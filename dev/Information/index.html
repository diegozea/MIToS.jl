<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Information · MIToS</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIToS</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../Installation/">Installation</a></li><li><a class="toctext" href="../Example/">Example</a></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../MSA/">MSA</a></li><li class="current"><a class="toctext" href>Information</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Counting-residues-1">Counting residues</a></li><li><a class="toctext" href="#Low-count-corrections-1">Low count corrections</a></li><li><a class="toctext" href="#Correction-for-data-redundancy-in-a-MSA-1">Correction for data redundancy in a MSA</a></li><li><a class="toctext" href="#Estimating-information-measures-on-an-MSA-1">Estimating information measures on an MSA</a></li><li><a class="toctext" href="#Corrected-Mutual-Information-1">Corrected Mutual Information</a></li><li><a class="toctext" href="#Visualize-Mutual-Information-1">Visualize Mutual Information</a></li></ul></li><li><a class="toctext" href="../SIFTS/">SIFTS</a></li><li><a class="toctext" href="../PDB/">PDB</a></li><li><a class="toctext" href="../Pfam/">Pfam</a></li></ul></li><li><a class="toctext" href="../Scripts/">Scripts</a></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../MSA_API/">MSA</a></li><li><a class="toctext" href="../Information_API/">Information</a></li><li><a class="toctext" href="../SIFTS_API/">SIFTS</a></li><li><a class="toctext" href="../PDB_API/">PDB</a></li><li><a class="toctext" href="../Pfam_API/">Pfam</a></li><li><a class="toctext" href="../Utils_API/">Utils</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Modules</li><li><a href>Information</a></li></ul><a class="edit-page" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/Information.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Information</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Module-Information-1" href="#Module-Information-1">Information</a></h1><p>The <code>Information</code> module of MIToS defines types and functions useful to calculate information measures (e.g. <em>Mutual Information</em> (MI) and <em>Entropy</em>) over a Multiple Sequence Alignment (MSA). This module was designed to count <code>Residue</code>s (defined in the <code>MSA</code> module) in special contingency tables (as fast as possible) and to derive probabilities from these counts. Also, includes methods for applying corrections to those tables, e.g. pseudocounts and pseudo frequencies. Finally, <code>Information</code> allows to use these probabilities and counts to estimate information measures and other frequency based values.  </p><pre><code class="language-julia">using MIToS.Information # to load the Information module</code></pre><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><ul><li>Estimate multi dimensional frequencies and probability tables from sequences, MSAs, etc...</li><li>Correction for small number of observations</li><li>Correction for data redundancy on a MSA</li><li>Estimate information measures</li><li>Calculate corrected mutual information between residues  </li></ul><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#Module-Information-1">Information</a></li><ul><li><a href="#Features-1">Features</a></li><li><a href="#Contents-1">Contents</a></li><li><a href="#Counting-residues-1">Counting residues</a></li><ul><ul><li><a href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1">Example: Plotting the probabilities of each residue in a sequence</a></li></ul></ul><li><a href="#Low-count-corrections-1">Low count corrections</a></li><li><a href="#Correction-for-data-redundancy-in-a-MSA-1">Correction for data redundancy in a MSA</a></li><li><a href="#Estimating-information-measures-on-an-MSA-1">Estimating information measures on an MSA</a></li><ul><ul><li><a href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></li></ul></ul><li><a href="#Corrected-Mutual-Information-1">Corrected Mutual Information</a></li><ul><ul><li><a href="#Example:-Estimating-corrected-MI-from-an-MSA-1">Example: Estimating corrected MI from an MSA</a></li></ul></ul><li><a href="#Visualize-Mutual-Information-1">Visualize Mutual Information</a></li></ul></ul><h2><a class="nav-anchor" id="Counting-residues-1" href="#Counting-residues-1">Counting residues</a></h2><p>MIToS Information module defines a multidimensional <code>ContingencyTable</code> type and two types wrapping it, <code>Counts</code> and <code>Probabilities</code>, to store occurrences or probabilities. The <code>ContingencyTable</code> type stores the contingency matrix, its marginal values and total. These types are parametric, taking three ordered parameters:</p><ul><li><code>T</code> : The type used for storing the counts or probabilities, e.g. <code>Float64</code>. It&#39;s</li></ul><p>possible to use <code>BigFloat</code> if more precision it&#39;s needed.</p><ul><li><code>N</code> : It&#39;s the dimension of the table and should be an <code>Int</code>.</li><li><code>A</code> : This should be a type, subtype of <code>ResidueAlphabet</code>, i.e.: <code>UngappedAlphabet</code>,</li></ul><p><code>GappedAlphabet</code> or <code>ReducedAlphabet</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>ContingencyTable</code> can be used for storing probabilities or counts. The wrapper types <code>Probabilities</code> and <code>Counts</code> are mainly intended to dispatch in methods that need to know if the matrix has probabilities or counts, e.g. <code>entropy</code>. In general, the use of <code>ContingencyTable</code> is recommended over the use of <code>Probabilities</code> and <code>Counts</code>.</p></div></div><p>In this way, a matrix for storing pairwise probabilities of residues (without gaps) can be initialized using:  </p><pre><code class="language-julia">using MIToS.Information

Pij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   0.0    0.0
R             │   0.0    0.0
N             │   0.0    0.0
D             │   0.0    0.0
C             │   0.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   0.0    0.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    0.0

total : 0.0</code></pre><p><strong>[High level interface]</strong> It is possible to use the functions <code>count</code> and <code>probabilities</code> to easily calculate the frequencies of sequences or columns of a MSA, where the number of sequences/columns determine the dimension of the resulting table.  </p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA # to use res&quot;...&quot; to create Vector{Residue}

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Nij[R,R] =   1     1   = 2

Nij = count(column_i, column_j)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 1.0  1.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  2.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 2.0  0.0  0.0  1.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  1.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   2.0    3.0
R             │   2.0    3.0
N             │   1.0    1.0
D             │   3.0    1.0
C             │   1.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   1.0    1.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    1.0

total : 10.0</code></pre><p>You can use <code>sum</code> to get the stored total:  </p><pre><code class="language-julia">sum(Nij) # There are 12 Residues, but 2 are gaps</code></pre><pre><code class="language-none">10.0</code></pre><p>Contingency tables can be indexed using <code>Int</code> or <code>Residue</code>s:  </p><pre><code class="language-julia">Nij[2, 2] # Use Int to index the table</code></pre><pre><code class="language-none">2.0</code></pre><pre><code class="language-julia">Nij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre><code class="language-none">2.0</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The number makes reference to the specific index in the table e.g <code>[2,2]</code> references the second row and the second column. The use of the number used to encode the residue to index the table is dangerous. The equivalent index number of a residue depends on the used alphabet and <code>Int(Residue(&#39;X&#39;))</code> will be always out of bounds.  </p></div></div><p>Indexing with <code>Residue</code>s works as expected. It uses the alphabet of the contingency table to find the index of the <code>Residue</code>.</p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Fij[R,R] =   1  1  1   = 3 # RHK

Fij = count(column_i, column_j, alphabet=alphabet)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    0.0    1.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    3.0    0.0    0.0    0.0    0.0    0.0
DE            │   2.0    0.0    0.0    1.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   2.0    4.0
NQST          │   1.0    1.0
RHK           │   3.0    4.0
DE            │   3.0    1.0
FWY           │   0.0    0.0
C             │   1.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 10.0</code></pre><pre><code class="language-julia">Fij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre><code class="language-none">3.0</code></pre><p>The function <code>getcontingencytable</code> allows to access the wrapped <code>ContingencyTable</code> in a <code>Counts</code> object. You can use it, in combination with <code>normalize</code> to get a contingency table of probabilities. The result can be wrapped inside a <code>Probabilities</code> object:  </p><pre><code class="language-julia">Probabilities(normalize(getcontingencytable(Fij)))</code></pre><pre><code class="language-none">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.1    0.0    0.1    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.1    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.3    0.0    0.0    0.0    0.0    0.0
DE            │   0.2    0.0    0.0    0.1    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.1    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.2    0.4
NQST          │   0.1    0.1
RHK           │   0.3    0.4
DE            │   0.3    0.1
FWY           │   0.0    0.0
C             │   0.1    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 1.0000000000000002</code></pre><h4><a class="nav-anchor" id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1">Example: Plotting the probabilities of each residue in a sequence</a></h4><p>Similar to the <code>count</code> function, the <code>probabilities</code> function can take at least one sequence (vector of residues) and returns the probabilities of each residue. Optionally, the keyword argument <code>alphabet</code> could be used to count some residues in the same cell of the table.  </p><pre><code class="language-julia">probabilities(res&quot;AARANHDDRDC&quot;, alphabet=alphabet)</code></pre><pre><code class="language-none">MIToS.Information.Probabilities{Float64,1,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.ReducedAlphabet} : 

table : 8-element Named Array{Float64,1}
Dim_1  │ 
───────┼──────────
AILMV  │  0.272727
NQST   │ 0.0909091
RHK    │  0.272727
DE     │  0.272727
FWY    │       0.0
C      │ 0.0909091
G      │       0.0
P      │       0.0

total : 1.0</code></pre><p>Here, we are going to use the <code>probabilities</code> function to get the residue probabilities of a particular sequence from <em>UniProt</em>.</p><p>use the <code>getsequence</code> function, from the <code>MSA</code> module, to get the sequence from a <code>FASTA</code> downloaded from UniProt.  </p><pre><code class="language-julia-repl">julia&gt; using MIToS.Information # to use the probabilities function

julia&gt; using MIToS.MSA # to use getsequence on the one sequence FASTA (canonical) from UniProt

julia&gt; seq = read(&quot;http://www.uniprot.org/uniprot/P29374.fasta&quot;, FASTA) # Small hack: read the single sequence as a MSA
AnnotatedMultipleSequenceAlignment with 0 annotations : 1×1257 Named Array{MIToS.MSA.Residue,2}
                                                                                                         Seq ╲ Col │   …
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼──────
sp|P29374|ARI4A_HUMAN AT-rich interactive domain-containing protein 4A OS=Homo sapiens OX=9606 GN=ARID4A PE=1 SV=3 │   …

julia&gt; probabilities(seq[1,:]) # Select the single sequence and calculate the probabilities
MIToS.Information.Probabilities{Float64,1,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.UngappedAlphabet} :

table : 20-element Named Array{Float64,1}
Dim_1  │
───────┼───────────
A      │   0.043755
R      │  0.0517104
N      │  0.0469372
D      │  0.0755768
C      │  0.0135243
Q      │   0.035004
E      │   0.134447
G      │   0.043755
H      │  0.0143198
⋮                 ⋮
K      │   0.109785
M      │  0.0159109
F      │  0.0190931
P      │  0.0445505
S      │   0.100239
T      │  0.0493238
W      │ 0.00636436
Y      │  0.0198886
V      │  0.0517104

total : 1.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In the previous example, using <code>getsequence(seq,1)</code> instead of <code>seq[1,:]</code> will return the sequence as a matrix with a single column to keep information for both dimensions. To use <code>probabilities</code> (or <code>count</code>) you can make use of the Julia&#39;s <code>vec</code> function to transform the matrix to a vector, e.g.: <code>probabilities(vec(getsequence(seq,1)))</code>.</p></div></div><div></div><pre><code class="language-julia">using Plots # We choose Plots because it&#39;s intuitive, concise and backend independent
gr(size=(600,300))</code></pre><pre><code class="language-none">Plots.GRBackend()</code></pre><p>You can plot together with the probabilities of each residue in a given sequence, the probabilities of each residue estimated with the BLOSUM62 substitution matrix. That matrix is exported as a constant by the <code>Information</code> module as <code>BLOSUM62_Pi</code>.  </p><pre><code class="language-julia">bar(
    1:20,
    [ frequencies  BLOSUM62_Pi ],
    lab = [ &quot;Sequence&quot;  &quot;BLOSUM62&quot;   ],
    alpha=0.5
    )</code></pre><pre><code class="language-none">/home/travis/.julia/packages/GR/KGODl/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../inf_plotfreq.png" alt/>  </p><h2><a class="nav-anchor" id="Low-count-corrections-1" href="#Low-count-corrections-1">Low count corrections</a></h2><p>Low number of observations can lead to sparse contingency tables, that lead to wrong probability estimations. It is shown in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a> that low-count corrections, can lead to improvements in the contact prediction capabilities of the Mutual Information. The Information module has available two low-count corrections:  </p><ol><li><a href="https://en.wikipedia.org/wiki/Additive_smoothing">Additive Smoothing<img src="../assets/external-link.png" alt/></a>; the constant value pseudocount described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a>.  </li><li>BLOSUM62 based pseudo frequencies of residues pairs, similar to <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC146917/"><em>Altschul et. al. 1997</em><img src="../assets/external-link.png" alt/></a>.  </li></ol><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)

filtercolumns!(msa, columngapfraction(msa) .&lt; 0.5) # delete columns with 50% gaps or more

column_i = msa[:,1]
column_j = msa[:,2]</code></pre><pre><code class="language-none">251-element Named Array{MIToS.MSA.Residue,1}
Seq                        │ 
───────────────────────────┼──
A0A2A2LU69_9BILA/10-118    │ Q
G1RVK4_NOMLE/46-161        │ R
A0A194PY65_PAPXU/3-116     │ -
A0A0V0S2G9_9BILA/731-840   │ S
A0A016T9R4_9BILA/3-89      │ -
A0A1V4KDS6_PATFA/159-270   │ -
M4A0G1_XIPMA/29-139        │ F
A0A1B0BJN8_9MUSC/16-132    │ -
A0A1I8N4P6_MUSDO/6-107     │ -
⋮                            ⋮
A0A0M3QXL3_DROBS/2-105     │ -
A0A195FWH0_9HYME/356-468   │ -
A0A182I7Y1_ANOAR/4-112     │ -
T1FXF3_HELRO/1-90          │ -
A0A2I3GIP3_NOMLE/10-125    │ R
G3WPK1_SARHA/11-126        │ H
RM55_MOUSE/9-124           │ H
M3XPJ7_MUSPF/10-125        │ R
A0A182GHC0_AEDAL/6-119     │ -</code></pre><p>If you have a preallocated <code>ContingencyTable</code> you can use <code>count!</code> to fill it, this prevent to create a new table as <code>count</code> do. However, you should note that <code>count!</code> <strong>adds the new counts to the pre existing values</strong>, so in this case, we want to start with a table initialized with zeros.  </p><pre><code class="language-julia">using MIToS.Information

const alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

Nij = ContingencyTable(Float64, Val{2}, alphabet)</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
DE            │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.0    0.0
NQST          │   0.0    0.0
RHK           │   0.0    0.0
DE            │   0.0    0.0
FWY           │   0.0    0.0
C             │   0.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 0.0</code></pre><pre><code class="language-julia">#      table  weights         pseudocount      sequences...
count!(Nij,   NoClustering(), NoPseudocount(), column_i, column_j)</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    2.0    1.0    0.0    0.0    0.0    2.0    1.0
NQST          │   4.0   17.0    2.0    0.0    3.0    5.0    1.0    0.0
RHK           │   2.0    8.0   27.0    0.0    9.0   12.0    1.0    0.0
DE            │   2.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    2.0    1.0    0.0    1.0    0.0    0.0    0.0
C             │   0.0   10.0   10.0    0.0    2.0    3.0    0.0    0.0
G             │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   6.0    9.0
NQST          │  32.0   40.0
RHK           │  59.0   41.0
DE            │   2.0    0.0
FWY           │   4.0   15.0
C             │  25.0   20.0
G             │   1.0    4.0
P             │   1.0    1.0

total : 130.0</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>You can use <code>NoClustering()</code> in places where clustering weights are required to not use weights. Also, <code>NoPseudocount()</code> in places where pseudocount values are required to not use pseudocounts.</p></div></div><p>In cases like the above, where there are few observations, it is possible to apply a constant pseudocount to the counting table.  This module defines the type <code>AdditiveSmoothing</code> and the correspond <code>fill!</code> and  <code>apply_pseudocount!</code> methods to efficiently add or fill with a constant value each element of the table.</p><pre><code class="language-julia">apply_pseudocount!(Nij, AdditiveSmoothing(1.0))</code></pre><pre><code class="language-none">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    3.0    2.0    1.0    1.0    1.0    3.0    2.0
NQST          │   5.0   18.0    3.0    1.0    4.0    6.0    2.0    1.0
RHK           │   3.0    9.0   28.0    1.0   10.0   13.0    2.0    1.0
DE            │   3.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    3.0    2.0    1.0    2.0    1.0    1.0    1.0
C             │   1.0   11.0   11.0    1.0    3.0    4.0    1.0    1.0
G             │   1.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   2.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  14.0   17.0
NQST          │  40.0   48.0
RHK           │  67.0   49.0
DE            │  10.0    8.0
FWY           │  12.0   23.0
C             │  33.0   28.0
G             │   9.0   12.0
P             │   9.0    9.0

total : 194.0</code></pre><p><strong>[High level interface.]</strong> The <code>count</code> function has a <code>pseudocounts</code> keyword argument that can take a <code>AdditiveSmoothing</code> value to easily calculate occurrences with pseudocounts. Also the alphabet keyword argument can be used to chage the default alphabet (i.e. )</p><pre><code class="language-julia">count(column_i, column_j, pseudocounts=AdditiveSmoothing(1.0), alphabet=alphabet)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    3.0    2.0    1.0    1.0    1.0    3.0    2.0
NQST          │   5.0   18.0    3.0    1.0    4.0    6.0    2.0    1.0
RHK           │   3.0    9.0   28.0    1.0   10.0   13.0    2.0    1.0
DE            │   3.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    3.0    2.0    1.0    2.0    1.0    1.0    1.0
C             │   1.0   11.0   11.0    1.0    3.0    4.0    1.0    1.0
G             │   1.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   2.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  14.0   17.0
NQST          │  40.0   48.0
RHK           │  67.0   49.0
DE            │  10.0    8.0
FWY           │  12.0   23.0
C             │  33.0   28.0
G             │   9.0   12.0
P             │   9.0    9.0

total : 194.0</code></pre><p>To use the conditional probability matrix <code>BLOSUM62_Pij</code> in the calculation of pseudo frequencies <span>$G$</span> for the pair of residues <span>$a$</span>, <span>$b$</span>, it should be calculated first the real frequencies/probabilities <span>$p_{a,b}$</span>. The observed probabilities are then used to estimate the pseudo frequencies.  </p><div>\[G_{ab} = \sum_{cd}  p_{cd} \cdot BLOSUM62( a | c ) \cdot BLOSUM62( b | d )\]</div><p>Finally, the probability <span>$P$</span> of each pair of residues <span>$a$</span>, <span>$b$</span> between the columns <span>$i$</span>, <span>$j$</span> is the weighted mean between the observed frequency <span>$p$</span> and BLOSUM62-based pseudo frequency <span>$G$</span>, where α is generally the number of clusters or the number of sequences of the MSA and β is an empiric weight value. β was determined to be close to <code>8.512</code>.  </p><div>\[P_{ab} = \frac{\alpha \cdot p_{ab} + \beta \cdot G_{ab} }{\alpha + \beta}\]</div><p>This could be easily achieved using the <code>pseudofrequencies</code> keyword argument of the <code>probabilities</code> function. That argument can take a <code>BLOSUM_Pseudofrequencies</code> object that is created with α and β as first and second argument, respectively.</p><pre><code class="language-julia">Pij = probabilities(column_i, column_j, pseudofrequencies=BLOSUM_Pseudofrequencies(nsequences(msa), 8.512))</code></pre><pre><code class="language-none">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │           A            R  …            Y            V
──────────────┼──────────────────────────────────────────────────────
A             │ 0.000142908    0.0075939  …   7.76763e-5   9.95548e-5
R             │  0.00772558    0.0673799       0.0225557  0.000202234
N             │  9.64158e-5   8.71683e-5      5.03437e-5    7.1042e-5
D             │  8.00906e-5   7.40001e-5      4.49757e-5   8.74722e-5
C             │ 0.000224617     0.015097      0.00758641  0.000126697
Q             │  9.35478e-5   9.14959e-5      5.41118e-5   0.00752563
E             │  9.80385e-5  0.000101904      6.07924e-5   8.42353e-5
G             │ 0.000101064   9.44132e-5      5.22545e-5   7.04391e-5
H             │  5.59106e-5   5.59221e-5      4.09321e-5   4.13428e-5
⋮                         ⋮            ⋮  ⋱            ⋮            ⋮
K             │ 0.000168605  0.000191384     0.000125256  0.000140848
M             │  3.57874e-5   3.61969e-5      2.14301e-5    2.5536e-5
F             │  6.65783e-5   5.31368e-5      3.81743e-5   4.26134e-5
P             │  5.02375e-5   4.96049e-5      2.97028e-5   4.56639e-5
S             │ 0.000160719    0.0150369      8.31195e-5  0.000117318
T             │ 0.000102889  0.000103082      5.60785e-5   7.50731e-5
W             │  1.21225e-5   1.24975e-5      7.72719e-6   8.65093e-6
Y             │  4.44681e-5   4.35146e-5      2.99456e-5   3.11897e-5
V             │  9.45992e-5   9.21482e-5  …   5.29008e-5    6.3349e-5

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │       Dim_1        Dim_2
──────────────┼─────────────────────────
A             │   0.0244776   0.00955496
R             │    0.347106     0.106384
N             │   0.0237304   0.00124081
D             │   0.0161538   0.00106531
C             │    0.189336     0.151575
Q             │   0.0535322    0.0458474
E             │  0.00155238   0.00137584
G             │  0.00889809    0.0315651
H             │   0.0307239     0.203753
⋮                         ⋮            ⋮
K             │    0.069772   0.00161526
M             │ 0.000546285   0.00807655
F             │   0.0232668    0.0762266
P             │  0.00825598    0.0082319
S             │    0.143734     0.188571
T             │   0.0238898    0.0688152
W             │ 0.000188462   0.00780421
Y             │   0.0081499      0.03108
V             │  0.00139872   0.00899212

total : 1.0000000000000002</code></pre><p>You can also use <code>apply_pseudofrequencies!</code> in a previously filled probability contingency table. i.e. <code>apply_pseudofrequencies!(Pij, BLOSUM_Pseudofrequencies(α, β))</code></p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>BLOSUM_Pseudofrequencies</code> can be only be applied in <strong>normalized/probability</strong> tables with <code>UngappedAlphabet</code>.  </p></div></div><h2><a class="nav-anchor" id="Correction-for-data-redundancy-in-a-MSA-1" href="#Correction-for-data-redundancy-in-a-MSA-1">Correction for data redundancy in a MSA</a></h2><p>A simple way to reduce redundancy in a MSA without losing sequences, is clusterization and sequence weighting. The weight of each sequence should be 1/N, where N is the number of sequences in its cluster. The <code>Clusters</code> type of the <code>MSA</code> module stores the weights. This vector of weights can be extracted (with the <code>getweight</code> function) and used by the <code>count</code> and <code>probabilities</code> functions with the keyword argument <code>weights</code>. Also it&#39;s possible to use the <code>Clusters</code> as second argument of the function <code>count!</code>.  </p><pre><code class="language-julia">clusters = hobohmI(msa, 62) # from MIToS.MSA</code></pre><pre><code class="language-none">MIToS.MSA.Clusters([2, 53, 37, 2, 8, 5, 7, 3, 1, 3  …  1, 1, 1, 1, 2, 2, 1, 1, 2, 1], [1, 2, 3, 4, 5, 6, 7, 8, 3, 2  …  15, 3, 19, 3, 77, 2, 2, 2, 2, 3], [0.5, 0.0188679, 0.027027, 0.5, 0.125, 0.2, 0.142857, 0.333333, 0.027027, 0.0188679  …  0.25, 0.027027, 0.0909091, 0.027027, 1.0, 0.0188679, 0.0188679, 0.0188679, 0.0188679, 0.027027])</code></pre><pre><code class="language-julia">count(msa[:,1], msa[:,2], weights=clusters)</code></pre><pre><code class="language-none">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │         A          R  …          Y          V
──────────────┼──────────────────────────────────────────────
A             │       0.0  0.0188679  …        0.0        0.0
R             │       0.2    1.63208      0.537736        0.0
N             │       0.0        0.0           0.0        0.0
D             │       0.0        0.0           0.0        0.0
C             │       0.0   0.143868         0.125        0.0
Q             │       0.0        0.0           0.0        0.5
E             │       0.0        0.0           0.0        0.0
G             │       0.0        0.0           0.0        0.0
H             │       0.0        0.0           0.0        0.0
⋮                       ⋮          ⋮  ⋱          ⋮          ⋮
K             │       0.0        0.0           0.0        0.0
M             │       0.0        0.0           0.0        0.0
F             │       0.0        0.0           0.0        0.0
P             │       0.0        0.0           0.0        0.0
S             │       0.0   0.333333           0.0        0.0
T             │       0.0        0.0           0.0        0.0
W             │       0.0        0.0           0.0        0.0
Y             │       0.0        0.0           0.0        0.0
V             │       0.0        0.0  …        0.0        0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │     Dim_1      Dim_2
──────────────┼─────────────────────
A             │   1.16173        0.2
R             │   7.61854    2.12814
N             │       1.5        0.0
D             │  0.666667        0.0
C             │   3.77201    3.66588
Q             │       4.5    3.27703
E             │       0.0        0.0
G             │ 0.0909091    1.41173
H             │ 0.0754717   0.721698
⋮                       ⋮          ⋮
K             │   1.92063        0.0
M             │       0.0        1.0
F             │       3.0    3.88792
P             │       0.2        0.5
S             │   6.38196     9.7943
T             │     1.125    4.44444
W             │       0.0  0.0188679
Y             │ 0.0188679   0.662736
V             │       0.0        0.5

total : 33.86512090380015</code></pre><h2><a class="nav-anchor" id="Estimating-information-measures-on-an-MSA-1" href="#Estimating-information-measures-on-an-MSA-1">Estimating information measures on an MSA</a></h2><p>The <code>Information</code> module has a number of functions defined to calculate information measures from <code>Counts</code> and <code>Probabilities</code>:</p><ul><li><code>entropy</code> : Shannon entropy (H)</li><li><code>marginal_entropy</code> : Shannon entropy (H) of the marginals</li><li><code>kullback_leibler</code> : Kullback-Leibler (KL) divergence</li><li><code>mutual_information</code> : Mutual Information (MI)</li><li><code>normalized_mutual_information</code> : Normalized Mutual Information (nMI) by Entropy</li><li><code>gap_intersection_percentage</code></li><li><code>gap_union_percentage</code></li></ul><p>Information measure functions take optionally the base as the last positional argument (default: <code>e</code>). You can use <code>2.0</code> to measure information in bits.</p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

Ni = count(res&quot;PPCDPPPPPKDKKKKDDGPP&quot;) # Ni has the count table of residues in this low complexity sequence

H = entropy(Ni) # returns the Shannon entropy in nats (base e)</code></pre><pre><code class="language-none">1.327362863420189</code></pre><pre><code class="language-julia">H = entropy(Ni, 2.0) # returns the Shannon entropy in bits (base 2)</code></pre><pre><code class="language-none">1.9149798205164812</code></pre><p>Information module defines special iteration functions to easily and efficiently compute a measure over a MSA. In particular, <code>mapcolfreq!</code> and <code>mapseqfreq!</code> map a function that takes a table of <code>Counts</code> or <code>Probabilities</code>. The table is filled in place with the counts or probabilities of each column or sequence of a MSA, respectively. <code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> are similar, but they fill the table using pairs of columns or sequences, respectively.  </p><p>This functions take three positional arguments: the function <code>f</code> to be calculated, the <code>msa</code> and <code>table</code> of <code>Counts</code> or <code>Probabilities</code>.  </p><p>After that, this function takes some keyword arguments:</p><ul><li><code>weights</code> (default: <code>NoClustering()</code>) : Weights to be used for table counting.</li><li><code>pseudocounts</code> (default: <code>NoPseudocount()</code>) : <code>Pseudocount</code> object to be applied to table.</li><li><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>) : <code>Pseudofrequencies</code> to be</li></ul><p>applied to the normalized (probabilities) table.  </p><p><code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> also have a fourth positional argument <code>usediagonal</code> that indicates if the function should be applied to identical element pairs (default to <code>Val{true}</code>). This two functions also have an extra keyword argument <code>diagonalvalue</code> (default to zero) to indicate the value used to fill the diagonal elements if <code>usediagonal</code> is <code>Val{false}</code>.  </p><h4><a class="nav-anchor" id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></h4><p>In this example, we are going to use <code>mapcolfreq!</code> and <code>mapcolpairfreq!</code> to estimate Shannon <code>entropy</code> of MSA columns <em>H(X)</em> and the joint entropy <em>H(X, Y)</em> of columns pairs, respectively.  </p><div></div><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)</code></pre><pre><code class="language-none">AnnotatedMultipleSequenceAlignment with 275 annotations : 251×116 Named Array{MIToS.MSA.Residue,2}
                 Seq ╲ Col │  35   36   37   38   39  …  183  184  185  186  187
───────────────────────────┼────────────────────────────────────────────────────
A0A2A2LU69_9BILA/10-118    │   -    -    -    -    -  …    K    L    -    -    -
G1RVK4_NOMLE/46-161        │   -    L    R    Q    S       Q    F    W    T    R
A0A194PY65_PAPXU/3-116     │   -    -    -    -    -       K    Y    I    K    K
A0A0V0S2G9_9BILA/731-840   │   -    -    -    -    -       Y    L    W    K    K
A0A016T9R4_9BILA/3-89      │   -    -    -    -    -       -    -    -    -    -
A0A1V4KDS6_PATFA/159-270   │   -    -    -    -    -       K    F    W    K    K
M4A0G1_XIPMA/29-139        │   -    -    -    -    -       H    L    W    K    K
A0A1B0BJN8_9MUSC/16-132    │   -    -    -    -    -       K    Y    I    K    K
A0A1I8N4P6_MUSDO/6-107     │   -    -    -    -    -       K    Y    I    K    K
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A0M3QXL3_DROBS/2-105     │   -    -    -    -    -       K    Y    I    K    K
A0A195FWH0_9HYME/356-468   │   -    -    -    -    -       N    F    K    -    -
A0A182I7Y1_ANOAR/4-112     │   -    -    -    -    -       K    Y    M    K    K
T1FXF3_HELRO/1-90          │   -    -    -    -    -       Y    L    W    K    K
A0A2I3GIP3_NOMLE/10-125    │   -    L    R    Q    S       Q    F    W    T    R
G3WPK1_SARHA/11-126        │   -    L    Q    Q    N       K    F    W    K    K
RM55_MOUSE/9-124           │   L    L    R    H    C       Q    F    W    T    K
M3XPJ7_MUSPF/10-125        │   -    L    Q    Q    P       R    F    W    T    K
A0A182GHC0_AEDAL/6-119     │   -    -    -    -    -  …    N    F    I    R    K</code></pre><p>We are going to count residues to estimate the entropy. The <code>entropy</code> estimation is performed over a rehused <code>Counts</code> object. The result will be a vector containing the values estimated over each column without counting gaps (<code>UngappedAlphabet</code>).  </p><pre><code class="language-julia">using MIToS.Information

Hx = mapcolfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{1}, UngappedAlphabet())))</code></pre><pre><code class="language-none">1×116 Named Array{Float64,2}
   Function ╲ Col │        35         36  …        186        187
──────────────────┼──────────────────────────────────────────────
StatsBase.entropy │  0.223718   0.152005  …    1.40053   0.392674</code></pre><p>If we want the <strong>joint entropy</strong> between columns pairs, we need to use a bidimensional table of <code>Counts</code> and <code>mapcolpairfreq!</code>.</p><pre><code class="language-julia">Hxy = mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))</code></pre><pre><code class="language-none">116×116 Named PairwiseListMatrices.PairwiseListMatrix{Float64,true,Array{Float64,1}}
Col1 ╲ Col2 │        35         36  …        186        187
────────────┼──────────────────────────────────────────────
35          │  0.223718   0.223718  …    1.32844   0.636514
36          │  0.223718   0.152005       1.31991   0.665504
37          │   1.17117    1.16219       2.17753    1.40666
38          │  0.644482   0.783024       1.91145    1.38292
39          │   1.65034    1.85736       2.72266    2.13018
40          │   1.74715    1.62878       2.69412    1.99026
41          │   1.32973    1.35369       2.62046    1.96563
42          │   1.57489    1.47441       2.72617     2.0551
43          │   1.47256    1.42538       2.58854    1.91578
⋮                     ⋮          ⋮  ⋱          ⋮          ⋮
179         │  0.362501   0.419556       2.72026    2.06222
180         │   1.29175    1.32064        2.6316    2.15441
181         │  0.228632   0.158411        1.4491   0.456464
182         │   1.29855    1.40964       2.89329     2.2956
183         │   0.94338   0.973938       2.44262     1.7813
184         │  0.453351   0.315396       2.24717     1.4562
185         │  0.228632   0.158411       2.26862    1.55818
186         │   1.32844    1.31991       1.40053      1.488
187         │  0.636514   0.665504  …      1.488   0.392674</code></pre><p>In the above examples, we indicate the type of each occurrence in the counting and the probability table to use. Also, it&#39;s possible for some measures as <strong>entropy</strong> and <strong>mutual information</strong>, to estimate the values only with the count table (without calculate the probability table). Estimating measures only with a <code>ResidueCount</code> table, when this is possible, should be faster than using a probability table.  </p><pre><code class="language-julia">Time_Pab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Probabilities(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

Time_Nab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

using Plots
gr()

histogram( [Time_Pab Time_Nab],
    labels = [&quot;Using ResidueProbability&quot; &quot;Using ResidueCount&quot;],
    xlabel = &quot;Execution time [seconds]&quot; )</code></pre><pre><code class="language-none">/home/travis/.julia/packages/GR/KGODl/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../inf_entropy.png" alt/>   </p><h2><a class="nav-anchor" id="Corrected-Mutual-Information-1" href="#Corrected-Mutual-Information-1">Corrected Mutual Information</a></h2><p>MIToS ships with two methods to easily calculate corrected mutual information.   The first is the algorithm described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a>. This algorithm can be accessed through the <code>buslje09</code> function and includes:  </p><ol><li>Low count correction using <code>AdditiveSmoothing</code></li><li>Sequence weighting after a <code>hobohmI</code> clustering</li><li>Average Product Correction (APC) proposed by</li></ol><p><a href="http://bioinformatics.oxfordjournals.org/content/24/3/333">Dunn et. al. 2008<img src="../assets/external-link.png" alt/></a>, through the <code>APC!</code> function that takes a MI matrix.</p><ol><li>Z score correction using the functions <code>shuffle!</code> from the MSA module and <code>zscore</code></li></ol><p>from the <code>PairwiseListMatrices</code> package.  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.buslje09" href="#MIToS.Information.buslje09"><code>MIToS.Information.buslje09</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>buslje09</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong>.</p><p>keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - lambda      Float64   0.05    Low count value
  - clustering  Bool      true    Sequence clustering (Hobohm I)
  - threshold             62      Percent identity threshold for clustering
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       100     Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples
  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score
  - MI or MIp</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/8799e501d56d9dcf4133b53421edaf4b4bf12a35/src/Information/CorrectedMutualInformation.jl#L19-L42">source</a></section><p>The second, implemented in the <code>BLMI</code> function, has the same corrections that the above algorithm, but use BLOSUM62 pseudo frequencies. This function is <strong>slower</strong> than <code>buslje09</code> (at the same number of samples), but gives <strong>better performance</strong> (for structural contact prediction) when the MSA has <strong>less than 400 clusters</strong> after a Hobohm I at 62% identity.  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIToS.Information.BLMI" href="#MIToS.Information.BLMI"><code>MIToS.Information.BLMI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>BLMI</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong> but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.</p><p>Keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies
  - lambda      Float64   0.0     Low count value
  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       50      Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score (ZBLMI)
  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/8799e501d56d9dcf4133b53421edaf4b4bf12a35/src/Information/CorrectedMutualInformation.jl#L94-L117">source</a></section><h4><a class="nav-anchor" id="Example:-Estimating-corrected-MI-from-an-MSA-1" href="#Example:-Estimating-corrected-MI-from-an-MSA-1">Example: Estimating corrected MI from an MSA</a></h4><div></div><pre><code class="language-julia">using MIToS.MSA
using MIToS.Information

msa = read(&quot;http://pfam.xfam.org/family/PF16078/alignment/full&quot;, Stockholm)
ZMIp, MIp  = buslje09(msa)
ZMIp</code></pre><pre><code class="language-none">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │           15            16  …            59            60
────────────┼──────────────────────────────────────────────────────────
15          │          NaN      0.671575  …      -3.11434       1.00521
16          │     0.671575           NaN         0.444187        3.0511
17          │      2.34645      0.944037         0.965957    -0.0136989
18          │     0.591695      -1.69525         -1.80403     -0.678965
19          │     -3.42378      -1.23663            7.047      -2.37453
20          │     -3.72666       1.32665        -0.410894      -1.38378
21          │     0.909906      -2.61584          3.84086     -0.932376
27          │     -3.73436    -0.0175735        -0.054194      -3.59973
28          │     -3.88585      -4.30775         -1.67966      -4.46148
⋮                        ⋮             ⋮  ⋱             ⋮             ⋮
52          │     -2.13758      0.196918          4.15349       -1.5019
53          │     -1.42717       6.01077          9.40875     0.0649704
54          │      4.14135      -2.07144         -2.58534       0.42282
55          │     -1.15821     -0.223075          1.45708      0.209268
56          │     -3.54667     -0.331172          7.62715     -0.328363
57          │     0.716198      -3.61325          5.92522       -1.7006
58          │     -2.85462       6.14661          7.84587       4.70466
59          │     -3.11434      0.444187              NaN       3.02594
60          │      1.00521        3.0511  …       3.02594           NaN</code></pre><pre><code class="language-julia">ZBLMIp, BLMIp  = BLMI(msa)
ZBLMIp</code></pre><pre><code class="language-none">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │           15            16  …            59            60
────────────┼──────────────────────────────────────────────────────────
15          │          NaN    -0.0450545  …     -0.036915   -0.00769414
16          │   -0.0450545           NaN       -0.0102239     0.0372196
17          │   -0.0210853    -0.0369195       0.00873277    -0.0252115
18          │    0.0122675    -0.0412662       -0.0294778     0.0103914
19          │   -0.0467111    -0.0209868         0.104964    -0.0329703
20          │   -0.0384957    0.00661179       -0.0213431    0.00971171
21          │    0.0085977    -0.0252071        0.0763177    -0.0075686
27          │    -0.031003    -0.0085647      -0.00960699    -0.0530898
28          │   -0.0175925    -0.0627666       -0.0407835    -0.0458722
⋮                        ⋮             ⋮  ⋱             ⋮             ⋮
52          │   0.00987037     0.0103642         0.027755   -0.00159873
53          │  -0.00833956      0.105136         0.137323    0.00474555
54          │    0.0151337   -0.00672509       0.00146536   -0.00599631
55          │     0.006021      0.010201        0.0127117     0.0141629
56          │    -0.019085   -0.00144585        0.0832875   -0.00779968
57          │    0.0121505    -0.0591763        0.0604599    -0.0388605
58          │   -0.0186695     0.0988717        0.0605095     0.0656851
59          │    -0.036915    -0.0102239              NaN    0.00427532
60          │  -0.00769414     0.0372196  …    0.00427532           NaN</code></pre><h2><a class="nav-anchor" id="Visualize-Mutual-Information-1" href="#Visualize-Mutual-Information-1">Visualize Mutual Information</a></h2><p>You can use the function of the <code>Plots</code> package to visualize the Mutual Information (MI) network between residues. As an example, we are going to visualize the MI between residues of the Pfam domain <em>PF16078</em>. The <code>heatmap</code> is the simplest way to visualize the values of the Mutual Information matrix.  </p><pre><code class="language-julia">using Plots
gr()

heatmap(ZMIp, yflip=true)</code></pre><pre><code class="language-none">/home/travis/.julia/packages/GR/KGODl/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../inf_heatmap.png" alt/>   </p><p>ZMIp is a Z score of the corrected MIp against its distribution on a random MSA (shuffling the residues in each sequence), so pairs with highest values are more likely to co-evolve. Here, we are going to use the top 1% pairs of MSA columns.  </p><pre><code class="language-julia">using PairwiseListMatrices # to use getlist
using Statistics # to use quantile

threshold = quantile(getlist(ZMIp), 0.99)</code></pre><pre><code class="language-none">9.972252169359093</code></pre><pre><code class="language-julia">ZMIp[ ZMIp .&lt; threshold ] .= NaN
heatmap(ZMIp, yflip=true)</code></pre><pre><code class="language-none">/home/travis/.julia/packages/GR/KGODl/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../inf_heatmap_top.png" alt/>   </p><p>We are going to calculate the cMI (cumulative mutual information) value of each node. Where cMI is a mutual information score per position that characterizes the extent of mutual information &quot;interactions&quot; in its neighbourhood. This score is calculated as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network and we are going to indicate it using the node color. To calculate cMI we are going to use the <code>cumulative</code> function:   </p><pre><code class="language-julia">cMI = cumulative(ZMIp, threshold)</code></pre><pre><code class="language-none">1×39 Named Array{Float64,2}
Function ╲ Col2 │      15       16       17  …       58       59       60
────────────────┼────────────────────────────────────────────────────────
cumulative      │     0.0      0.0      0.0  …  10.7217      0.0      0.0</code></pre><div></div><footer><hr/><a class="previous" href="../MSA/"><span class="direction">Previous</span><span class="title">MSA</span></a><a class="next" href="../SIFTS/"><span class="direction">Next</span><span class="title">SIFTS</span></a></footer></article></body></html>
