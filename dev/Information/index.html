<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Information · MIToS</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MIToS</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Example/">Example</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../MSA/">MSA</a></li><li class="is-active"><a class="tocitem" href>Information</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Counting-residues"><span>Counting residues</span></a></li><li><a class="tocitem" href="#Low-count-corrections"><span>Low count corrections</span></a></li><li><a class="tocitem" href="#Correction-for-data-redundancy-in-a-MSA"><span>Correction for data redundancy in a MSA</span></a></li><li><a class="tocitem" href="#Estimating-information-measures-on-an-MSA"><span>Estimating information measures on an MSA</span></a></li><li><a class="tocitem" href="#Corrected-Mutual-Information"><span>Corrected Mutual Information</span></a></li><li><a class="tocitem" href="#Visualize-Mutual-Information"><span>Visualize Mutual Information</span></a></li></ul></li><li><a class="tocitem" href="../SIFTS/">SIFTS</a></li><li><a class="tocitem" href="../PDB/">PDB</a></li><li><a class="tocitem" href="../Pfam/">Pfam</a></li></ul></li><li><span class="tocitem">Cookbook</span><ul><li><a class="tocitem" href="../01_Change_B_factors/">Change B-factors</a></li><li><a class="tocitem" href="../02_Linking_structural_and_evolutionary_information/">Linking structural and evolutionary information</a></li><li><a class="tocitem" href="../03_RMSF/">Root Mean Squared Fluctuation (RMSF)</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../MSA_API/">MSA</a></li><li><a class="tocitem" href="../Information_API/">Information</a></li><li><a class="tocitem" href="../SIFTS_API/">SIFTS</a></li><li><a class="tocitem" href="../PDB_API/">PDB</a></li><li><a class="tocitem" href="../Pfam_API/">Pfam</a></li><li><a class="tocitem" href="../Utils_API/">Utils</a></li></ul></li><li><a class="tocitem" href="../Scripts/">Scripts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Information</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Information</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/Information.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Information"><a class="docs-heading-anchor" href="#Module-Information">Information</a><a id="Module-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Information" title="Permalink"></a></h1><p>The <code>Information</code> module of MIToS defines types and functions useful to calculate information measures (e.g. <em>Mutual Information</em> (MI) and <em>Entropy</em>) over a Multiple Sequence Alignment (MSA). This module was designed to count <code>Residue</code>s (defined in the <code>MSA</code> module) in special contingency tables (as fast as possible) and to derive probabilities from these counts. Also, includes methods for applying corrections to those tables, e.g. pseudocounts and pseudo frequencies. Finally, <code>Information</code> allows to use these probabilities and counts to estimate information measures and other frequency based values.  </p><pre><code class="language-julia">using MIToS.Information # to load the Information module</code></pre><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li>Estimate multi dimensional frequencies and probability tables from sequences, MSAs, etc...</li><li>Correction for small number of observations</li><li>Correction for data redundancy on a MSA</li><li>Estimate information measures</li><li>Calculate corrected mutual information between residues  </li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Module-Information">Information</a></li><ul><li><a href="#Features">Features</a></li><li><a href="#Contents">Contents</a></li><li><a href="#Counting-residues">Counting residues</a></li><ul><ul><li><a href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence">Example: Plotting the probabilities of each residue in a sequence</a></li></ul></ul><li><a href="#Low-count-corrections">Low count corrections</a></li><li><a href="#Correction-for-data-redundancy-in-a-MSA">Correction for data redundancy in a MSA</a></li><li><a href="#Estimating-information-measures-on-an-MSA">Estimating information measures on an MSA</a></li><ul><ul><li><a href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></li></ul></ul><li><a href="#Corrected-Mutual-Information">Corrected Mutual Information</a></li><ul><ul><li><a href="#Example:-Estimating-corrected-MI-from-an-MSA">Example: Estimating corrected MI from an MSA</a></li></ul></ul><li><a href="#Visualize-Mutual-Information">Visualize Mutual Information</a></li></ul></ul><h2 id="Counting-residues"><a class="docs-heading-anchor" href="#Counting-residues">Counting residues</a><a id="Counting-residues-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-residues" title="Permalink"></a></h2><p>MIToS Information module defines a multidimensional <code>ContingencyTable</code> type and two types wrapping it, <code>Counts</code> and <code>Probabilities</code>, to store occurrences or probabilities. The <code>ContingencyTable</code> type stores the contingency matrix, its marginal values and total. These types are parametric, taking three ordered parameters:</p><ul><li><code>T</code> : The type used for storing the counts or probabilities, e.g. <code>Float64</code>. It&#39;s</li></ul><p>possible to use <code>BigFloat</code> if more precision it&#39;s needed.</p><ul><li><code>N</code> : It&#39;s the dimension of the table and should be an <code>Int</code>.</li><li><code>A</code> : This should be a type, subtype of <code>ResidueAlphabet</code>, i.e.: <code>UngappedAlphabet</code>,</li></ul><p><code>GappedAlphabet</code> or <code>ReducedAlphabet</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ContingencyTable</code> can be used for storing probabilities or counts. The wrapper types <code>Probabilities</code> and <code>Counts</code> are mainly intended to dispatch in methods that need to know if the matrix has probabilities or counts, e.g. <code>entropy</code>. In general, the use of <code>ContingencyTable</code> is recommended over the use of <code>Probabilities</code> and <code>Counts</code>.</p></div></div><p>In this way, a matrix for storing pairwise probabilities of residues (without gaps) can be initialized using:  </p><pre><code class="language-julia">using MIToS.Information

Pij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   0.0    0.0
R             │   0.0    0.0
N             │   0.0    0.0
D             │   0.0    0.0
C             │   0.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   0.0    0.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    0.0

total : 0.0</pre><p><strong>[High level interface]</strong> It is possible to use the functions <code>count</code> and <code>probabilities</code> to easily calculate the frequencies of sequences or columns of a MSA, where the number of sequences/columns determine the dimension of the resulting table.  </p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA # to use res&quot;...&quot; to create Vector{Residue}

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Nij[R,R] =   1     1   = 2

Nij = count(column_i, column_j)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 1.0  1.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  2.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 2.0  0.0  0.0  1.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  1.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
H             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
K             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   2.0    3.0
R             │   2.0    3.0
N             │   1.0    1.0
D             │   3.0    1.0
C             │   1.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
H             │   1.0    1.0
⋮                   ⋮      ⋮
K             │   0.0    0.0
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    1.0

total : 10.0</pre><p>You can use <code>sum</code> to get the stored total:  </p><pre><code class="language-julia">sum(Nij) # There are 12 Residues, but 2 are gaps</code></pre><pre class="documenter-example-output">10.0</pre><p>Contingency tables can be indexed using <code>Int</code> or <code>Residue</code>s:  </p><pre><code class="language-julia">Nij[2, 2] # Use Int to index the table</code></pre><pre class="documenter-example-output">2.0</pre><pre><code class="language-julia">Nij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre class="documenter-example-output">2.0</pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The number makes reference to the specific index in the table e.g <code>[2,2]</code> references the second row and the second column. The use of the number used to encode the residue to index the table is dangerous. The equivalent index number of a residue depends on the used alphabet and <code>Int(Residue(&#39;X&#39;))</code> will be always out of bounds.  </p></div></div><p>Indexing with <code>Residue</code>s works as expected. It uses the alphabet of the contingency table to find the index of the <code>Residue</code>.</p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Fij[R,R] =   1  1  1   = 3 # RHK

Fij = count(column_i, column_j, alphabet=alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    0.0    1.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    3.0    0.0    0.0    0.0    0.0    0.0
DE            │   2.0    0.0    0.0    1.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   2.0    4.0
NQST          │   1.0    1.0
RHK           │   3.0    4.0
DE            │   3.0    1.0
FWY           │   0.0    0.0
C             │   1.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 10.0</pre><pre><code class="language-julia">Fij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)] # Use Residue to index the table</code></pre><pre class="documenter-example-output">3.0</pre><p>The function <code>getcontingencytable</code> allows to access the wrapped <code>ContingencyTable</code> in a <code>Counts</code> object. You can use it, in combination with <code>normalize</code> to get a contingency table of probabilities. The result can be wrapped inside a <code>Probabilities</code> object:  </p><pre><code class="language-julia">Probabilities(normalize(getcontingencytable(Fij)))</code></pre><pre class="documenter-example-output">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.1    0.0    0.1    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.1    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.3    0.0    0.0    0.0    0.0    0.0
DE            │   0.2    0.0    0.0    0.1    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.1    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.2    0.4
NQST          │   0.1    0.1
RHK           │   0.3    0.4
DE            │   0.3    0.1
FWY           │   0.0    0.0
C             │   0.1    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 1.0000000000000002</pre><h4 id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence"><a class="docs-heading-anchor" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence">Example: Plotting the probabilities of each residue in a sequence</a><a id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence" title="Permalink"></a></h4><p>Similar to the <code>count</code> function, the <code>probabilities</code> function can take at least one sequence (vector of residues) and returns the probabilities of each residue. Optionally, the keyword argument <code>alphabet</code> could be used to count some residues in the same cell of the table.  </p><pre><code class="language-julia">probabilities(res&quot;AARANHDDRDC&quot;, alphabet=alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.Probabilities{Float64,1,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.ReducedAlphabet} : 

table : 8-element Named Array{Float64,1}
Dim_1  │ 
───────┼──────────
AILMV  │  0.272727
NQST   │ 0.0909091
RHK    │  0.272727
DE     │  0.272727
FWY    │       0.0
C      │ 0.0909091
G      │       0.0
P      │       0.0

total : 1.0</pre><p>Here, we are going to use the <code>probabilities</code> function to get the residue probabilities of a particular sequence from <em>UniProt</em>.</p><p>use the <code>getsequence</code> function, from the <code>MSA</code> module, to get the sequence from a <code>FASTA</code> downloaded from UniProt.  </p><pre><code class="language-julia-repl">julia&gt; using MIToS.Information # to use the probabilities function

julia&gt; using MIToS.MSA # to use getsequence on the one sequence FASTA (canonical) from UniProt

julia&gt; seq = read(&quot;http://www.uniprot.org/uniprot/P29374.fasta&quot;, FASTA) # Small hack: read the single sequence as a MSA
AnnotatedMultipleSequenceAlignment with 0 annotations : 1×1257 Named Array{MIToS.MSA.Residue,2}
                                                                                                         Seq ╲ Col │   …
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼──────
sp|P29374|ARI4A_HUMAN AT-rich interactive domain-containing protein 4A OS=Homo sapiens OX=9606 GN=ARID4A PE=1 SV=3 │   …

julia&gt; probabilities(seq[1,:]) # Select the single sequence and calculate the probabilities
MIToS.Information.Probabilities{Float64,1,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,1,MIToS.MSA.UngappedAlphabet} :

table : 20-element Named Array{Float64,1}
Dim_1  │
───────┼───────────
A      │   0.043755
R      │  0.0517104
N      │  0.0469372
D      │  0.0755768
C      │  0.0135243
Q      │   0.035004
E      │   0.134447
G      │   0.043755
H      │  0.0143198
⋮                 ⋮
K      │   0.109785
M      │  0.0159109
F      │  0.0190931
P      │  0.0445505
S      │   0.100239
T      │  0.0493238
W      │ 0.00636436
Y      │  0.0198886
V      │  0.0517104

total : 1.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the previous example, using <code>getsequence(seq,1)</code> instead of <code>seq[1,:]</code> will return the sequence as a matrix with a single column to keep information for both dimensions. To use <code>probabilities</code> (or <code>count</code>) you can make use of the Julia&#39;s <code>vec</code> function to transform the matrix to a vector, e.g.: <code>probabilities(vec(getsequence(seq,1)))</code>.</p></div></div><pre><code class="language-julia">using Plots # We choose Plots because it&#39;s intuitive, concise and backend independent
gr(size=(600,300))</code></pre><pre class="documenter-example-output">Plots.GRBackend()</pre><p>You can plot together with the probabilities of each residue in a given sequence, the probabilities of each residue estimated with the BLOSUM62 substitution matrix. That matrix is exported as a constant by the <code>Information</code> module as <code>BLOSUM62_Pi</code>.  </p><pre><code class="language-julia">bar(
    1:20,
    [ frequencies  BLOSUM62_Pi ],
    lab = [ &quot;Sequence&quot;  &quot;BLOSUM62&quot;   ],
    alpha=0.5
    )</code></pre><p><img src="../inf_plotfreq.png" alt/>  </p><h2 id="Low-count-corrections"><a class="docs-heading-anchor" href="#Low-count-corrections">Low count corrections</a><a id="Low-count-corrections-1"></a><a class="docs-heading-anchor-permalink" href="#Low-count-corrections" title="Permalink"></a></h2><p>Low number of observations can lead to sparse contingency tables, that lead to wrong probability estimations. It is shown in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a> that low-count corrections, can lead to improvements in the contact prediction capabilities of the Mutual Information. The Information module has available two low-count corrections:  </p><ol><li><a href="https://en.wikipedia.org/wiki/Additive_smoothing">Additive Smoothing<img src="../assets/external-link.png" alt/></a>; the constant value pseudocount described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a>.  </li><li>BLOSUM62 based pseudo frequencies of residues pairs, similar to <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC146917/"><em>Altschul et. al. 1997</em><img src="../assets/external-link.png" alt/></a>.  </li></ol><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)

filtercolumns!(msa, columngapfraction(msa) .&lt; 0.5) # delete columns with 50% gaps or more

column_i = msa[:,1]
column_j = msa[:,2]</code></pre><pre class="documenter-example-output">386-element Named Array{MIToS.MSA.Residue,1}
Seq                      │ 
─────────────────────────┼──
A0A553R1G6_9TELE/549-644 │ T
A0A2K6AF64_MANLE/10-125  │ L
G1RVK4_NOMLE/46-161      │ F
A0A6A4ILB2_APOLU/2-111   │ -
A0A672YV19_9TELE/15-130  │ R
A0A444U283_ACIRT/1-75    │ -
A0A0V0S2G9_9BILA/731-840 │ -
A0A6A5D6Z0_SCHHA/3-104   │ -
A0A194PY65_PAPXU/4-116   │ -
⋮                          ⋮
A0A0B2V267_TOXCA/6-119   │ P
H3DW02_PRIPA/2-115       │ I
A0A090MXF3_STRRB/2-104   │ -
A0A3B1JKX3_ASTMX/16-130  │ A
A0A3P6PBE0_ANISI/14-103  │ -
G3WPK1_SARHA/11-126      │ L
M3XPJ7_MUSPF/10-125      │ H
A0A2K6LYH7_RHIBE/10-125  │ L
F4WNV6_ACREC/302-415     │ -</pre><p>If you have a preallocated <code>ContingencyTable</code> you can use <code>count!</code> to fill it, this prevent to create a new table as <code>count</code> do. However, you should note that <code>count!</code> <strong>adds the new counts to the pre existing values</strong>, so in this case, we want to start with a table initialized with zeros.  </p><pre><code class="language-julia">using MIToS.Information

const alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

Nij = ContingencyTable(Float64, Val{2}, alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
DE            │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.0    0.0
NQST          │   0.0    0.0
RHK           │   0.0    0.0
DE            │   0.0    0.0
FWY           │   0.0    0.0
C             │   0.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 0.0</pre><pre><code class="language-julia">#      table  weights         pseudocount      sequences...
count!(Nij,   NoClustering(), NoPseudocount(), column_i, column_j)</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │  58.0    8.0    9.0    0.0    2.0    5.0    0.0    6.0
NQST          │  36.0   17.0   18.0    0.0    0.0    0.0    2.0    5.0
RHK           │   7.0    5.0    0.0    0.0    0.0    0.0    0.0    4.0
DE            │   0.0    9.0    0.0    0.0    1.0    0.0    0.0    0.0
FWY           │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   1.0    1.0    1.0    0.0    0.0    0.0    0.0    0.0
P             │   4.0    0.0    0.0    0.0    0.0    1.0    0.0    2.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  88.0  106.0
NQST          │  78.0   41.0
RHK           │  16.0   28.0
DE            │  10.0    0.0
FWY           │   1.0    3.0
C             │   0.0    6.0
G             │   3.0    2.0
P             │   7.0   17.0

total : 203.0</pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can use <code>NoClustering()</code> in places where clustering weights are required to not use weights. Also, <code>NoPseudocount()</code> in places where pseudocount values are required to not use pseudocounts.</p></div></div><p>In cases like the above, where there are few observations, it is possible to apply a constant pseudocount to the counting table.  This module defines the type <code>AdditiveSmoothing</code> and the correspond <code>fill!</code> and  <code>apply_pseudocount!</code> methods to efficiently add or fill with a constant value each element of the table.</p><pre><code class="language-julia">apply_pseudocount!(Nij, AdditiveSmoothing(1.0))</code></pre><pre class="documenter-example-output">MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │  59.0    9.0   10.0    1.0    3.0    6.0    1.0    7.0
NQST          │  37.0   18.0   19.0    1.0    1.0    1.0    3.0    6.0
RHK           │   8.0    6.0    1.0    1.0    1.0    1.0    1.0    5.0
DE            │   1.0   10.0    1.0    1.0    2.0    1.0    1.0    1.0
FWY           │   1.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
G             │   2.0    2.0    2.0    1.0    1.0    1.0    1.0    1.0
P             │   5.0    1.0    1.0    1.0    1.0    2.0    1.0    3.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  96.0  114.0
NQST          │  86.0   49.0
RHK           │  24.0   36.0
DE            │  18.0    8.0
FWY           │   9.0   11.0
C             │   8.0   14.0
G             │  11.0   10.0
P             │  15.0   25.0

total : 267.0</pre><p><strong>[High level interface.]</strong> The <code>count</code> function has a <code>pseudocounts</code> keyword argument that can take a <code>AdditiveSmoothing</code> value to easily calculate occurrences with pseudocounts. Also the alphabet keyword argument can be used to chage the default alphabet (i.e. )</p><pre><code class="language-julia">count(column_i, column_j, pseudocounts=AdditiveSmoothing(1.0), alphabet=alphabet)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │  59.0    9.0   10.0    1.0    3.0    6.0    1.0    7.0
NQST          │  37.0   18.0   19.0    1.0    1.0    1.0    3.0    6.0
RHK           │   8.0    6.0    1.0    1.0    1.0    1.0    1.0    5.0
DE            │   1.0   10.0    1.0    1.0    2.0    1.0    1.0    1.0
FWY           │   1.0    2.0    1.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
G             │   2.0    2.0    2.0    1.0    1.0    1.0    1.0    1.0
P             │   5.0    1.0    1.0    1.0    1.0    2.0    1.0    3.0

marginals : 8×2 Named Array{Float64,2}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │  96.0  114.0
NQST          │  86.0   49.0
RHK           │  24.0   36.0
DE            │  18.0    8.0
FWY           │   9.0   11.0
C             │   8.0   14.0
G             │  11.0   10.0
P             │  15.0   25.0

total : 267.0</pre><p>To use the conditional probability matrix <code>BLOSUM62_Pij</code> in the calculation of pseudo frequencies <span>$G$</span> for the pair of residues <span>$a$</span>, <span>$b$</span>, it should be calculated first the real frequencies/probabilities <span>$p_{a,b}$</span>. The observed probabilities are then used to estimate the pseudo frequencies.  </p><p class="math-container">\[G_{ab} = \sum_{cd}  p_{cd} \cdot BLOSUM62( a | c ) \cdot BLOSUM62( b | d )\]</p><p>Finally, the probability <span>$P$</span> of each pair of residues <span>$a$</span>, <span>$b$</span> between the columns <span>$i$</span>, <span>$j$</span> is the weighted mean between the observed frequency <span>$p$</span> and BLOSUM62-based pseudo frequency <span>$G$</span>, where α is generally the number of clusters or the number of sequences of the MSA and β is an empiric weight value. β was determined to be close to <code>8.512</code>.  </p><p class="math-container">\[P_{ab} = \frac{\alpha \cdot p_{ab} + \beta \cdot G_{ab} }{\alpha + \beta}\]</p><p>This could be easily achieved using the <code>pseudofrequencies</code> keyword argument of the <code>probabilities</code> function. That argument can take a <code>BLOSUM_Pseudofrequencies</code> object that is created with α and β as first and second argument, respectively.</p><pre><code class="language-julia">Pij = probabilities(column_i, column_j, pseudofrequencies=BLOSUM_Pseudofrequencies(nsequences(msa), 8.512))</code></pre><pre class="documenter-example-output">MIToS.Information.Probabilities{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │           A            R  …            Y            V
──────────────┼──────────────────────────────────────────────────────
A             │   0.0436552    0.0146151  …   6.86411e-5     0.024364
R             │  0.00495647   5.63071e-5      2.65647e-5   0.00492551
N             │   8.1845e-5   4.39133e-5        1.727e-5   5.82878e-5
D             │  8.75091e-5   4.46217e-5      1.97191e-5   6.13966e-5
C             │  3.29725e-5   2.02129e-5      7.81597e-6   2.98321e-5
Q             │   0.0821137    5.0501e-5      2.44158e-5    0.0097304
E             │ 0.000154837   6.43804e-5      0.00485561   9.53793e-5
G             │  0.00495541   0.00490452      2.89342e-5  0.000102361
H             │  0.00970394   2.19255e-5       9.8944e-6   3.48272e-5
⋮                         ⋮            ⋮  ⋱            ⋮            ⋮
K             │ 0.000137569    6.0674e-5      2.71533e-5   9.74759e-5
M             │  4.54269e-5   2.37546e-5      9.43202e-6   3.76855e-5
F             │  4.81705e-5    2.7654e-5      1.05982e-5   4.02543e-5
P             │  7.64427e-5   3.85568e-5      1.88345e-5   0.00972767
S             │  0.00981275    0.0338658      4.43013e-5  0.000136093
T             │  0.00979911   0.00491395      3.58359e-5    0.0194224
W             │  1.83893e-5     8.592e-6      3.56766e-6   1.20098e-5
Y             │  4.43348e-5   2.18765e-5      8.91639e-6   3.31595e-5
V             │ 0.000144199    0.0193812  …   3.41784e-5    0.0242418

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │       Dim_1        Dim_2
──────────────┼─────────────────────────
A             │    0.325986     0.180578
R             │   0.0687625    0.0783091
N             │ 0.000749462   0.00547748
D             │ 0.000801326  0.000618927
C             │ 0.000349759    0.0295593
Q             │    0.126466   0.00538426
E             │   0.0495117  0.000778742
G             │   0.0157656    0.0106762
H             │   0.0100885    0.0488669
⋮                         ⋮            ⋮
K             │  0.00121226    0.0106448
M             │   0.0100732   0.00537751
F             │ 0.000476082    0.0103748
P             │    0.034643    0.0832573
S             │    0.107862     0.131686
T             │    0.146281    0.0590751
W             │  0.00499063  0.000127028
Y             │ 0.000401969   0.00530484
V             │   0.0738511    0.0933679

total : 1.0</pre><p>You can also use <code>apply_pseudofrequencies!</code> in a previously filled probability contingency table. i.e. <code>apply_pseudofrequencies!(Pij, BLOSUM_Pseudofrequencies(α, β))</code></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>BLOSUM_Pseudofrequencies</code> can be only be applied in <strong>normalized/probability</strong> tables with <code>UngappedAlphabet</code>.  </p></div></div><h2 id="Correction-for-data-redundancy-in-a-MSA"><a class="docs-heading-anchor" href="#Correction-for-data-redundancy-in-a-MSA">Correction for data redundancy in a MSA</a><a id="Correction-for-data-redundancy-in-a-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Correction-for-data-redundancy-in-a-MSA" title="Permalink"></a></h2><p>A simple way to reduce redundancy in a MSA without losing sequences, is clusterization and sequence weighting. The weight of each sequence should be 1/N, where N is the number of sequences in its cluster. The <code>Clusters</code> type of the <code>MSA</code> module stores the weights. This vector of weights can be extracted (with the <code>getweight</code> function) and used by the <code>count</code> and <code>probabilities</code> functions with the keyword argument <code>weights</code>. Also it&#39;s possible to use the <code>Clusters</code> as second argument of the function <code>count!</code>.  </p><pre><code class="language-julia">clusters = hobohmI(msa, 62) # from MIToS.MSA</code></pre><pre class="documenter-example-output">MIToS.MSA.Clusters([1, 109, 1, 41, 2, 2, 5, 26, 10, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 3, 4, 5, 6, 7, 8, 9  …  2, 104, 105, 31, 4, 77, 2, 2, 2, 14], [1.0, 0.009174311926605505, 0.009174311926605505, 1.0, 0.024390243902439025, 0.5, 0.5, 0.2, 0.038461538461538464, 0.1  …  0.009174311926605505, 1.0, 1.0, 0.3333333333333333, 0.024390243902439025, 0.5, 0.009174311926605505, 0.009174311926605505, 0.009174311926605505, 0.09090909090909091])</pre><pre><code class="language-julia">count(msa[:,1], msa[:,2], weights=clusters)</code></pre><pre class="documenter-example-output">MIToS.Information.Counts{Float64,2,MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64,2,MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Array{Float64,2}
Dim_1 ╲ Dim_2 │          A           R  …           Y           V
──────────────┼──────────────────────────────────────────────────
A             │    2.34878   0.0275229  …         0.0     0.82439
R             │ 0.00917431         0.0            0.0   0.0243902
N             │        0.0         0.0            0.0         0.0
D             │        0.0         0.0            0.0         0.0
C             │        0.0         0.0            0.0         0.0
Q             │    1.39024         0.0            0.0     1.03846
E             │        0.0         0.0     0.00917431         0.0
G             │        1.0   0.0243902            0.0         0.0
H             │        1.0         0.0            0.0         0.0
⋮                        ⋮           ⋮  ⋱           ⋮           ⋮
K             │        0.0         0.0            0.0         0.0
M             │        0.0         0.0            0.0         0.0
F             │        0.0         0.0            0.0         0.0
P             │        0.0         0.0            0.0   0.0487805
S             │        2.0   0.0642202            0.0         0.0
T             │        1.0         1.0            0.0         0.5
W             │        0.0         0.0            0.0         0.0
Y             │        0.0         0.0            0.0         0.0
V             │        0.0   0.0366972  …         0.0   0.0458716

marginals : 20×2 Named Array{Float64,2}
Residue ╲ Dim │      Dim_1       Dim_2
──────────────┼───────────────────────
A             │    6.73456      9.1232
R             │    2.67035     1.15283
N             │        0.0    0.333333
D             │        0.0         0.0
C             │        0.0     1.04587
Q             │    4.99595         1.0
E             │   0.582569         0.0
G             │    1.03356   0.0183486
H             │        1.0   0.0917431
⋮                        ⋮           ⋮
K             │        0.0    0.666667
M             │        2.0         0.5
F             │        0.0   0.0183486
P             │    2.22256     1.76009
S             │    5.28965     6.44987
T             │    6.73782     4.05711
W             │ 0.00917431         0.0
Y             │        0.0  0.00917431
V             │    1.12844     2.48189

total : 35.112972745535956</pre><h2 id="Estimating-information-measures-on-an-MSA"><a class="docs-heading-anchor" href="#Estimating-information-measures-on-an-MSA">Estimating information measures on an MSA</a><a id="Estimating-information-measures-on-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-information-measures-on-an-MSA" title="Permalink"></a></h2><p>The <code>Information</code> module has a number of functions defined to calculate information measures from <code>Counts</code> and <code>Probabilities</code>:</p><ul><li><code>entropy</code> : Shannon entropy (H)</li><li><code>marginal_entropy</code> : Shannon entropy (H) of the marginals</li><li><code>kullback_leibler</code> : Kullback-Leibler (KL) divergence</li><li><code>mutual_information</code> : Mutual Information (MI)</li><li><code>normalized_mutual_information</code> : Normalized Mutual Information (nMI) by Entropy</li><li><code>gap_intersection_percentage</code></li><li><code>gap_union_percentage</code></li></ul><p>Information measure functions take optionally the base as the last positional argument (default: <code>e</code>). You can use <code>2.0</code> to measure information in bits.</p><pre><code class="language-julia">using MIToS.Information
using MIToS.MSA

Ni = count(res&quot;PPCDPPPPPKDKKKKDDGPP&quot;) # Ni has the count table of residues in this low complexity sequence

H = entropy(Ni) # returns the Shannon entropy in nats (base e)</code></pre><pre class="documenter-example-output">1.327362863420189</pre><pre><code class="language-julia">H = entropy(Ni, 2.0) # returns the Shannon entropy in bits (base 2)</code></pre><pre class="documenter-example-output">1.9149798205164812</pre><p>Information module defines special iteration functions to easily and efficiently compute a measure over a MSA. In particular, <code>mapcolfreq!</code> and <code>mapseqfreq!</code> map a function that takes a table of <code>Counts</code> or <code>Probabilities</code>. The table is filled in place with the counts or probabilities of each column or sequence of a MSA, respectively. <code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> are similar, but they fill the table using pairs of columns or sequences, respectively.  </p><p>This functions take three positional arguments: the function <code>f</code> to be calculated, the <code>msa</code> and <code>table</code> of <code>Counts</code> or <code>Probabilities</code>.  </p><p>After that, this function takes some keyword arguments:</p><ul><li><code>weights</code> (default: <code>NoClustering()</code>) : Weights to be used for table counting.</li><li><code>pseudocounts</code> (default: <code>NoPseudocount()</code>) : <code>Pseudocount</code> object to be applied to table.</li><li><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>) : <code>Pseudofrequencies</code> to be</li></ul><p>applied to the normalized (probabilities) table.  </p><p><code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> also have a fourth positional argument <code>usediagonal</code> that indicates if the function should be applied to identical element pairs (default to <code>Val{true}</code>). This two functions also have an extra keyword argument <code>diagonalvalue</code> (default to zero) to indicate the value used to fill the diagonal elements if <code>usediagonal</code> is <code>Val{false}</code>.  </p><h4 id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA"><a class="docs-heading-anchor" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a><a id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA" title="Permalink"></a></h4><p>In this example, we are going to use <code>mapcolfreq!</code> and <code>mapcolpairfreq!</code> to estimate Shannon <code>entropy</code> of MSA columns <em>H(X)</em> and the joint entropy <em>H(X, Y)</em> of columns pairs, respectively.  </p><pre><code class="language-julia">using MIToS.MSA

msa = read(&quot;http://pfam.xfam.org/family/PF09776/alignment/full&quot;, Stockholm)</code></pre><pre class="documenter-example-output">AnnotatedMultipleSequenceAlignment with 410 annotations : 386×116 Named Array{MIToS.MSA.Residue,2}
               Seq ╲ Col │  39   40   41   42   43  …  191  194  195  196  197
─────────────────────────┼────────────────────────────────────────────────────
A0A553R1G6_9TELE/549-644 │   -    -    -    -    -  …    -    -    -    -    -
A0A2K6AF64_MANLE/10-125  │   L    L    R    Q    S       Q    F    W    N    -
G1RVK4_NOMLE/46-161      │   -    L    R    Q    S       Q    F    W    T    R
A0A6A4ILB2_APOLU/2-111   │   -    -    -    -    -       K    L    V    K    -
A0A672YV19_9TELE/15-130  │   -    -    -    -    -       R    F    W    K    K
A0A444U283_ACIRT/1-75    │   -    -    -    -    -       K    F    W    K    K
A0A0V0S2G9_9BILA/731-840 │   -    -    -    -    -       Y    L    W    K    K
A0A6A5D6Z0_SCHHA/3-104   │   -    -    -    -    -       F    L    L    -    -
A0A194PY65_PAPXU/4-116   │   -    -    -    -    -       K    Y    I    K    K
⋮                            ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A0B2V267_TOXCA/6-119   │   -    -    -    -    -       Q    L    W    K    -
H3DW02_PRIPA/2-115       │   -    -    -    -    -       S    F    W    S    -
A0A090MXF3_STRRB/2-104   │   -    -    -    -    -       K    L    W    K    -
A0A3B1JKX3_ASTMX/16-130  │   -    L    Q    E    V       K    F    W    K    K
A0A3P6PBE0_ANISI/14-103  │   -    -    -    -    -       -    -    -    -    -
G3WPK1_SARHA/11-126      │   -    L    Q    Q    N       K    F    W    K    K
M3XPJ7_MUSPF/10-125      │   -    L    Q    Q    P       R    F    W    T    K
A0A2K6LYH7_RHIBE/10-125  │   L    L    R    Q    S       Q    F    W    N    -
F4WNV6_ACREC/302-415     │   -    -    -    -    -  …    N    F    N    -    -</pre><p>We are going to count residues to estimate the entropy. The <code>entropy</code> estimation is performed over a rehused <code>Counts</code> object. The result will be a vector containing the values estimated over each column without counting gaps (<code>UngappedAlphabet</code>).  </p><pre><code class="language-julia">using MIToS.Information

Hx = mapcolfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{1}, UngappedAlphabet())))</code></pre><pre class="documenter-example-output">1×116 Named Array{Float64,2}
Function ╲ Col │        39         40  …        196        197
───────────────┼──────────────────────────────────────────────
entropy        │  0.167026    0.13282  …    1.42931   0.291903</pre><p>If we want the <strong>joint entropy</strong> between columns pairs, we need to use a bidimensional table of <code>Counts</code> and <code>mapcolpairfreq!</code>.</p><pre><code class="language-julia">Hxy = mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))</code></pre><pre class="documenter-example-output">116×116 Named PairwiseListMatrices.PairwiseListMatrix{Float64,true,Array{Float64,1}}
Col1 ╲ Col2 │       39        40        41  …       195       196       197
────────────┼──────────────────────────────────────────────────────────────
39          │ 0.167026  0.167026   1.05803  …   0.16925   1.34207   0.34878
40          │ 0.167026   0.13282   1.22089     0.136512   1.40086  0.535274
41          │  1.05803   1.22089   1.21425      1.22652     2.121   1.44626
42          │ 0.547645  0.979877   1.92835      1.03635   1.99952   1.54384
43          │  1.74324   2.03632    2.5633      2.15465    2.6921   2.35045
44          │  1.61301    1.6139   2.35935      1.69875   2.48762   1.71034
45          │  1.22608   1.40381   2.34415      1.58488   2.58066   1.90997
46          │  1.53769   1.60775    2.3245      1.94138   2.72215   2.14746
48          │  1.32265   1.46773   2.36984      1.74594   2.54161   1.81194
⋮                    ⋮         ⋮         ⋮  ⋱         ⋮         ⋮         ⋮
187         │ 0.314245  0.466242   1.54739      2.13229   2.52573    1.7452
188         │  1.28139   1.40474    2.0452      2.71719   2.74963   2.14131
189         │  0.16925  0.136512   1.22652     0.973534   1.49348  0.342899
190         │  1.16595   1.46201   2.15734      2.57438   2.84439   2.10267
191         │ 0.799186   0.96076   1.94311      2.37664   2.54461   1.92773
194         │ 0.253446  0.185847     1.268      1.53213   2.11438   1.13293
195         │  0.16925  0.136512   1.22652      0.91968   2.06058   0.97414
196         │  1.34207   1.40086     2.121      2.06058   1.42931   1.44691
197         │  0.34878  0.535274   1.44626  …   0.97414   1.44691  0.291903</pre><p>In the above examples, we indicate the type of each occurrence in the counting and the probability table to use. Also, it&#39;s possible for some measures as <strong>entropy</strong> and <strong>mutual information</strong>, to estimate the values only with the count table (without calculate the probability table). Estimating measures only with a <code>ResidueCount</code> table, when this is possible, should be faster than using a probability table.  </p><pre><code class="language-julia">Time_Pab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Probabilities(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

Time_Nab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))
end

using Plots
gr()

histogram( [Time_Pab Time_Nab],
    labels = [&quot;Using ResidueProbability&quot; &quot;Using ResidueCount&quot;],
    xlabel = &quot;Execution time [seconds]&quot; )</code></pre><p><img src="../inf_entropy.png" alt/>   </p><h2 id="Corrected-Mutual-Information"><a class="docs-heading-anchor" href="#Corrected-Mutual-Information">Corrected Mutual Information</a><a id="Corrected-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Corrected-Mutual-Information" title="Permalink"></a></h2><p>MIToS ships with two methods to easily calculate corrected mutual information.   The first is the algorithm described in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2672635/"><em>Buslje et. al. 2009</em><img src="../assets/external-link.png" alt/></a>. This algorithm can be accessed through the <code>buslje09</code> function and includes:  </p><ol><li>Low count correction using <code>AdditiveSmoothing</code></li><li>Sequence weighting after a <code>hobohmI</code> clustering</li><li>Average Product Correction (APC) proposed by</li></ol><p><a href="http://bioinformatics.oxfordjournals.org/content/24/3/333">Dunn et. al. 2008<img src="../assets/external-link.png" alt/></a>, through the <code>APC!</code> function that takes a MI matrix.</p><ol><li>Z score correction using the functions <code>shuffle!</code> from the MSA module and <code>zscore</code></li></ol><p>from the <code>PairwiseListMatrices</code> package.  </p><article class="docstring"><header><a class="docstring-binding" id="MIToS.Information.buslje09" href="#MIToS.Information.buslje09"><code>MIToS.Information.buslje09</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>buslje09</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong>.</p><p>keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - lambda      Float64   0.05    Low count value
  - clustering  Bool      true    Sequence clustering (Hobohm I)
  - threshold             62      Percent identity threshold for clustering
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       100     Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples
  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score
  - MI or MIp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/457ebc7a63f32bf2e6807275a285bd5e8ec310d5/src/Information/CorrectedMutualInformation.jl#L19-L42">source</a></section></article><p>The second, implemented in the <code>BLMI</code> function, has the same corrections that the above algorithm, but use BLOSUM62 pseudo frequencies. This function is <strong>slower</strong> than <code>buslje09</code> (at the same number of samples), but gives <strong>better performance</strong> (for structural contact prediction) when the MSA has <strong>less than 400 clusters</strong> after a Hobohm I at 62% identity.  </p><article class="docstring"><header><a class="docstring-binding" id="MIToS.Information.BLMI" href="#MIToS.Information.BLMI"><code>MIToS.Information.BLMI</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>BLMI</code> takes a MSA or a file and a <code>FileFormat</code> as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on <strong>Busjle et. al. 2009</strong> but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.</p><p>Keyword argument, type, default value and descriptions:</p><pre><code class="language-none">  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies
  - lambda      Float64   0.0     Low count value
  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       50      Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples</code></pre><p>This function returns:</p><pre><code class="language-none">  - Z score (ZBLMI)
  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/457ebc7a63f32bf2e6807275a285bd5e8ec310d5/src/Information/CorrectedMutualInformation.jl#L94-L117">source</a></section></article><h4 id="Example:-Estimating-corrected-MI-from-an-MSA"><a class="docs-heading-anchor" href="#Example:-Estimating-corrected-MI-from-an-MSA">Example: Estimating corrected MI from an MSA</a><a id="Example:-Estimating-corrected-MI-from-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-corrected-MI-from-an-MSA" title="Permalink"></a></h4><pre><code class="language-julia">using MIToS.MSA
using MIToS.Information

msa = read(&quot;http://pfam.xfam.org/family/PF16078/alignment/full&quot;, Stockholm)
ZMIp, MIp  = buslje09(msa)
ZMIp</code></pre><pre class="documenter-example-output">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │         14          15  …          59          60
────────────┼──────────────────────────────────────────────────
14          │        NaN     1.75121  …    -2.21165      1.8652
15          │    1.75121         NaN       -1.37146     3.24482
16          │    2.54817     1.80444       0.431776   -0.280811
17          │  -0.510536    -1.42754       -2.51125    -1.30286
18          │   -1.34343    -1.73309        6.11595    -1.96559
19          │   -4.93862    0.678482       0.861063    -1.60795
20          │   0.955412    -4.19739        2.49361   -0.968506
26          │    -4.6982    0.150499      -0.120434     -3.4822
27          │   -4.92183    -2.56811       -2.07322    -3.44205
⋮                      ⋮           ⋮  ⋱           ⋮           ⋮
52          │   -1.51293   -0.241538       0.975154    -1.01722
53          │   -2.26194     6.36118         10.411    0.180106
54          │    3.50069    -2.22526       -2.83806    0.607289
55          │  -0.734247    0.221112        2.73363    0.395282
56          │   -2.59913    -1.29007        8.74904   -0.741256
57          │   0.375642    -3.03788        7.95365   -0.361863
58          │   -2.18377     8.63362        8.09427     1.61798
59          │   -2.21165    -1.37146            NaN     3.91538
60          │     1.8652     3.24482  …     3.91538         NaN</pre><pre><code class="language-julia">ZBLMIp, BLMIp  = BLMI(msa)
ZBLMIp</code></pre><pre class="documenter-example-output">39×39 Named PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}}
Col1 ╲ Col2 │           14            15  …            59            60
────────────┼──────────────────────────────────────────────────────────
14          │          NaN    -0.0361895  …    -0.0188949    0.00248148
15          │   -0.0361895           NaN       -0.0374084     0.0293007
16          │   -0.0171206    -0.0278213      0.000568627    -0.0247921
17          │   -0.0011799    -0.0398732       -0.0351658   -0.00430076
18          │    -0.023351    -0.0265493        0.0769328    -0.0272612
19          │   -0.0400772    -0.0019086      0.000318475    0.00281241
20          │   0.00763391    -0.0449152         0.041199   -0.00138397
26          │    -0.030315   -0.00453481      -0.00818949    -0.0391383
27          │   -0.0244834    -0.0394667       -0.0373988     -0.023861
⋮                        ⋮             ⋮  ⋱             ⋮             ⋮
52          │   0.00769419  -0.000914643      0.000702067     0.0097406
53          │   -0.0142384      0.100232         0.123109    0.00553947
54          │    0.0117461   -0.00447789      -0.00554595    -0.0108557
55          │    0.0102212     0.0137708        0.0320511     0.0206935
56          │   -0.0136997    -0.0168638        0.0897505   -0.00253739
57          │    0.0102413    -0.0477182        0.0612399    -0.0121978
58          │  -0.00961846      0.114751        0.0550897     0.0260544
59          │   -0.0188949    -0.0374084              NaN     0.0317193
60          │   0.00248148     0.0293007  …     0.0317193           NaN</pre><h2 id="Visualize-Mutual-Information"><a class="docs-heading-anchor" href="#Visualize-Mutual-Information">Visualize Mutual Information</a><a id="Visualize-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-Mutual-Information" title="Permalink"></a></h2><p>You can use the function of the <code>Plots</code> package to visualize the Mutual Information (MI) network between residues. As an example, we are going to visualize the MI between residues of the Pfam domain <em>PF16078</em>. The <code>heatmap</code> is the simplest way to visualize the values of the Mutual Information matrix.  </p><pre><code class="language-julia">using Plots
gr()

heatmap(ZMIp, yflip=true)</code></pre><pre class="documenter-example-output">┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::NamedArrays.NamedArray{Float64,2,PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}},Tuple{OrderedCollections.OrderedDict{String,Int64},OrderedCollections.OrderedDict{String,Int64}}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/uCh2y/src/pipeline.jl:15</pre><p><img src="../inf_heatmap.png" alt/>   </p><p>ZMIp is a Z score of the corrected MIp against its distribution on a random MSA (shuffling the residues in each sequence), so pairs with highest values are more likely to co-evolve. Here, we are going to use the top 1% pairs of MSA columns.  </p><pre><code class="language-julia">using PairwiseListMatrices # to use getlist
using Statistics # to use quantile

threshold = quantile(getlist(ZMIp), 0.99)</code></pre><pre class="documenter-example-output">11.451771168439166</pre><pre><code class="language-julia">ZMIp[ ZMIp .&lt; threshold ] .= NaN
heatmap(ZMIp, yflip=true)</code></pre><pre class="documenter-example-output">┌ Warning: Attribute alias `ratio` detected in the user recipe defined for the signature (::NamedArrays.NamedArray{Float64,2,PairwiseListMatrices.PairwiseListMatrix{Float64,false,Array{Float64,1}},Tuple{OrderedCollections.OrderedDict{String,Int64},OrderedCollections.OrderedDict{String,Int64}}}). To ensure expected behavior it is recommended to use the default attribute `aspect_ratio`.
└ @ Plots ~/.julia/packages/Plots/uCh2y/src/pipeline.jl:15</pre><p><img src="../inf_heatmap_top.png" alt/>   </p><p>We are going to calculate the cMI (cumulative mutual information) value of each node. Where cMI is a mutual information score per position that characterizes the extent of mutual information &quot;interactions&quot; in its neighbourhood. This score is calculated as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network and we are going to indicate it using the node color. To calculate cMI we are going to use the <code>cumulative</code> function:   </p><pre><code class="language-julia">cMI = cumulative(ZMIp, threshold)</code></pre><pre class="documenter-example-output">1×39 Named Array{Float64,2}
Function ╲ Col2 │      14       15       16  …       58       59       60
────────────────┼────────────────────────────────────────────────────────
cumulative      │     0.0      0.0      0.0  …      0.0      0.0      0.0</pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MSA/">« MSA</a><a class="docs-footer-nextpage" href="../SIFTS/">SIFTS »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 26 April 2021 00:58">Monday 26 April 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
