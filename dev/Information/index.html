<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Information · MIToS</title><meta name="title" content="Information · MIToS"/><meta property="og:title" content="Information · MIToS"/><meta property="twitter:title" content="Information · MIToS"/><meta name="description" content="Documentation for MIToS."/><meta property="og:description" content="Documentation for MIToS."/><meta property="twitter:description" content="Documentation for MIToS."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/extra_styles.css" rel="stylesheet" type="text/css"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MIToS</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Example/">Example</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../MSA/">MSA</a></li><li class="is-active"><a class="tocitem" href>Information</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Counting-residues"><span>Counting residues</span></a></li><li><a class="tocitem" href="#Low-count-corrections"><span>Low count corrections</span></a></li><li><a class="tocitem" href="#Correction-for-data-redundancy-in-a-MSA"><span>Correction for data redundancy in a MSA</span></a></li><li><a class="tocitem" href="#Estimating-information-measures-on-an-MSA"><span>Estimating information measures on an MSA</span></a></li><li><a class="tocitem" href="#Corrected-Mutual-Information"><span>Corrected Mutual Information</span></a></li><li><a class="tocitem" href="#Visualize-Mutual-Information"><span>Visualize Mutual Information</span></a></li></ul></li><li><a class="tocitem" href="../SIFTS/">SIFTS</a></li><li><a class="tocitem" href="../PDB/">PDB</a></li><li><a class="tocitem" href="../Pfam/">Pfam</a></li></ul></li><li><span class="tocitem">Cookbook</span><ul><li><a class="tocitem" href="../01_Change_B_factors/">Change B-factors</a></li><li><a class="tocitem" href="../02_Linking_structural_and_evolutionary_information/">Linking structural and evolutionary information</a></li><li><a class="tocitem" href="../03_RMSF/">Root Mean Squared Fluctuation (RMSF)</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../MSA_API/">MSA</a></li><li><a class="tocitem" href="../Information_API/">Information</a></li><li><a class="tocitem" href="../SIFTS_API/">SIFTS</a></li><li><a class="tocitem" href="../PDB_API/">PDB</a></li><li><a class="tocitem" href="../Pfam_API/">Pfam</a></li><li><a class="tocitem" href="../Utils_API/">Utils</a></li></ul></li><li><a class="tocitem" href="../Scripts/">MIToS&#39; Scripts</a></li><li><a class="tocitem" href="../References/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Information</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Information</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/diegozea/MIToS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/Information.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Information"><a class="docs-heading-anchor" href="#Module-Information">Information</a><a id="Module-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Information" title="Permalink"></a></h1><p>Extracting evolutionary signals, such as conservation and coevolution, from Multiple Sequence Alignments (MSAs) is a common task in bioinformatics. There are several methods to estimate these signals, including information measures like <em>Shannon Entropy</em>—to assess the conservation of a position—and <em>Mutual Information</em>—to assess the coevolution between two positions. The <code>Information</code> module of MIToS defines types and functions useful for calculating those information measures over an MSA. This module was designed to count <code>Residue</code>s (defined in the <code>MSA</code> module) in special contingency tables (as fast as possible) and to derive probabilities from these counts. It also includes methods for applying corrections to those tables, e.g., pseudo counts and pseudo frequencies. Finally, <code>Information</code> allows using probabilities and counts to estimate information measures and other frequency-based values.</p><pre><code class="language-julia hljs">using MIToS.Information # to load the Information module</code></pre><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li>Estimate multi-dimensional frequencies (counts) and probability tables from sequences, MSA columns, etc...</li><li>Corrections for a small number of observations</li><li>Corrections for data redundancy on an MSA</li><li>Estimate information measures such as Shannon entropy, mutual information, etc...</li><li>Calculate corrected mutual information between residues</li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Module-Information">Information</a></li><li class="no-marker"><ul><li><a href="#Features">Features</a></li><li><a href="#Contents">Contents</a></li><li><a href="#Counting-residues">Counting residues</a></li><li class="no-marker"><ul><li><a href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence">Example: Plotting the probabilities of each residue in a sequence</a></li><li><a href="#Low-level-interface">Low-level interface</a></li></ul></li><li><a href="#Low-count-corrections">Low count corrections</a></li><li class="no-marker"><ul><li><a href="#Low-level-interface-2">Low-level interface</a></li></ul></li><li><a href="#Correction-for-data-redundancy-in-a-MSA">Correction for data redundancy in a MSA</a></li><li><a href="#Estimating-information-measures-on-an-MSA">Estimating information measures on an MSA</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a></li></ul></li></ul></li><li><a href="#Corrected-Mutual-Information">Corrected Mutual Information</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#Example:-Estimating-corrected-MI-from-an-MSA">Example: Estimating corrected MI from an MSA</a></li></ul></li></ul></li><li><a href="#Visualize-Mutual-Information">Visualize Mutual Information</a></li></ul></li></ul><h2 id="Counting-residues"><a class="docs-heading-anchor" href="#Counting-residues">Counting residues</a><a id="Counting-residues-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-residues" title="Permalink"></a></h2><p>You can use the <code>frequencies</code> and <code>probabilities</code> functions to easily calculate the amino acid frequencies or probabilities of a sequence or a column of an MSA. The number of sequences/columns determines the dimension of the resulting table. Let&#39;s see an example using the <code>frequencies</code> function to calculate the frequencies of each pair of residues in two columns of an MSA. The resulting <code>Frequencies</code> object contains the bidimensional  contingency table, the marginal values, and the total.</p><pre><code class="language-julia hljs">using MIToS.Information
using MIToS.MSA # to use res&quot;...&quot; to create Vector{Residue}

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Nij[R,R] =   1     1   = 2

Nij = frequencies(column_i, column_j)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Frequencies{Float64, 2, MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 1.0  1.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  2.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  1.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 2.0  0.0  0.0  1.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  1.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Matrix{Float64}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   2.0    3.0
R             │   2.0    3.0
N             │   1.0    1.0
D             │   3.0    1.0
C             │   1.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
⋮                   ⋮      ⋮
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    1.0

total : 10.0</code></pre><p>You can use <code>sum</code> to get the stored total:</p><pre><code class="language-julia hljs">sum(Nij)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10.0</code></pre><p>Here, the total is <code>10.0</code>, because there are <code>12</code> residues on each column, but <code>2</code> are gaps. Since the default alphabet used by <code>frequency</code> is <code>UngappedAlphabet()</code>, the gaps are  not counted.</p><p>Contingency tables can be indexed using <code>Int</code> (the coordinates in the table) or <code>Residue</code>s. For example, to get the number of times an arginine (<em>R</em>) is found in the same sequence in both columns, you can use:</p><pre><code class="language-julia hljs">Nij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.0</code></pre><p>Or, since the arginine is in the second row and the second column of the table—this is  because the arginine is the second residue in the <code>UngappedAlphabet()</code>—you can use:</p><pre><code class="language-julia hljs">Nij[2, 2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.0</code></pre><div class="admonition is-warning"><header class="admonition-header">Indexing with `Int`</header><div class="admonition-body"><p>The index refers to the specific position in the table, e.g., <code>[2,2]</code> references the  second row and the second column. For <code>GappedAlphabet()</code> and <code>UngappedAlphabet()</code>,  the index is the same as the position of the residue in the alphabet.  However, for <code>ReducedAlphabet()</code>, the index will be the number of the group to which  the residue belongs. For example, if the alphabet is  <code>ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)</code>, the index of the arginine (<em>R</em>)  will be <code>3</code> rather than <code>2</code>. Therefore, <strong>it is recommended</strong> that you use a <code>Residue</code>  object to index the table to avoid subtle bugs if the alphabet changes.</p></div></div><p>You can change the alphabet used to count residues by setting the <code>alphabet</code> keyword of the <code>frequencies</code> function. Let&#39;s see an example with an reduced alphabet:</p><pre><code class="language-julia hljs">using MIToS.Information
using MIToS.MSA

alphabet = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
#   Fij[R,R] =   1  1  1   = 3 # RHK

Fij = frequencies(column_i, column_j, alphabet = alphabet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Frequencies{Float64, 2, MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    0.0    1.0    0.0    0.0    0.0    0.0    0.0
NQST          │   0.0    1.0    0.0    0.0    0.0    0.0    0.0    0.0
RHK           │   0.0    0.0    3.0    0.0    0.0    0.0    0.0    0.0
DE            │   2.0    0.0    0.0    1.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   1.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Matrix{Float64}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   2.0    4.0
NQST          │   1.0    1.0
RHK           │   3.0    4.0
DE            │   3.0    1.0
FWY           │   0.0    0.0
C             │   1.0    0.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 10.0</code></pre><pre><code class="language-julia hljs">Fij[Residue(&#39;R&#39;), Residue(&#39;R&#39;)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.0</code></pre><h3 id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence"><a class="docs-heading-anchor" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence">Example: Plotting the probabilities of each residue in a sequence</a><a id="Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence" title="Permalink"></a></h3><p>Like the <code>frequencies</code> function, the <code>probabilities</code> function can take at least one sequence or column (a vector of <code>Residue</code> objects) and return the probabilities of each  residue. Optionally, as before, the keyword argument <code>alphabet</code> could be used to count  some residues in the same table cell.</p><pre><code class="language-julia hljs">probabilities(res&quot;AARANHDDRDC&quot;, alphabet = alphabet)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Probabilities{Float64, 1, MIToS.MSA.ReducedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 1, MIToS.MSA.ReducedAlphabet} : 

table : 8-element Named Vector{Float64}
Dim_1  │ 
───────┼──────────
AILMV  │  0.272727
NQST   │ 0.0909091
RHK    │  0.272727
DE     │  0.272727
FWY    │       0.0
C      │ 0.0909091
G      │       0.0
P      │       0.0

total : 1.0</code></pre><p>Here, we are going to use the <code>probabilities</code> function to get the residue probabilities of a particular sequence from <em>UniProt</em>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MIToS.Information</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MIToS.MSA</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; file_name = &quot;http://www.uniprot.org/uniprot/P29374.fasta&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;http://www.uniprot.org/uniprot/P29374.fasta&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sequences = read_file(file_name, FASTASequences)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{MIToS.MSA.AnnotatedSequence}:
 [M K … C R]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pa = probabilities(sequences[1])</code><code class="nohighlight hljs ansi" style="display:block;">MIToS.Information.Probabilities{Float64, 1, MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 1, MIToS.MSA.UngappedAlphabet} :

table : 20-element Named Vector{Float64}
Dim_1  │
───────┼───────────
A      │   0.043755
R      │  0.0517104
N      │  0.0469372
D      │  0.0755768
C      │  0.0135243
Q      │   0.035004
E      │   0.134447
G      │   0.043755
⋮                 ⋮
M      │  0.0159109
F      │  0.0190931
P      │  0.0445505
S      │   0.100239
T      │  0.0493238
W      │ 0.00636436
Y      │  0.0198886
V      │  0.0517104

total : 1.0</code></pre><pre><code class="language-julia hljs">using Plots # We choose Plots because it&#39;s intuitive and concise
gr(size = (600, 300))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plots.GRBackend()</code></pre><p>You can plot together with the probabilities of each residue in a given sequence, the probabilities of each residue estimated with the BLOSUM62 substitution matrix. That matrix is exported as a constant by the <code>Information</code> module as <code>BLOSUM62_Pi</code>.</p><pre><code class="language-julia hljs">bar(1:20, [Pa BLOSUM62_Pi], lab = [&quot;Sequence&quot; &quot;BLOSUM62&quot;], alpha = 0.5)</code></pre><p><img src="../inf_plotfreq.png" alt/></p><h3 id="Low-level-interface"><a class="docs-heading-anchor" href="#Low-level-interface">Low-level interface</a><a id="Low-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-interface" title="Permalink"></a></h3><p>You can work directly with the <code>ContingencyTable</code> type if you want performance. The MIToS Information module also defines two types wrapping this multi-dimensional array; <code>Frequencies</code> and <code>Probabilities</code>, to store occurrences or probabilities, respectively. The <code>ContingencyTable</code> type stores the contingency matrix, its marginal values, and its total. These three types are parametric, taking three ordered parameters:</p><ul><li><code>T</code>: The type used for storing the counts or probabilities, e.g., <code>Float64</code>. If more  precision is needed, <code>BigFloat</code> is possible.</li><li><code>N</code>: It&#39;s the dimension of the table and should be an <code>Int</code>.</li><li><code>A</code>: This should be a type, subtype of <code>ResidueAlphabet</code>, i.e.: <code>UngappedAlphabet</code>, <code>GappedAlphabet</code>, or <code>ReducedAlphabet</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ContingencyTable</code> can be used to store probabilities or counts. The wrapper types <code>Probabilities</code> and <code>Frequencies</code> are mainly intended to dispatch in methods that need to know if the matrix has probabilities or counts. For example, the implementation of <code>shannon_entropy</code> is faster when the table is a <code>Frequencies</code> object.</p></div></div><p>In this way, a matrix for storing pairwise probabilities of residues (without gaps) can be initialized using:</p><pre><code class="language-julia hljs">using MIToS.Information

Pij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Matrix{Float64}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   0.0    0.0
R             │   0.0    0.0
N             │   0.0    0.0
D             │   0.0    0.0
C             │   0.0    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
⋮                   ⋮      ⋮
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    0.0

total : 0.0</code></pre><p>Note that the dimension of the table is indicated using <code>Val{2}</code> rather than <code>2</code>, so that Julia knows that the table is two-dimensional at compile time.</p><p>You can also obtain the <code>ContingencyTable</code> wrapped in a <code>Frequencies</code> object using  the <code>getcontingencytable</code> function. For example, you can take a table of counts and  normalize it using the <code>normalize</code> function to get a table of probabilities that you can  later wrap in a <code>Probabilities</code> object:</p><pre><code class="language-julia hljs">using MIToS.MSA
using MIToS.Information
column_i = res&quot;AARANHDDRDC-&quot;
column_j = res&quot;-ARRNHADRAVY&quot;
Fij = frequencies(column_i, column_j)
Pij = Probabilities(normalize(getcontingencytable(Fij)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Probabilities{Float64, 2, MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │   A    R    N    D    C    Q  …    P    S    T    W    Y    V
──────────────┼──────────────────────────────────────────────────────────────
A             │ 0.1  0.1  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
R             │ 0.0  0.2  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
N             │ 0.0  0.0  0.1  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
D             │ 0.2  0.0  0.0  0.1  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
C             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.1
Q             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
E             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
G             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
⋮                 ⋮    ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮    ⋮
M             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
F             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
P             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
S             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
T             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
W             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
Y             │ 0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
V             │ 0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0

marginals : 20×2 Named Matrix{Float64}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
A             │   0.2    0.3
R             │   0.2    0.3
N             │   0.1    0.1
D             │   0.3    0.1
C             │   0.1    0.0
Q             │   0.0    0.0
E             │   0.0    0.0
G             │   0.0    0.0
⋮                   ⋮      ⋮
M             │   0.0    0.0
F             │   0.0    0.0
P             │   0.0    0.0
S             │   0.0    0.0
T             │   0.0    0.0
W             │   0.0    0.0
Y             │   0.0    0.0
V             │   0.0    0.1

total : 1.0</code></pre><h2 id="Low-count-corrections"><a class="docs-heading-anchor" href="#Low-count-corrections">Low count corrections</a><a id="Low-count-corrections-1"></a><a class="docs-heading-anchor-permalink" href="#Low-count-corrections" title="Permalink"></a></h2><p>A low number of observations can lead to sparse contingency tables that lead to wrong probability estimations. It is shown in <a href="../References/#10.1093/bioinformatics/btp135">Buslje <em>et al.</em> [3]</a> that low-count corrections, can lead to improvements in the contact prediction capabilities of the mutual information. The Information module has available two low-count corrections:</p><ol><li><a href="../Information_API/#MIToS.Information.AdditiveSmoothing"><code>AdditiveSmoothing</code></a>: <a href="https://en.wikipedia.org/wiki/Additive_smoothing">Additive smoothing<img src="../assets/external-link.png" alt/></a>  corrects the frequencies by adding a constant value to each cell of the table. It can be used to represent the constant value pseudocount described in <a href="../References/#10.1093/bioinformatics/btp135">Buslje <em>et al.</em> [3]</a>. For example: <code>AdditiveSmoothing(1.0)</code> can be used to  add <code>1.0</code> to each cell of the table.</li><li><a href="../Information_API/#MIToS.Information.BLOSUM_Pseudofrequencies"><code>BLOSUM_Pseudofrequencies</code></a>: BLOSUM62-based pseudo frequencies for residues pairs,  similar to <a href="../References/#10.1093/nar/25.17.3389">Altschul <em>et al.</em> [4]</a> and described in  [<a href="../References/#10.1093/bioinformatics/btw646">1</a>]</li></ol><p>The <code>frequencies</code> and <code>probabilities</code> functions have a <code>pseudocounts</code> keyword argument that can take an <code>AdditiveSmoothing</code> value to calculate occurrences and probabilities with  pseudo counts.</p><pre><code class="language-julia hljs">using MIToS.MSA
using MIToS.Information
seq = res&quot;AAAVRNHDDRDCPPPGGPPG&quot;
frequencies(seq, pseudocounts = AdditiveSmoothing(1.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Frequencies{Float64, 1, MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 1, MIToS.MSA.UngappedAlphabet} : 

table : 20-element Named Vector{Float64}
Dim_1  │ 
───────┼────
A      │ 4.0
R      │ 3.0
N      │ 2.0
D      │ 4.0
C      │ 2.0
Q      │ 1.0
E      │ 1.0
G      │ 4.0
⋮          ⋮
M      │ 1.0
F      │ 1.0
P      │ 6.0
S      │ 1.0
T      │ 1.0
W      │ 1.0
Y      │ 1.0
V      │ 2.0

total : 40.0</code></pre><p>The <code>probabilities</code> function can also take a <code>pseudofrequencies</code> keyword argument that can take a <code>BLOSUM_Pseudofrequencies</code> object to calculate probabilities with pseudo  frequencies. Note that these pseudofrequencies can only be used on bidimensional tables,  i.e. passing only two sequences or columns to the <code>probabilities</code> function, and using <code>UngappedAlphabet()</code> (the default alphabet).</p><pre><code class="language-julia hljs">using MIToS.MSA
using MIToS.Information
column_i = res&quot;ARANHDDRDC&quot;
column_j = res&quot;-RRNHADRAV&quot;
probabilities(column_i, column_j, pseudofrequencies = BLOSUM_Pseudofrequencies(10, 8.512))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Probabilities{Float64, 2, MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │           A            R  …            Y            V
──────────────┼──────────────────────────────────────────────────────
A             │   0.0025812    0.0671681  …  0.000659565   0.00194086
R             │  0.00284631     0.133119     0.000898756   0.00172866
N             │  0.00328919   0.00301308     0.000682269   0.00145771
D             │    0.133185   0.00378038      0.00121515   0.00381553
C             │  0.00208857   0.00127052     0.000589305    0.0668084
Q             │  0.00142694   0.00247813      0.00033108  0.000699949
E             │    0.003512   0.00324315     0.000557825   0.00134036
G             │  0.00214771   0.00303399     0.000436419   0.00119478
⋮                         ⋮            ⋮  ⋱            ⋮            ⋮
M             │ 0.000521219  0.000978248     0.000135993  0.000411015
F             │ 0.000778701   0.00119943     0.000210395  0.000551961
P             │  0.00101033   0.00142181     0.000203036  0.000567906
S             │  0.00244132   0.00361921     0.000499758   0.00141208
T             │  0.00169218   0.00249277     0.000346269   0.00108457
W             │ 0.000196949  0.000349704      5.40184e-5  0.000128953
Y             │ 0.000675454   0.00115816     0.000266102  0.000431768
V             │  0.00138077   0.00259873  …   0.00032221   0.00125388

marginals : 20×2 Named Matrix{Float64}
Residue ╲ Dim │      Dim_1       Dim_2
──────────────┼───────────────────────
A             │   0.093333    0.166519
R             │    0.16693    0.243387
N             │  0.0956191   0.0918704
D             │   0.252676   0.0952168
C             │  0.0886361  0.00561482
Q             │  0.0151327   0.0160779
E             │  0.0275049   0.0232662
G             │  0.0214472   0.0219686
⋮                        ⋮           ⋮
M             │ 0.00609007  0.00760737
F             │ 0.00868029  0.00993714
P             │ 0.00977333   0.0100034
S             │  0.0246863   0.0255755
T             │  0.0172989   0.0186683
W             │ 0.00226332  0.00252896
Y             │ 0.00874174  0.00980948
V             │  0.0158639   0.0893325

total : 1.0</code></pre><h3 id="Low-level-interface-2"><a class="docs-heading-anchor" href="#Low-level-interface-2">Low-level interface</a><a class="docs-heading-anchor-permalink" href="#Low-level-interface-2" title="Permalink"></a></h3><p>If you have a preallocated <code>ContingencyTable</code>, for performance reasons, you can use <code>frequencies!</code> or the <code>probabilities!</code> functions to fill it. That  prevents the creation of a new table as <code>frequencies</code> and <code>probabilities</code> do. However, you should note that <code>frequencies!</code> and <code>probabilities!</code> <strong>add the new counts to the pre-existing values</strong>. Therefore, you can use the <code>cleanup!</code> function to set the table to zero  before filling it. </p><p>Let&#39;s see an example, in this case we start with a table of zeros, <code>Nij</code>, and fill it  with the counts of the residues in the columns <code>column_i</code> and <code>column_j</code> using the <code>frequencies!</code> function. Since we start with a new table, we don&#39;t need to use <code>cleanup!</code>.</p><pre><code class="language-julia hljs">using MIToS.MSA
using MIToS.Information

file_name = &quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;

msa = read_file(file_name, Stockholm)

column_i = msa[:, 1]
column_j = msa[:, 2]

const ALPHABET = ReducedAlphabet(&quot;(AILMV)(NQST)(RHK)(DE)(FWY)CGP&quot;)

Nij = ContingencyTable(Float64, Val{2}, ALPHABET)

frequencies!(Nij, column_i, column_j)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
NQST          │  42.0  114.0   10.0   33.0    1.0    1.0    0.0    0.0
RHK           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
DE            │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
FWY           │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
C             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
G             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0
P             │   0.0    0.0    0.0    0.0    0.0    0.0    0.0    0.0

marginals : 8×2 Named Matrix{Float64}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   0.0   42.0
NQST          │ 201.0  114.0
RHK           │   0.0   10.0
DE            │   0.0   33.0
FWY           │   0.0    1.0
C             │   0.0    1.0
G             │   0.0    0.0
P             │   0.0    0.0

total : 201.0</code></pre><p>In cases like the above, where there are few observations, applying a constant pseudocount  to the contingency table could be beneficial. This module defines the type <code>AdditiveSmoothing</code> and the corresponding <code>fill!</code> and  <a href="../Information_API/#MIToS.Information.apply_pseudocount!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, N, A}, T}} where {T, N, A}"><code>apply_pseudocount!</code></a> methods  to efficiently fill or add a constant value to each element of the table.</p><pre><code class="language-julia hljs">apply_pseudocount!(Nij, AdditiveSmoothing(1.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.ReducedAlphabet} : 

table : 8×8 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │ AILMV   NQST    RHK     DE    FWY      C      G      P
──────────────┼───────────────────────────────────────────────────────
AILMV         │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
NQST          │  43.0  115.0   11.0   34.0    2.0    2.0    1.0    1.0
RHK           │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
DE            │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
FWY           │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
C             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
G             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0
P             │   1.0    1.0    1.0    1.0    1.0    1.0    1.0    1.0

marginals : 8×2 Named Matrix{Float64}
Residue ╲ Dim │ Dim_1  Dim_2
──────────────┼─────────────
AILMV         │   8.0   50.0
NQST          │ 209.0  122.0
RHK           │   8.0   18.0
DE            │   8.0   41.0
FWY           │   8.0    9.0
C             │   8.0    9.0
G             │   8.0    8.0
P             │   8.0    8.0

total : 265.0</code></pre><p>If we work with a normalized contingency table or a <code>Probabilities</code> object and use the  <code>UnappedAlphabet()</code>, we can apply the BLOSUM62-based pseudo frequencies to the table.  For that, we can use the <code>BLOSUM_Pseudofrequencies</code> type and the <code>apply_pseudofrequencies!</code>  function. That function first needs to calculate the actual probabilities <span>$p_{a,b}$</span> for  each pair of residues <span>$a$</span>, <span>$b$</span>. Then, it uses the conditional probability matrix  <code>BLOSUM62_Pij</code> and the observed probabilities to calculate pseudo frequencies <span>$G$</span>.</p><p class="math-container">\[G_{ab} = \sum_{cd}  p_{cd} \cdot BLOSUM62( a | c ) \cdot BLOSUM62( b | d )\]</p><p>The <code>apply_pseudofrequencies!</code> function calculates the probability <span>$P$</span> of each pair of  residues <span>$a$</span>, <span>$b$</span> between the columns <span>$i$</span>, <span>$j$</span> as the weighted mean between the observed  frequency <span>$p$</span> and BLOSUM62-based pseudo frequency <span>$G$</span>. The former has α as weight, and the  latter has the parameter β. We use the number of sequences or sequence clusters as α, and  β is an empiric weight value that we determined to be close to <code>8.512</code>.</p><p class="math-container">\[P_{ab} = \frac{\alpha \cdot p_{ab} + \beta \cdot G_{ab} }{\alpha + \beta}\]</p><p>The <code>BLOSUM_Pseudofrequencies</code> type is defined with two parameters, α and β, that are  set using the positional arguments of the constructor.</p><pre><code class="language-julia hljs">using MIToS.MSA
using MIToS.Information
column_i = res&quot;ARANHDDRDC&quot;
column_j = res&quot;-RRNHADRAV&quot;
Pij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())
probabilities!(Pij, column_i, column_j)
α = 10
β = 8.512
apply_pseudofrequencies!(Pij, BLOSUM_Pseudofrequencies(α, β))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │           A            R  …            Y            V
──────────────┼──────────────────────────────────────────────────────
A             │   0.0025812    0.0671681  …  0.000659565   0.00194086
R             │  0.00284631     0.133119     0.000898756   0.00172866
N             │  0.00328919   0.00301308     0.000682269   0.00145771
D             │    0.133185   0.00378038      0.00121515   0.00381553
C             │  0.00208857   0.00127052     0.000589305    0.0668084
Q             │  0.00142694   0.00247813      0.00033108  0.000699949
E             │    0.003512   0.00324315     0.000557825   0.00134036
G             │  0.00214771   0.00303399     0.000436419   0.00119478
⋮                         ⋮            ⋮  ⋱            ⋮            ⋮
M             │ 0.000521219  0.000978248     0.000135993  0.000411015
F             │ 0.000778701   0.00119943     0.000210395  0.000551961
P             │  0.00101033   0.00142181     0.000203036  0.000567906
S             │  0.00244132   0.00361921     0.000499758   0.00141208
T             │  0.00169218   0.00249277     0.000346269   0.00108457
W             │ 0.000196949  0.000349704      5.40184e-5  0.000128953
Y             │ 0.000675454   0.00115816     0.000266102  0.000431768
V             │  0.00138077   0.00259873  …   0.00032221   0.00125388

marginals : 20×2 Named Matrix{Float64}
Residue ╲ Dim │      Dim_1       Dim_2
──────────────┼───────────────────────
A             │   0.093333    0.166519
R             │    0.16693    0.243387
N             │  0.0956191   0.0918704
D             │   0.252676   0.0952168
C             │  0.0886361  0.00561482
Q             │  0.0151327   0.0160779
E             │  0.0275049   0.0232662
G             │  0.0214472   0.0219686
⋮                        ⋮           ⋮
M             │ 0.00609007  0.00760737
F             │ 0.00868029  0.00993714
P             │ 0.00977333   0.0100034
S             │  0.0246863   0.0255755
T             │  0.0172989   0.0186683
W             │ 0.00226332  0.00252896
Y             │ 0.00874174  0.00980948
V             │  0.0158639   0.0893325

total : 1.0</code></pre><h2 id="Correction-for-data-redundancy-in-a-MSA"><a class="docs-heading-anchor" href="#Correction-for-data-redundancy-in-a-MSA">Correction for data redundancy in a MSA</a><a id="Correction-for-data-redundancy-in-a-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Correction-for-data-redundancy-in-a-MSA" title="Permalink"></a></h2><p>A simple way to reduce redundancy in an MSA without losing sequences is through  clusterization and sequence weighting. The weight of each sequence should be <span>$1/N$</span>,  where <span>$N$</span> is the number of sequences in its cluster. The <code>Clusters</code> type of the <code>MSA</code>  module stores the weights. This vector of weights can be extracted  (with the <code>getweight</code> function) and used by the <code>frequencies</code> and <code>probabilities</code> functions  with the keyword argument <code>weights</code>. Also, using the <code>Clusters</code> as the second argument of  the function <code>frequencies!</code> is possible.</p><pre><code class="language-julia hljs">clusters = hobohmI(msa, 62) # from MIToS.MSA</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.MSA.Clusters([1, 4, 3, 1, 2, 1, 2, 9, 9, 3  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  297, 462, 463, 46, 122, 464, 111, 465, 429, 348], [1.0, 0.25, 0.3333333333333333, 1.0, 0.5, 1.0, 0.5, 0.1111111111111111, 0.1111111111111111, 0.3333333333333333  …  0.3333333333333333, 1.0, 1.0, 0.14285714285714285, 0.1111111111111111, 1.0, 0.3333333333333333, 1.0, 0.5, 0.3333333333333333])</code></pre><pre><code class="language-julia hljs">frequencies(msa[:, 1], msa[:, 2], weights = clusters)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.Information.Frequencies{Float64, 2, MIToS.MSA.UngappedAlphabet} wrapping a MIToS.Information.ContingencyTable{Float64, 2, MIToS.MSA.UngappedAlphabet} : 

table : 20×20 Named Matrix{Float64}
Dim_1 ╲ Dim_2 │        A         R         N  …         W         Y         V
──────────────┼──────────────────────────────────────────────────────────────
A             │      0.0       0.0       0.0  …       0.0       0.0       0.0
R             │      0.0       0.0       0.0          0.0       0.0       0.0
N             │      0.0       0.0       0.0          0.0       0.0       0.0
D             │      0.0       0.0       0.0          0.0       0.0       0.0
C             │      0.0       0.0       0.0          0.0       0.0       0.0
Q             │      0.0       0.0       0.0          0.0       0.0       0.0
E             │      0.0       0.0       0.0          0.0       0.0       0.0
G             │      0.0       0.0       0.0          0.0       0.0       0.0
⋮                      ⋮         ⋮         ⋮  ⋱         ⋮         ⋮         ⋮
M             │      0.0       0.0       0.0          0.0       0.0       0.0
F             │      0.0       0.0       0.0          0.0       0.0       0.0
P             │      0.0       0.0       0.0          0.0       0.0       0.0
S             │  3.27778       3.2   23.1333     0.333333       0.0   12.5012
T             │      0.0       0.0       0.0          0.0       0.0       0.0
W             │      0.0       0.0       0.0          0.0       0.0       0.0
Y             │      0.0       0.0       0.0          0.0       0.0       0.0
V             │      0.0       0.0       0.0  …       0.0       0.0       0.0

marginals : 20×2 Named Matrix{Float64}
Residue ╲ Dim │    Dim_1     Dim_2
──────────────┼───────────────────
A             │      0.0   3.27778
R             │      0.0       3.2
N             │      0.0   23.1333
D             │      0.0   10.2833
C             │      0.0       1.0
Q             │      0.0      7.55
E             │      0.0    4.9619
G             │      0.0       0.0
⋮                      ⋮         ⋮
M             │      0.0       1.0
F             │      0.0       0.0
P             │      0.0       0.0
S             │  107.531   16.8833
T             │      0.0   18.4024
W             │      0.0  0.333333
Y             │      0.0       0.0
V             │      0.0   12.5012

total : 107.53055555555555</code></pre><h2 id="Estimating-information-measures-on-an-MSA"><a class="docs-heading-anchor" href="#Estimating-information-measures-on-an-MSA">Estimating information measures on an MSA</a><a id="Estimating-information-measures-on-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-information-measures-on-an-MSA" title="Permalink"></a></h2><p>The <code>Information</code> module has a number of functions defined to calculate information measures from <code>Frequencies</code> and <code>Probabilities</code>:</p><ul><li><code>shannon_entropy</code> : Shannon entropy (H)</li><li><code>marginal_entropy</code> : Shannon entropy (H) of the marginals</li><li><code>kullback_leibler</code> : Kullback-Leibler (KL) divergence</li><li><code>mutual_information</code> : Mutual Information (MI)</li><li><code>normalized_mutual_information</code> : Normalized Mutual Information (nMI) by Entropy</li><li><code>gap_intersection_percentage</code></li><li><code>gap_union_percentage</code></li></ul><p>Information measure functions take optionally the base as a keyword argument (default: <code>ℯ</code>). You can set <code>base=2</code> to measure information in bits.</p><pre><code class="language-julia hljs">using MIToS.Information
using MIToS.MSA

Ni = frequencies(res&quot;PPCDPPPPPKDKKKKDDGPP&quot;) # Ni has the count table of residues in this low complexity sequence

H = shannon_entropy(Ni) # returns the Shannon entropy in nats (base e)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.327362863420189</code></pre><pre><code class="language-julia hljs">H = shannon_entropy(Ni, base = 2) # returns the Shannon entropy in bits (base 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.9149798205164812</code></pre><p>Information module defines special iteration functions to easily and efficiently compute a measure over a MSA. In particular, <code>mapcolfreq!</code> and <code>mapseqfreq!</code> map a function that takes a table of <code>Frequencies</code> or <code>Probabilities</code>. The table is filled in place with the counts or probabilities of each column or sequence of a MSA, respectively. <code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> are similar, but they fill the table using pairs of columns or sequences, respectively.</p><p>This functions take three positional arguments: the function <code>f</code> to be calculated, the <code>msa</code> and <code>table</code> of <code>Frequencies</code> or <code>Probabilities</code>.</p><p>After that, this function takes some keyword arguments:</p><ul><li><code>weights</code> (default: <code>NoClustering()</code>) : Weights to be used for table counting.</li><li><code>pseudocounts</code> (default: <code>NoPseudocount()</code>) : <code>Pseudocount</code> object to be applied to table.</li><li><code>pseudofrequencies</code> (default: <code>NoPseudofrequencies()</code>) : <code>Pseudofrequencies</code> to be applied to the normalized (probabilities) table.</li><li><code>usediagonal</code> (default: <code>true</code>) : Indicates if the function should be applied to pairs containing the same sequence or column.</li><li><code>diagonalvalue</code> (default to zero) : The value that fills the diagonal elements of the table if <code>usediagonal</code> is <code>false</code>.</li></ul><h4 id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA"><a class="docs-heading-anchor" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA">Example: Estimating <em>H(X)</em> and <em>H(X, Y)</em> over an MSA</a><a id="Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA" title="Permalink"></a></h4><p>In this example, we are going to use <code>mapcolfreq!</code> and <code>mapcolpairfreq!</code> to estimate Shannon <code>shannon_entropy</code> of MSA columns <em>H(X)</em> and the joint entropy <em>H(X, Y)</em> of columns pairs, respectively.</p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read_file(
    &quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;,
    Stockholm,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 835 annotations : 811×113 Named Matrix{MIToS.MSA.Residue}
                 Seq ╲ Col │  53   54   55   56   57  …  428  429  430  431  432
───────────────────────────┼────────────────────────────────────────────────────
A0A370X5B3_9GAMM/1736-1853 │   -    -    -    -    -  …    Y    A    Y    R    L
D1AVB4_STRM9/461-568       │   -    -    -    -    -       Y    R    Y    R    L
A0A2T5HR93_9PSED/761-875   │   S    N    L    T    S       Y    Q    Y    T    L
A0A427CBK0_9GAMM/418-540   │   -    -    -    -    -       F    R    Y    R    L
A0A1I1MWW5_9BURK/779-907   │   -    -    -    -    -       Y    E    Y    R    L
C6JIE8_FUSVA/367-481       │   -    I    I    S    N       Y    E    Y    F    L
A0A017H8U7_9FUSO/691-802   │   S    S    V    T    E       Y    E    Y    T    L
A0A085VLZ6_PSESX/333-446   │   -    -    -    -    -       Y    E    Y    Y    L
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A318T6N3_9RHIZ/636-751   │   -    -    -    K    T       Y    V    Y    Q    L
A0A388SGN0_9BURK/625-739   │   S    E    L    T    T       Y    L    Y    E    L
A0A443IAD3_9GAMM/1863-1969 │   -    -    -    -    -       Y    D    Y    S    L
A0A2S8VQP6_9CAUL/182-287   │   -    -    -    -    R       V    R    Y    R    -
A0A1A9RWJ5_9NEIS/1004-1099 │   S    T    V    T    N       -    -    -    -    -
A6T0K2_JANMA/343-459       │   -    -    -    -    -       Y    A    Y    T    L
Q2KVL9_BORA1/480-598       │   S    R    I    T    R       Y    E    Y    R    L
A0A2W4CX06_9RHIZ/331-444   │   -    -    -    -    N  …    Y    E    Y    L    L</code></pre><p>We are going to count residues to estimate the Shannon entropy. The <code>shannon_entropy</code> estimation is performed over a rehused <code>Frequencies</code> object. The result will be a vector containing the values estimated over each column without counting gaps (<code>UngappedAlphabet</code>).</p><pre><code class="language-julia hljs">using MIToS.Information

Hx = mapcolfreq!(
    shannon_entropy,
    msa,
    Frequencies(ContingencyTable(Float64, Val{1}, UngappedAlphabet())),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×113 Named Matrix{Float64}
 Function ╲ Col │        53         54  …        431        432
────────────────┼──────────────────────────────────────────────
shannon_entropy │       0.0    2.28908  …    2.43627        0.0</code></pre><p>If we want the <strong>joint entropy</strong> between columns pairs, we need to use a bidimensional table of <code>Frequencies</code> and <code>mapcolpairfreq!</code>.</p><pre><code class="language-julia hljs">Hxy = mapcolpairfreq!(
    shannon_entropy,
    msa,
    Frequencies(ContingencyTable(Float64, Val{2}, UngappedAlphabet())),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">113×113 Named PairwiseListMatrices.PairwiseListMatrix{Float64, true, Vector{Float64}}
Col1 ╲ Col2 │        53         54  …        431        432
────────────┼──────────────────────────────────────────────
53          │       0.0    2.27907  …    2.34531        0.0
54          │   2.27907    2.28908       4.19681    2.25097
55          │   1.12284     3.2452       3.37893    1.14042
56          │   1.77041    3.76691        4.0201    2.04439
57          │   2.18455    4.03923       4.17225    2.07303
58          │  0.570446    2.76359       3.06398   0.779658
59          │   2.11739     4.0329       4.28252    2.19535
60          │   1.53981    3.46025       3.35723    1.08494
⋮                     ⋮          ⋮  ⋱          ⋮          ⋮
423         │   1.09798    3.13026       3.42102    1.19229
424         │  0.479167    2.61361       2.62843   0.258226
427         │   1.34976    3.38375       3.37444    1.13379
428         │  0.600381    2.79541       3.06003   0.721655
429         │   1.52338    3.49462       3.90651    1.86877
430         │ 0.0584063     2.3272        2.4817  0.0594665
431         │   2.34531    4.19681       2.43627    2.40596
432         │       0.0    2.25097  …    2.40596        0.0</code></pre><p>In the above examples, we indicate the type of each occurrence in the counting and the probability table to use. Also, it&#39;s possible for some measures as <strong>entropy</strong> and <strong>mutual information</strong>, to estimate the values only with the count table (without calculate the probability table). Estimating measures only with a <code>ResidueCount</code> table, when this is possible, should be faster than using a probability table.</p><pre><code class="language-julia hljs">Time_Pab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(
        shannon_entropy,
        msa,
        Probabilities(ContingencyTable(Float64, Val{2}, UngappedAlphabet())),
    )
end

Time_Nab = map(1:100) do x
    time = @elapsed mapcolpairfreq!(
        shannon_entropy,
        msa,
        Frequencies(ContingencyTable(Float64, Val{2}, UngappedAlphabet())),
    )
end

using Plots
gr()

histogram(
    [Time_Pab Time_Nab],
    labels = [&quot;Using ResidueProbability&quot; &quot;Using ResidueCount&quot;],
    xlabel = &quot;Execution time [seconds]&quot;,
)</code></pre><p><img src="../inf_entropy.png" alt/></p><h2 id="Corrected-Mutual-Information"><a class="docs-heading-anchor" href="#Corrected-Mutual-Information">Corrected Mutual Information</a><a id="Corrected-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Corrected-Mutual-Information" title="Permalink"></a></h2><p>MIToS ships with two methods to easily calculate corrected mutual information. The first is the algorithm described in <a href="../References/#10.1093/bioinformatics/btp135">Buslje <em>et al.</em> [3]</a>. This algorithm can be accessed through the <code>buslje09</code> function and includes:</p><ol><li>Low count correction using <code>AdditiveSmoothing</code></li><li>Sequence weighting after a <code>hobohmI</code> clustering [<a href="../References/#10.1002/pro.5560010313">2</a>]</li><li>Average Product Correction (APC) proposed by <a href="../References/#10.1093/bioinformatics/btm604">Dunn <em>et al.</em> [5]</a>, through the <code>APC!</code> function that takes a MI matrix.</li><li>Z score correction using the functions <code>shuffle_msa!</code> from the MSA module and <code>zscore</code> from the <code>PairwiseListMatrices</code> package.</li></ol><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIToS.Information.buslje09" href="#MIToS.Information.buslje09"><code>MIToS.Information.buslje09</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>buslje09</code> takes a MSA and calculates a Z score and a corrected MI/MIp as described on <em>Busjle et al. 2009</em>.</p><p>keyword argument, type, default value and descriptions:</p><pre><code class="nohighlight hljs">  - lambda      Float64   0.05    Low count value
  - clustering  Bool      true    Sequence clustering (Hobohm I)
  - threshold             62      Percent identity threshold for clustering
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       100     Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples
  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used</code></pre><p>This function returns:</p><pre><code class="nohighlight hljs">  - Z score
  - MI or MIp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/17a145136e8287f0c05b332b9c41b0a78deba377/src/Information/CorrectedMutualInformation.jl#L27-L50">source</a></section></article><p>The second, implemented in the <code>BLMI</code> function, has the same corrections that the above algorithm, but use BLOSUM62 pseudo frequencies. This function is <strong>slower</strong> than <code>buslje09</code> (at the same number of samples), but gives <strong>better performance</strong> (for structural contact prediction) when the MSA has <strong>less than 400 clusters</strong> after a Hobohm I at 62% identity.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MIToS.Information.BLMI" href="#MIToS.Information.BLMI"><code>MIToS.Information.BLMI</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>BLMI</code> takes an MSA and calculates a Z score (ZBLMI) and a corrected MI/MIp as described on <strong>Busjle et al. 2009</strong> but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.</p><p>Keyword argument, type, default value and descriptions:</p><pre><code class="nohighlight hljs">  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies
  - lambda      Float64   0.0     Low count value
  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)
  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation
  - apc         Bool      true    Use APC correction (MIp)
  - samples     Int       50      Number of samples for Z-score
  - fixedgaps   Bool      true    Fix gaps positions for the random samples</code></pre><p>This function returns:</p><pre><code class="nohighlight hljs">  - Z score (ZBLMI)
  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)</code></pre><p><strong>References</strong></p><ul><li><a href="../References/#10.1093/bioinformatics/btp135">Buslje, Cristina Marino, et al. &quot;Correction for phylogeny, small number of observations and data redundancy improves the identification of coevolving amino acid pairs using mutual information.&quot; Bioinformatics 25.9 (2009): 1125-1131.</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/diegozea/MIToS.jl/blob/17a145136e8287f0c05b332b9c41b0a78deba377/src/Information/CorrectedMutualInformation.jl#L112-L142">source</a></section></article><h4 id="Example:-Estimating-corrected-MI-from-an-MSA"><a class="docs-heading-anchor" href="#Example:-Estimating-corrected-MI-from-an-MSA">Example: Estimating corrected MI from an MSA</a><a id="Example:-Estimating-corrected-MI-from-an-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-corrected-MI-from-an-MSA" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MIToS.MSA
using MIToS.Information

msa = read_file(
    &quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;,
    Stockholm,
)
ZMIp, MIp = buslje09(msa)
ZMIp</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">107×107 Named PairwiseListMatrices.PairwiseListMatrix{Float64, false, Vector{Float64}}
Col1 ╲ Col2 │         57          58  …         431         432
────────────┼──────────────────────────────────────────────────
57          │        NaN     3.25274  …     1.38945    -1.38567
58          │    3.25274         NaN       -2.08538     4.56056
59          │    5.04975     3.23443        2.97155     -2.7079
60          │    1.38393     3.33905        -3.2956     1.39512
61          │    3.51849     1.02903       0.505697    -1.69826
64          │    1.17778     4.11793       -2.63834     5.06113
65          │   0.101109    -1.15235       0.836405     -2.6048
66          │   0.264063     4.73749       -3.05505      2.7723
⋮                      ⋮           ⋮  ⋱           ⋮           ⋮
423         │   0.367235    -1.75688      -0.223408   -0.700785
424         │    1.49777     1.40958       -2.50772     4.30845
427         │    1.14857   -0.376888         2.0029    0.170692
428         │   -2.05199     2.28319       -1.30895     3.03717
429         │   0.231057    -1.23643        6.09982    -0.72507
430         │   -1.40566     2.68801       -2.55912     5.80094
431         │    1.38945    -2.08538            NaN    -3.08604
432         │   -1.38567     4.56056  …    -3.08604         NaN</code></pre><pre><code class="language-julia hljs">ZBLMIp, BLMIp = BLMI(msa)
ZBLMIp</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">107×107 Named PairwiseListMatrices.PairwiseListMatrix{Float64, false, Vector{Float64}}
Col1 ╲ Col2 │           57            58  …           431           432
────────────┼──────────────────────────────────────────────────────────
57          │          NaN    -0.0058753  …      0.054706   -0.00724753
58          │   -0.0058753           NaN      -0.00230327     0.0093646
59          │  -0.00462501     0.0177384        0.0716935   -0.00916293
60          │   -0.0385254     0.0114635       -0.0411778    0.00585093
61          │    0.0076633   -0.00767814        0.0146958   -0.00519354
64          │    0.0070737    0.00620751        -0.005128     0.0122708
65          │    -0.046307    -0.0287545       0.00846159    -0.0071145
66          │    -0.018272     0.0306033       -0.0277811    0.00521656
⋮                        ⋮             ⋮  ⋱             ⋮             ⋮
423         │     0.030699    -0.0166871       -0.0186436   -0.00203097
424         │    0.0653332    -0.0104712       -0.0142883    0.00839156
427         │    0.0409193    -0.0109902        0.0254383  -0.000165967
428         │   -0.0293523     0.0176844      -0.00865934     0.0105738
429         │    0.0123588    -0.0182636        0.0861102   -0.00345761
430         │   -0.0202489   -0.00581871       -0.0176394     0.0242715
431         │     0.054706   -0.00230327              NaN   -0.00883419
432         │  -0.00724753     0.0093646  …   -0.00883419           NaN</code></pre><h2 id="Visualize-Mutual-Information"><a class="docs-heading-anchor" href="#Visualize-Mutual-Information">Visualize Mutual Information</a><a id="Visualize-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-Mutual-Information" title="Permalink"></a></h2><p>You can use the function of the <code>Plots</code> package to visualize the Mutual Information (MI) network between residues. As an example, we are going to visualize the MI between residues of the Pfam domain <em>PF18883</em>. The <code>heatmap</code> is the simplest way to visualize the values of the Mutual Information matrix.</p><pre><code class="language-julia hljs">using Plots
gr()

heatmap(ZMIp, yflip = true)</code></pre><p><img src="../inf_heatmap.png" alt/></p><p>ZMIp is a Z score of the corrected MIp against its distribution on a random MSA (shuffling the residues in each sequence), so pairs with highest values are more likely to coevolve. Here, we are going to use the top 1% pairs of MSA columns.</p><pre><code class="language-julia hljs">using PairwiseListMatrices # to use getlist
using Statistics # to use quantile

threshold = quantile(getlist(ZMIp), 0.99)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6.967400960553533</code></pre><pre><code class="language-julia hljs">ZMIp[ZMIp.&lt;threshold] .= NaN
heatmap(ZMIp, yflip = true)</code></pre><p><img src="../inf_heatmap_top.png" alt/></p><p>We are going to calculate the cMI (cumulative mutual information) value of each node. Where cMI is a mutual information score per position that characterizes the extent of mutual information &quot;interactions&quot; in its neighbourhood. This score is calculated as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network and we are going to indicate it using the node color. To calculate cMI we are going to use the <code>cumulative</code> function:</p><pre><code class="language-julia hljs">cMI = cumulative(ZMIp, threshold)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×107 Named Matrix{Float64}
Function ╲ Col2 │      57       58       59  …      430      431      432
────────────────┼────────────────────────────────────────────────────────
cumulative      │     0.0      0.0      0.0  …      0.0      0.0      0.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MSA/">« MSA</a><a class="docs-footer-nextpage" href="../SIFTS/">SIFTS »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 30 July 2024 20:59">Tuesday 30 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
