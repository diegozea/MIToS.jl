<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MSA · MIToS</title><meta name="title" content="MSA · MIToS"/><meta property="og:title" content="MSA · MIToS"/><meta property="twitter:title" content="MSA · MIToS"/><meta name="description" content="Documentation for MIToS."/><meta property="og:description" content="Documentation for MIToS."/><meta property="twitter:description" content="Documentation for MIToS."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MIToS</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Installation/">Installation</a></li><li><a class="tocitem" href="../Example/">Example</a></li><li><span class="tocitem">Modules</span><ul><li class="is-active"><a class="tocitem" href>MSA</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#MSA-IO"><span>MSA IO</span></a></li><li><a class="tocitem" href="#MSA-Annotations"><span>MSA Annotations</span></a></li><li><a class="tocitem" href="#Editing-your-MSA"><span>Editing your MSA</span></a></li><li><a class="tocitem" href="#Column-and-sequence-mappings"><span>Column and sequence mappings</span></a></li><li><a class="tocitem" href="#Get-sequences-from-a-MSA"><span>Get sequences from a MSA</span></a></li><li><a class="tocitem" href="#Describing-your-MSA"><span>Describing your MSA</span></a></li><li><a class="tocitem" href="#Sequence-clustering"><span>Sequence clustering</span></a></li></ul></li><li><a class="tocitem" href="../Information/">Information</a></li><li><a class="tocitem" href="../SIFTS/">SIFTS</a></li><li><a class="tocitem" href="../PDB/">PDB</a></li><li><a class="tocitem" href="../Pfam/">Pfam</a></li></ul></li><li><span class="tocitem">Cookbook</span><ul><li><a class="tocitem" href="../01_Change_B_factors/">Change B-factors</a></li><li><a class="tocitem" href="../02_Linking_structural_and_evolutionary_information/">Linking structural and evolutionary information</a></li><li><a class="tocitem" href="../03_RMSF/">Root Mean Squared Fluctuation (RMSF)</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../MSA_API/">MSA</a></li><li><a class="tocitem" href="../Information_API/">Information</a></li><li><a class="tocitem" href="../SIFTS_API/">SIFTS</a></li><li><a class="tocitem" href="../PDB_API/">PDB</a></li><li><a class="tocitem" href="../Pfam_API/">Pfam</a></li><li><a class="tocitem" href="../Utils_API/">Utils</a></li></ul></li><li><a class="tocitem" href="../Scripts/">Scripts</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>MSA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MSA</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/diegozea/MIToS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/diegozea/MIToS.jl/blob/master/docs/src/MSA.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-MSA"><a class="docs-heading-anchor" href="#Module-MSA">MSA</a><a id="Module-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Module-MSA" title="Permalink"></a></h1><p>The MSA module of MIToS has utilities for working with Multiple Sequence Alignments of protein Sequences (MSA).  </p><pre><code class="language-julia hljs">using MIToS.MSA # to load the MSA module</code></pre><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li><a href="#Reading-MSA-files"><strong>Read</strong></a> and <a href="#Writing-MSA-files"><strong>write</strong></a> MSAs in <code>Stockholm</code>, <code>FASTA</code>, <code>PIR</code> or <code>Raw</code> format.</li><li>Handle <a href="#MSA-Annotations"><strong>MSA annotations</strong></a>.</li><li><a href="#Editing-your-MSA"><strong>Edit the MSA</strong></a>, e.g. delete columns or sequences, change sequence order, shuffling...</li><li><a href="#Column-and-sequence-mappings"><strong>Keep track of positions</strong></a> and annotations after modifications on the MSA.</li><li><a href="#Describing-your-MSA"><strong>Describe an MSA</strong></a>, e.g. mean percent identity, sequence coverage, gap percentage...</li><li><a href="#Sequence-clustering"><strong>Sequence clustering</strong></a> with Hobohm I.</li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Module-MSA">MSA</a></li><li class="no-marker"><ul><li><a href="#Features">Features</a></li><li><a href="#Contents">Contents</a></li><li><a href="#MSA-IO">MSA IO</a></li><li class="no-marker"><ul><li><a href="#Reading-MSA-files">Reading MSA files</a></li><li><a href="#Writing-MSA-files">Writing MSA files</a></li></ul></li><li><a href="#MSA-Annotations">MSA Annotations</a></li><li><a href="#Editing-your-MSA">Editing your MSA</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#Example:-Deleting-sequences">Example: Deleting sequences</a></li><li><a href="#Example:-Exporting-a-MSA-for-freecontact-(part-I)">Example: Exporting a MSA for freecontact (part I)</a></li></ul></li></ul></li><li><a href="#Column-and-sequence-mappings">Column and sequence mappings</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#Example:-Exporting-a-MSA-for-freecontact-(part-II)">Example: Exporting a MSA for freecontact (part II)</a></li></ul></li></ul></li><li><a href="#Get-sequences-from-a-MSA">Get sequences from a MSA</a></li><li><a href="#Describing-your-MSA">Describing your MSA</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence">Example: Plotting gap percentage per column and coverage per sequence</a></li><li><a href="#Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction">Example: Filter sequences per coverage and columns per gap fraction</a></li><li><a href="#Example:-Plotting-the-percentage-of-identity-between-sequences">Example: Plotting the percentage of identity between sequences</a></li></ul></li></ul></li><li><a href="#Sequence-clustering">Sequence clustering</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#Example:-Reducing-redundancy-of-a-MSA">Example: Reducing redundancy of a MSA</a></li></ul></li></ul></li></ul></li></ul><h2 id="MSA-IO"><a class="docs-heading-anchor" href="#MSA-IO">MSA IO</a><a id="MSA-IO-1"></a><a class="docs-heading-anchor-permalink" href="#MSA-IO" title="Permalink"></a></h2><h3 id="Reading-MSA-files"><a class="docs-heading-anchor" href="#Reading-MSA-files">Reading MSA files</a><a id="Reading-MSA-files-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-MSA-files" title="Permalink"></a></h3><p>The main function for reading MSA files in MIToS is <code>read</code> and it is defined in the <code>Utils</code> module. This function takes a filename/path as a first argument followed by other arguments. It opens the file and uses the arguments to call the <code>parse</code> function. <code>read</code> decides how to open the file, using the prefixes (e.g. https) and suffixes (i.e. extensions) of the file name, while <code>parse</code> does the actual parsing of the file. You can <code>read</code> <strong>gzipped files</strong> if they have the <code>.gz</code> extension and also urls pointing to a <strong>web file</strong>.   The second argument of <code>read</code> and <code>parse</code> is the file <code>FileFormat</code>. The supported MSA formats at the moment are <code>Stockholm</code>, <code>FASTA</code>, <code>PIR</code> (NBRF) and <code>Raw</code>.   For example, reading with MIToS the full Stockholm MSA of the Pfam family <em>PF09645</em> from  the MIToS test data will be:  </p><pre><code class="language-julia hljs">using MIToS.MSA

read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;, Stockholm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 9 annotations : 4×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
C3N734_SULIY/1-95  │   -    -    -    N    S  …    -    -    -    -    -
H2C869_9CREN/7-104 │   -    -    L    N    D       -    -    -    -    -
Y070_ATV/2-70      │   -    -    -    -    -       -    -    -    -    -
F112_SSV1/3-112    │   Q    T    L    N    S  …    I    K    A    K    Q</code></pre><p>The third (and optional) argument of <code>read</code> and <code>parse</code> is the output MSA type:  </p><ul><li><code>Matrix{Residue}</code> : It only contains the aligned sequences.  </li><li><code>MultipleSequenceAlignment</code> : It contains the aligned sequences and their names/identifiers.  </li><li><code>AnnotatedMultipleSequenceAlignment</code> : It&#39;s the richest MIToS&#39; MSA format and it&#39;s the default. It includes the aligned sequences, their names and the MSA annotations.  </li></ul><p>Example of <code>Matrix{Residue}</code> output using a <code>Stockholm</code> file as input:</p><pre><code class="language-julia hljs">read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;, Stockholm, Matrix{Residue})</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×110 Matrix{MIToS.MSA.Residue}:
 -  -  -  N  S  Y  Q  M  A  E  I  M  Y  …  -  -  -  -  -  -  -  -  -  -  -  -
 -  -  L  N  D  V  Q  R  A  K  L  L  V     -  -  -  -  -  -  -  -  -  -  -  -
 -  -  -  -  -  -  -  V  A  Q  Q  L  F     -  -  -  -  -  -  -  -  -  -  -  -
 Q  T  L  N  S  Y  K  M  A  E  I  M  Y     E  Q  T  D  Q  G  F  I  K  A  K  Q</code></pre><p>Because <code>read</code> calls <code>parse</code>, you should look into the documentation of <code>parse</code> to know the available keyword arguments. The optional keyword arguments of those functions are:  </p><ul><li><code>generatemapping</code> : If <code>generatemapping</code> is <code>true</code> (default: <code>false</code>), sequences and columns mappings are generated and saved in the MSA annotations. <strong>The default is <code>false</code> to not overwrite mappings by mistake when you read an annotated MSA file saved with MIToS.</strong>  </li><li><code>useidcoordinates</code> : If <code>useidcoordinates</code> is <code>true</code> (default: <code>false</code>) and the names have the form <em>seqname/start-end</em>, MIToS uses this coordinates to generate sequence</li></ul><p>mappings. This is safe and useful with unmodified Pfam MSAs. <strong>Do not use it when reading an MSA saved with MIToS. MIToS deletes unaligned insert columns, therefore disrupts sequences that have them.</strong>  </p><ul><li><code>deletefullgaps</code> : Given that lowercase characters and dots are converted to gaps, unaligned insert columns in the MSA (derived from a HMM profile) are converted into full</li></ul><p>gap columns. <code>deletefullgaps</code> is <code>true</code> by default, deleting full gaps columns and therefore insert columns.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><strong>If you want to keep the insert columns...</strong>  Use the keyword argument <code>keepinserts</code> to <code>true</code> in <code>read</code>/<code>parse</code>. This only works with an <code>AnnotatedMultipleSequenceAlignment</code> output. A column annotation (<code>&quot;Aligned&quot;</code>) is stored in the annotations, where insert columns are marked with <code>0</code> and aligned columns with <code>1</code>.  </p></div></div><p>When <code>read</code> returns an <code>AnnotatedMultipleSequenceAlignment</code>, it uses the MSA <code>Annotations</code> to keep track of performed modifications. To access these notes, use <code>printmodifications</code>:  </p><pre><code class="language-julia hljs">msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;, Stockholm)

printmodifications(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-------------------
2024-01-05T16:31:54.818

deletefullgaps!  :  Deletes 10 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
filtercolumns! : 10 columns have been deleted.</code></pre><h3 id="Writing-MSA-files"><a class="docs-heading-anchor" href="#Writing-MSA-files">Writing MSA files</a><a id="Writing-MSA-files-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-MSA-files" title="Permalink"></a></h3><p>Julia REPL shows MSAs as Matrices. If you want to print them in another format, you should use the <code>print</code> function with an MSA object as first argument and the <code>FileFormat</code> <code>FASTA</code>, <code>Stockholm</code>, <code>PIR</code> or <code>Raw</code> as second argument.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;, Stockholm) # reads a Stockholm MSA file

print(msa, FASTA) # prints msa in FASTA format</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&gt;C3N734_SULIY/1-95
---NSYQMAEIMYKILQQKKEISLEDILAQFEISASTAYNVQRTLRMICEKHPDECEVQTKNRRTIFKWIKNEETTEEGQEE--QEIEKILNAQPAE-------------
&gt;H2C869_9CREN/7-104
--LNDVQRAKLLVKILQAKGELDVYDIMLQFEISYTRAIPIMKLTRKICEAQ-EICTYDEKEHKLVSLNAKKEKVEQDEEENEREEIEKILDAH----------------
&gt;Y070_ATV/2-70
-------VAQQLFSKLREKKEITAEDIIAIYNVTPSVAYAIFTVLKVMCQQHQGECQAIKRGRKTVI-------------------------------------------
&gt;F112_SSV1/3-112
QTLNSYKMAEIMYKILEKKGELTLEDILAQFEISVPSAYNIQRALKAICERHPDECEVQYKNRKTTFKWIKQEQKEEQKQEQTQDNIAKIFDAQPANFEQTDQGFIKAKQ</code></pre><p>To save an MSA object to a file, use the <code>write</code> function. This function takes a filename as a first argument. If the filename ends with <code>.gz</code>, the output will be a compressed (gzipped) file. The next two arguments of <code>write</code> are passed to <code>print</code>, so <code>write</code> behaves as <code>print</code>.  </p><pre><code class="language-julia hljs">write(&quot;msa.gz&quot;, msa, FASTA) # writes msa in FASTA format in a gzipped file</code></pre><h2 id="MSA-Annotations"><a class="docs-heading-anchor" href="#MSA-Annotations">MSA Annotations</a><a id="MSA-Annotations-1"></a><a class="docs-heading-anchor-permalink" href="#MSA-Annotations" title="Permalink"></a></h2><p>MSA annotations are based on the Stockholm format mark-ups. There are four types of annotations stored as dictionaries. All the annotations have a feature name as part of the key, which should be a single &quot;word&quot; (without spaces) and less than 50 characters long.  </p><ul><li><strong>File annotations</strong> : The annotations can contain either file or MSA information. They have feature names as keys and the values are strings (free text). Lines starting with</li></ul><p><code>#=GF</code> in Stockholm format.  </p><ul><li><strong>Column annotations</strong> : They have feature names as keys and strings with exactly 1 char per column as values. Lines starting with <code>#=GC</code> in Stockholm format.  </li><li><strong>Sequence annotations</strong> : The keys are tuples with the sequence name and the feature name. The values are free text (strings). Lines starting with <code>#=GS</code> in Stockholm format.</li></ul><p>Annotations in the <code>PIR</code>/NBRF format are also stored as sequence annotations. In particular, we use the names <code>&quot;Type&quot;</code> and <code>&quot;Title&quot;</code> to name the sequence type in the identifier line and the first comment line before the sequence in PIR files, respectively.  </p><ul><li><strong>Residue annotations</strong> : The keys are tuples with the sequence name and the feature name. The values are strings with exactly 1 char per column/residues. <code>#=GR</code> lines in Stockholm format.  </li></ul><p>Julia REPL shows the <code>Annotations</code> type as they are represented in the <a href="https://en.wikipedia.org/wiki/Stockholm_format">Stockholm format<img src="../assets/external-link.png" alt/></a>. You can get the <code>Annotations</code> inside an annotated MSA or sequence using the <code>annotations</code> function.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF16996.alignment.full&quot;, Stockholm)

annotations(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#=GF ID	Asp4
#=GF AC	PF16996.8
#=GF DE	Accessory secretory protein Sec Asp4
#=GF AU	Coggill P;0000-0001-5731-1588
#=GF SE	Pfam-B_7603 (release 27.0)
#=GF GA	27.70 27.70;
#=GF TC	29.00 28.80;
#=GF NC	25.50 25.40;
#=GF BM	hmmbuild HMM.ann SEED.ann
#=GF SM	hmmsearch -Z 61295632 -E 1000 --cpu 4 HMM pfamseq
#=GF TP	Family
#=GF RN	[1]
#=GF RM	23000954
#=GF RT	Emerging themes in SecA2-mediated protein export.
#=GF RA	Feltcher ME, Braunstein M;
#=GF RL	Nat Rev Microbiol. 2012;10:779-789.
#=GF DR	INTERPRO; IPR031551;
#=GF DR	SO; 0100021; polypeptide_conserved_region;
#=GF CC	Asp4 and Asp5 are putative accessory components of the SecY2
#=GF CC	channel of the SecA2-SecY2 mediated export system, but they are
#=GF CC	not present in all SecA2-SecY2 systems. This family of Asp4 is
#=GF CC	found in Firmicutes [1].
#=GF SQ	6
#=GF MIToS_2024-01-05T16:31:55.183	deletefullgaps!  :  Deletes 5 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
#=GF MIToS_2024-01-05T16:31:55.183	filtercolumns! : 5 columns have been deleted.
#=GS A3CM62_STRSV/3-57	AC	A3CM62.1
#=GS A0A139NMD7_9STRE/5-59	AC	A0A139NMD7.1
#=GS J0UVX5_STREE/3-41	AC	J0UVX5.1
#=GS A0A4Q0VKA2_9LACO/6-62	AC	A0A4Q0VKA2.1
#=GS A0A139NPI6_9STRE/5-59	AC	A0A139NPI6.1
#=GS A8AWV6_STRGC/3-57	AC	A8AWV6.1
#=GC seq_cons			KcDLFYKDIEGRM-ELK+KsPKKEKcotGE+LNphFsluLGLhILlGLlFTLlt.
</code></pre><p>Particular annotations can be accessed using the functions <code>getannot...</code>. These functions take the MSA/sequence as first argument and the feature name of the desired annotation as the last. In the case of <code>getannotsequence</code> and <code>getannotresidue</code>, the second argument should be the sequence name.  </p><pre><code class="language-julia hljs">getannotsequence(msa, &quot;A8AWV6_STRGC/3-57&quot;, &quot;AC&quot;) # (&quot;A8AWV6_STRGC/3-57&quot;, &quot;AC&quot;) is the key in the dictionary</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;A8AWV6.1&quot;</code></pre><p>If you want to add new annotations, you should use the <code>setannot…!</code> functions. These functions have the same arguments that <code>getannot...</code> functions except for an extra argument used to indicate the new annotation value.  </p><pre><code class="language-julia hljs">setannotsequence!(msa, &quot;A8AWV6_STRGC/3-57&quot;, &quot;New_Feature_Name&quot;, &quot;New_Annotation&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;New_Annotation&quot;</code></pre><p>A <code>getannot...</code> function without the key (last arguments), returns the particular annotation dictionary. As you can see, the new sequence annotation is now part of our MSA annotations.  </p><pre><code class="language-julia hljs">getannotsequence(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Tuple{String, String}, String} with 7 entries:
  (&quot;A3CM62_STRSV/3-57&quot;, &quot;AC&quot;)               =&gt; &quot;A3CM62.1&quot;
  (&quot;A0A139NMD7_9STRE/5-59&quot;, &quot;AC&quot;)           =&gt; &quot;A0A139NMD7.1&quot;
  (&quot;A8AWV6_STRGC/3-57&quot;, &quot;New_Feature_Name&quot;) =&gt; &quot;New_Annotation&quot;
  (&quot;J0UVX5_STREE/3-41&quot;, &quot;AC&quot;)               =&gt; &quot;J0UVX5.1&quot;
  (&quot;A0A4Q0VKA2_9LACO/6-62&quot;, &quot;AC&quot;)           =&gt; &quot;A0A4Q0VKA2.1&quot;
  (&quot;A0A139NPI6_9STRE/5-59&quot;, &quot;AC&quot;)           =&gt; &quot;A0A139NPI6.1&quot;
  (&quot;A8AWV6_STRGC/3-57&quot;, &quot;AC&quot;)               =&gt; &quot;A8AWV6.1&quot;</code></pre><h2 id="Editing-your-MSA"><a class="docs-heading-anchor" href="#Editing-your-MSA">Editing your MSA</a><a id="Editing-your-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Editing-your-MSA" title="Permalink"></a></h2><p>MIToS offers functions to edit your MSA. Because these functions modify the msa, their names end with a bang <code>!</code>, following the Julia convention. Some of these functions have an <code>annotate</code> keyword argument (in general, it&#39;s <code>true</code> by default) to indicate if the modification should be recorded in the MSA/sequence annotations.  </p><p>One common task is to delete sequences or columns of the MSA. This could be done using the functions <code>filtersequences!</code> and <code>filtercolumns!</code>. These functions take the MSA or sequence (if it&#39;s possible) as first argument and a <code>BitVector</code> or <code>Vector{Bool}</code> mask as second argument. It deletes all the sequences or columns where the mask is <code>false</code>. These functions are also defined for <code>Annotations</code>, this allows to automatically update (modify) the annotations (and therefore, sequence and column mappings) in the MSA.  </p><p>This two deleting operations are used in the second and third mutating functions of the following list:  </p><ul><li><code>setreference!</code> : Sets one of the sequences as the first sequence of the MSA (query or reference sequence).  </li><li><code>adjustreference!</code> : Deletes columns with gaps in the first sequence of the MSA (reference).  </li><li><code>gapstrip!</code> : This function first calls <code>adjustreference!</code>, then deletes sequences with low (user defined) MSA coverage and finally, columns with user defined % of gaps.  </li></ul><p>Also, there are several available funtions <code>shuffle_…!</code>. These functions are useful to generate random alignments. The <code>Information</code> module of <code>MIToS</code> uses them to calculate the Z scores of MI values.  </p><h4 id="Example:-Deleting-sequences"><a class="docs-heading-anchor" href="#Example:-Deleting-sequences">Example: Deleting sequences</a><a id="Example:-Deleting-sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Deleting-sequences" title="Permalink"></a></h4><p>For example, if you want to delete all proteins from <em>Sulfolobus islandicus</em> in the  <em>PF09645</em> MSA, you can delete all the sequences that have <code>_SULIY</code> in their  UniProt entry names:  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;, Stockholm)

sequencenames(msa) # the function sequencenames returns the sequence names in the MSA</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{String}:
 &quot;C3N734_SULIY/1-95&quot;
 &quot;H2C869_9CREN/7-104&quot;
 &quot;Y070_ATV/2-70&quot;
 &quot;F112_SSV1/3-112&quot;</code></pre><pre><code class="language-julia hljs">mask = map(x -&gt; !occursin(r&quot;_SULIY&quot;, x), sequencenames(msa)) # an element of mask is true if &quot;_SULIY&quot; is not in the name</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Bool}:
 0
 1
 1
 1</code></pre><pre><code class="language-julia hljs">filtersequences!(msa, mask) # deletes all the sequences where mask is false

sequencenames(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{String}:
 &quot;H2C869_9CREN/7-104&quot;
 &quot;Y070_ATV/2-70&quot;
 &quot;F112_SSV1/3-112&quot;</code></pre><h4 id="Example:-Exporting-a-MSA-for-freecontact-(part-I)"><a class="docs-heading-anchor" href="#Example:-Exporting-a-MSA-for-freecontact-(part-I)">Example: Exporting a MSA for freecontact (part I)</a><a id="Example:-Exporting-a-MSA-for-freecontact-(part-I)-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Exporting-a-MSA-for-freecontact-(part-I)" title="Permalink"></a></h4><p>The most simple input for the command line tool <a href="https://rostlab.org/owiki/index.php/FreeContact">freecontact<img src="../assets/external-link.png" alt/></a> (if you don&#39;t want to set <code>--mincontsep</code>) is a <code>Raw</code> MSA file with a reference sequence without insertions or gaps. This is easy to get with MIToS using <code>read</code> (deletes the insert columns), <code>setreference!</code> (to choose a reference), <code>adjustreference!</code> (to delete columns with gaps in the reference) and <code>write</code> (to save it in <code>Raw</code> format) functions.  </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MIToS.MSA</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;, Stockholm)</code><code class="nohighlight hljs ansi" style="display:block;">AnnotatedMultipleSequenceAlignment with 9 annotations : 4×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
C3N734_SULIY/1-95  │   -    -    -    N    S  …    -    -    -    -    -
H2C869_9CREN/7-104 │   -    -    L    N    D       -    -    -    -    -
Y070_ATV/2-70      │   -    -    -    -    -       -    -    -    -    -
F112_SSV1/3-112    │   Q    T    L    N    S  …    I    K    A    K    Q</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; msa_coverage = coverage(msa)</code><code class="nohighlight hljs ansi" style="display:block;">4×1 Named Matrix{Float64}
    Seq ╲ Function │ coverage
───────────────────┼─────────
C3N734_SULIY/1-95  │ 0.836364
H2C869_9CREN/7-104 │ 0.827273
Y070_ATV/2-70      │ 0.545455
F112_SSV1/3-112    │      1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; maxcoverage, maxindex = findmax(msa_coverage) # chooses the sequence with more coverage of the MSA</code><code class="nohighlight hljs ansi" style="display:block;">(1.0, CartesianIndex(4, 1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; setreference!(msa, maxindex[1])</code><code class="nohighlight hljs ansi" style="display:block;">AnnotatedMultipleSequenceAlignment with 10 annotations : 4×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
F112_SSV1/3-112    │   Q    T    L    N    S  …    I    K    A    K    Q
H2C869_9CREN/7-104 │   -    -    L    N    D       -    -    -    -    -
Y070_ATV/2-70      │   -    -    -    -    -       -    -    -    -    -
C3N734_SULIY/1-95  │   -    -    -    N    S  …    -    -    -    -    -</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; adjustreference!(msa)</code><code class="nohighlight hljs ansi" style="display:block;">AnnotatedMultipleSequenceAlignment with 10 annotations : 4×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
F112_SSV1/3-112    │   Q    T    L    N    S  …    I    K    A    K    Q
H2C869_9CREN/7-104 │   -    -    L    N    D       -    -    -    -    -
Y070_ATV/2-70      │   -    -    -    -    -       -    -    -    -    -
C3N734_SULIY/1-95  │   -    -    -    N    S  …    -    -    -    -    -</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; write(&quot;tofreecontact.msa&quot;, msa, Raw)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(read(&quot;tofreecontact.msa&quot;, String)) # It displays the contents of the output file</code><code class="nohighlight hljs ansi" style="display:block;">QTLNSYKMAEIMYKILEKKGELTLEDILAQFEISVPSAYNIQRALKAICERHPDECEVQYKNRKTTFKWIKQEQKEEQKQEQTQDNIAKIFDAQPANFEQTDQGFIKAKQ
--LNDVQRAKLLVKILQAKGELDVYDIMLQFEISYTRAIPIMKLTRKICEAQ-EICTYDEKEHKLVSLNAKKEKVEQDEEENEREEIEKILDAH----------------
-------VAQQLFSKLREKKEITAEDIIAIYNVTPSVAYAIFTVLKVMCQQHQGECQAIKRGRKTVI-------------------------------------------
---NSYQMAEIMYKILQQKKEISLEDILAQFEISASTAYNVQRTLRMICEKHPDECEVQTKNRRTIFKWIKNEETTEEGQEE--QEIEKILNAQPAE-------------</code></pre><h2 id="Column-and-sequence-mappings"><a class="docs-heading-anchor" href="#Column-and-sequence-mappings">Column and sequence mappings</a><a id="Column-and-sequence-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Column-and-sequence-mappings" title="Permalink"></a></h2><p>Inserts in a Stockholm MSA allow to access the full fragment of the aligned sequences. Using this, combined with the sequence names that contain coordinates used in Pfam, you can know what is the UniProt residue number of each residue in the MSA.   </p><pre><code class="language-julia hljs">&quot;PROT_SPECI/3-15 .....insertALIGNED&quot;
#                     3456789111111
#                            012345</code></pre><p>MIToS <code>read</code> and <code>parse</code> functions delete the insert columns, but they do the mapping between each residue and its residue number before deleting insert columns when <code>generatemapping</code> is <code>true</code>. If you don&#39;t set <code>useidcoordinates</code> to <code>true</code>, the residue first <code>i</code> residue will be 1 instead of 3 in the previous example.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = parse(&quot;PROT_SPECI/3-15 .....insertALIGNED&quot;, Stockholm, generatemapping=true, useidcoordinates=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 5 annotations : 1×7 Named Matrix{MIToS.MSA.Residue}
      Seq ╲ Col │ 12  13  14  15  16  17  18
────────────────┼───────────────────────────
PROT_SPECI/3-15 │  A   L   I   G   N   E   D</code></pre><p>MIToS also keeps the column number of the input MSA and its total number of columns. All this data is stored in the MSA annotations using the <code>SeqMap</code>, <code>ColMap</code> and <code>NCol</code> feature names.  </p><pre><code class="language-julia hljs">annotations(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#=GF NCol	18
#=GF ColMap	12,13,14,15,16,17,18
#=GF MIToS_2024-01-05T16:31:57.355	deletefullgaps!  :  Deletes 11 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
#=GF MIToS_2024-01-05T16:31:57.356	filtercolumns! : 11 columns have been deleted.
#=GS PROT_SPECI/3-15	SeqMap	9,10,11,12,13,14,15
</code></pre><p>To have an easy access to mapping data, MIToS provides the <code>getsequencemapping</code> and <code>getcolumnmapping</code> functions.  </p><pre><code class="language-julia hljs">getsequencemapping(msa, &quot;PROT_SPECI/3-15&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Int64}:
  9
 10
 11
 12
 13
 14
 15</code></pre><pre><code class="language-julia hljs">getcolumnmapping(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Int64}:
 12
 13
 14
 15
 16
 17
 18</code></pre><h4 id="Example:-Exporting-a-MSA-for-freecontact-(part-II)"><a class="docs-heading-anchor" href="#Example:-Exporting-a-MSA-for-freecontact-(part-II)">Example: Exporting a MSA for freecontact (part II)</a><a id="Example:-Exporting-a-MSA-for-freecontact-(part-II)-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Exporting-a-MSA-for-freecontact-(part-II)" title="Permalink"></a></h4><p>If we want to use the <code>--mincontsep</code> argument of <code>freecontact</code> to calculate scores between distant residues, we will need to add a header to the MSA. This header should contains the residue number of the first residue of the sequence and the full fragment of that sequence (with the inserts). This data is used by FreeContact to calculate the residue number of each residue in the reference sequence.   We are going to use MIToS mapping data to create this header, so we read the MSA with <code>generatemapping</code> and <code>useidcoordinates</code> set to <code>true</code>.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read( &quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;, Stockholm,
            generatemapping=true, useidcoordinates=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 1649 annotations : 811×113 Named Matrix{MIToS.MSA.Residue}
                 Seq ╲ Col │  53   54   55   56   57  …  428  429  430  431  432
───────────────────────────┼────────────────────────────────────────────────────
A0A370X5B3_9GAMM/1736-1853 │   -    -    -    -    -  …    Y    A    Y    R    L
D1AVB4_STRM9/461-568       │   -    -    -    -    -       Y    R    Y    R    L
A0A2T5HR93_9PSED/761-875   │   S    N    L    T    S       Y    Q    Y    T    L
A0A427CBK0_9GAMM/418-540   │   -    -    -    -    -       F    R    Y    R    L
A0A1I1MWW5_9BURK/779-907   │   -    -    -    -    -       Y    E    Y    R    L
C6JIE8_FUSVA/367-481       │   -    I    I    S    N       Y    E    Y    F    L
A0A017H8U7_9FUSO/691-802   │   S    S    V    T    E       Y    E    Y    T    L
A0A085VLZ6_PSESX/333-446   │   -    -    -    -    -       Y    E    Y    Y    L
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A318T6N3_9RHIZ/636-751   │   -    -    -    K    T       Y    V    Y    Q    L
A0A388SGN0_9BURK/625-739   │   S    E    L    T    T       Y    L    Y    E    L
A0A443IAD3_9GAMM/1863-1969 │   -    -    -    -    -       Y    D    Y    S    L
A0A2S8VQP6_9CAUL/182-287   │   -    -    -    -    R       V    R    Y    R    -
A0A1A9RWJ5_9NEIS/1004-1099 │   S    T    V    T    N       -    -    -    -    -
A6T0K2_JANMA/343-459       │   -    -    -    -    -       Y    A    Y    T    L
Q2KVL9_BORA1/480-598       │   S    R    I    T    R       Y    E    Y    R    L
A0A2W4CX06_9RHIZ/331-444   │   -    -    -    -    N  …    Y    E    Y    L    L</code></pre><p>Here, we are going to choose the sequence with more coverage of the MSA as our reference sequence.  </p><pre><code class="language-julia hljs">msa_coverage = coverage(msa)
maxcoverage, maxindex = findmax(msa_coverage)
setreference!(msa, maxindex[1])
adjustreference!(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 1650 annotations : 811×113 Named Matrix{MIToS.MSA.Residue}
                 Seq ╲ Col │  53   54   55   56   57  …  428  429  430  431  432
───────────────────────────┼────────────────────────────────────────────────────
W3TV15_BARQI/1447-1579     │   S    S    I    S    A  …    Y    K    Y    T    L
D1AVB4_STRM9/461-568       │   -    -    -    -    -       Y    R    Y    R    L
A0A2T5HR93_9PSED/761-875   │   S    N    L    T    S       Y    Q    Y    T    L
A0A427CBK0_9GAMM/418-540   │   -    -    -    -    -       F    R    Y    R    L
A0A1I1MWW5_9BURK/779-907   │   -    -    -    -    -       Y    E    Y    R    L
C6JIE8_FUSVA/367-481       │   -    I    I    S    N       Y    E    Y    F    L
A0A017H8U7_9FUSO/691-802   │   S    S    V    T    E       Y    E    Y    T    L
A0A085VLZ6_PSESX/333-446   │   -    -    -    -    -       Y    E    Y    Y    L
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A318T6N3_9RHIZ/636-751   │   -    -    -    K    T       Y    V    Y    Q    L
A0A388SGN0_9BURK/625-739   │   S    E    L    T    T       Y    L    Y    E    L
A0A443IAD3_9GAMM/1863-1969 │   -    -    -    -    -       Y    D    Y    S    L
A0A2S8VQP6_9CAUL/182-287   │   -    -    -    -    R       V    R    Y    R    -
A0A1A9RWJ5_9NEIS/1004-1099 │   S    T    V    T    N       -    -    -    -    -
A6T0K2_JANMA/343-459       │   -    -    -    -    -       Y    A    Y    T    L
Q2KVL9_BORA1/480-598       │   S    R    I    T    R       Y    E    Y    R    L
A0A2W4CX06_9RHIZ/331-444   │   -    -    -    -    N  …    Y    E    Y    L    L</code></pre><p>MIToS deletes the residues in insert columns, so we are going to use the sequence mapping to generate the whole fragment of the reference sequence (filling the missing regions with <code>&#39;x&#39;</code>).  </p><pre><code class="language-julia hljs">seqmap = getsequencemapping(msa, 1) # seqmap will be a vector with the residue numbers of the first sequence (reference)

seq = collect( stringsequence(msa, 1) ) # seq will be a Vector of Chars with the reference sequence

sequence = map(seqmap[1]:seqmap[end]) do seqpos # for each position in the whole fragment
    if seqpos in seqmap                         # if that position is in the MSA
        popfirst!(seq)                          # the residue is taken from seq
    else                                        # otherwise
        &#39;x&#39;                                     # &#39;x&#39; is included
    end
end

sequence = join(sequence) # join the Chars on the Vector to create a string</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;SSISALHLVNSSLSFEKPESxxxDGYQTLRIGKGxxxxYNAQGNAxIYFNARLNPSDPSxxxxTDRLLIHGDVSGKTVVHVKGVSGSxGENNRSDKxxxxVSIIQVYGKAEKDSFQLSGDxxxLDDSPYKYTL&quot;</code></pre><p>Once we have the whole fragment of the sequence, we create the file and write the header in the required format (as in the man page of freecontact).  </p><pre><code class="language-julia hljs">open(&quot;tofreecontact.msa&quot;, &quot;w&quot;) do fh

    println(fh, &quot;# querystart=&quot;, seqmap[1])

    println(fh, &quot;# query=&quot;, sequence )

end</code></pre><p>As last (optional) argument, <code>write</code> takes the mode in which is opened the file. We use <code>&quot;a&quot;</code> here to append the MSA to the header.  </p><pre><code class="language-julia hljs">write(&quot;tofreecontact.msa&quot;, msa, Raw, &quot;a&quot;)</code></pre><pre><code class="language-julia hljs">print(join(first(readlines(&quot;tofreecontact.msa&quot;), 5), &#39;\n&#39;)) # It displays the first five lines</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"># querystart=1447
# query=SSISALHLVNSSLSFEKPESxxxDGYQTLRIGKGxxxxYNAQGNAxIYFNARLNPSDPSxxxxTDRLLIHGDVSGKTVVHVKGVSGSxGENNRSDKxxxxVSIIQVYGKAEKDSFQLSGDxxxLDDSPYKYTL
SSISALHLVNSSLSFEKPESDGYQTLRIGKGYNAQGNAIYFNARLNPSDPSTDRLLIHGDVSGKTVVHVKGVSGSGENNRSDKVSIIQVYGKAEKDSFQLSGDLDDSPYKYTL
--------NKGLISFLNSKD-NTSNLSIKGNYVGENSKLLMRTYIDE--LKSDKLKLDGSASGSTGVEISNPNFTLNKRMKNKLKLIET-KSSTKDAFTLLNP-EHGIYRYRL
SNLTSLRNDHSLIDFSAPVGTSFKTLTVNA-YHGANGSIGLNTYLGADGSPSDQLVLDGGNSGSSNLLISNAGGAGALTQGNGIQVVNAGASTDASAFRLVNEVKAGPYQYTL</code></pre><h2 id="Get-sequences-from-a-MSA"><a class="docs-heading-anchor" href="#Get-sequences-from-a-MSA">Get sequences from a MSA</a><a id="Get-sequences-from-a-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Get-sequences-from-a-MSA" title="Permalink"></a></h2><p>It&#39;s possible to index the MSA as any other matrix to get an aligned sequence. This will be return a <code>Array</code> of <code>Residue</code>s without annotations but keeping names/identifiers.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read( &quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/test/data/PF09645_full.stockholm&quot;,
            Stockholm, generatemapping=true, useidcoordinates=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 16 annotations : 4×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
C3N734_SULIY/1-95  │   -    -    -    N    S  …    -    -    -    -    -
H2C869_9CREN/7-104 │   -    -    L    N    D       -    -    -    -    -
Y070_ATV/2-70      │   -    -    -    -    -       -    -    -    -    -
F112_SSV1/3-112    │   Q    T    L    N    S  …    I    K    A    K    Q</code></pre><pre><code class="language-julia hljs">msa[2,:] # second sequence of the MSA, it keeps column names</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">110-element Named Vector{MIToS.MSA.Residue}
Col  │ 
─────┼──
6    │ -
7    │ -
8    │ L
9    │ N
10   │ D
11   │ V
12   │ Q
13   │ R
⋮      ⋮
108  │ -
109  │ -
110  │ -
111  │ -
112  │ -
113  │ -
114  │ -
115  │ -</code></pre><pre><code class="language-julia hljs">msa[2:2,:] # Using the range 2:2 to select the second sequence, keeping also the sequence name</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 9 annotations : 1×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
H2C869_9CREN/7-104 │   -    -    L    N    D  …    -    -    -    -    -</code></pre><p>If you want to obtain the aligned sequence with its name and annotations (and therefore sequence and column mappings), you should use the function <code>getsequence</code>. This function returns an <code>AlignedSequence</code> with the sequence name from a <code>MultipleSequenceAlignment</code> or an <code>AnnotatedAlignedSequence</code>, that also contains annotations, from an <code>AnnotatedMultipleSequenceAlignment</code>.  </p><pre><code class="language-julia hljs">secondsequence = getsequence(msa, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedAlignedSequence with 8 annotations : 1×110 Named Matrix{MIToS.MSA.Residue}
         Seq ╲ Col │   6    7    8    9   10  …  111  112  113  114  115
───────────────────┼────────────────────────────────────────────────────
H2C869_9CREN/7-104 │   -    -    L    N    D  …    -    -    -    -    -</code></pre><pre><code class="language-julia hljs">annotations(secondsequence)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#=GF NCol	120
#=GF ColMap	6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115
#=GF MIToS_2024-01-05T16:31:57.552	deletefullgaps!  :  Deletes 10 columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)
#=GF MIToS_2024-01-05T16:31:57.553	filtercolumns! : 10 columns have been deleted.
#=GS H2C869_9CREN/7-104	AC	H2C869.1
#=GS H2C869_9CREN/7-104	SeqMap	,,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,,,,,,,,,,,,,,,,
#=GC seq_cons			...NshphAclhaKILppKtElolEDIlAQFEISsosAYsI.+sL+hICEpH.-ECpsppKsRKTlhh.hKpEphppptpEp..ppItKIhsAp................
#=GC SS_cons			X---HHHHHHHHHHHHHHHSEE-HHHHHHHH---HHHHHHHHHHHHHHHHH-TTTEEEEE-SS-EEEEE--XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
</code></pre><p>Use <code>stringsequence</code> if you want to get the sequence as a string.  </p><pre><code class="language-julia hljs">stringsequence(msa, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;--LNDVQRAKLLVKILQAKGELDVYDIMLQFEISYTRAIPIMKLTRKICEAQ-EICTYDEKEHKLVSLNAKKEKVEQDEEENEREEIEKILDAH----------------&quot;</code></pre><p>Because matrices are stored columnwise in Julia, you will find useful the <code>getresiduesequences</code> function when you need to heavily operate over sequences.  </p><pre><code class="language-julia hljs">getresiduesequences(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Vector{MIToS.MSA.Residue}}:
 [-, -, -, N, S, Y, Q, M, A, E  …  -, -, -, -, -, -, -, -, -, -]
 [-, -, L, N, D, V, Q, R, A, K  …  -, -, -, -, -, -, -, -, -, -]
 [-, -, -, -, -, -, -, V, A, Q  …  -, -, -, -, -, -, -, -, -, -]
 [Q, T, L, N, S, Y, K, M, A, E  …  T, D, Q, G, F, I, K, A, K, Q]</code></pre><h2 id="Describing-your-MSA"><a class="docs-heading-anchor" href="#Describing-your-MSA">Describing your MSA</a><a id="Describing-your-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Describing-your-MSA" title="Permalink"></a></h2><p>The MSA module has a number of functions to gain insight about your MSA. Using <code>MIToS.MSA</code>, one can easily ask for...  </p><ul><li>The <strong>number of columns and sequences</strong> with the <code>ncolumns</code> and <code>nsequences</code> functions.  </li><li>The fraction of columns with residues (<strong>coverage</strong>) for each sequence making use of the <code>coverage</code> method.  </li><li>The <strong>fraction or percentage of gaps/residues</strong> using with the functions <code>gapfraction</code>, <code>residuefraction</code> and <code>columngapfraction</code>.  </li><li>The <strong>percentage of identity</strong> (PID) between each sequence of the MSA or its mean value with <code>percentidentity</code> and <code>meanpercentidentity</code>.  </li></ul><p>The percentage identity between two aligned sequences is a common measure of sequence similarity and is used by the <code>hobohmI</code> method to estimate and reduce MSA redundancy. <strong>MIToS functions to calculate percent identity don&#39;t align the sequences, they need already aligned sequences.</strong> Full gaps columns don&#39;t count to the alignment length.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = permutedims(
        hcat(   res&quot;--GGG-&quot;,      # res&quot;...&quot; uses the @res_str macro to create a (column) Vector{Residue}
                res&quot;---GGG&quot; ), (2,1))
#        identities 000110 sum 2
#  aligned residues 001111 sum 4</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×6 Matrix{MIToS.MSA.Residue}:
 -  -  G  G  G  -
 -  -  -  G  G  G</code></pre><pre><code class="language-julia hljs">percentidentity(msa[1,:], msa[2,:]) # 2 / 4</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50.0</code></pre><p>To quickly calculate if the percentage of identity is greater than a determined value, use that threshold as third argument. <code>percentidentity(seqa, seqb, pid)</code> is a lot more faster than <code>percentidentity(seqa, seqb) &gt;= pid</code>.  </p><pre><code class="language-julia hljs">percentidentity(msa[1,:], msa[2,:], 62) # 50% &gt;= 62%</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><h4 id="Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence"><a class="docs-heading-anchor" href="#Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence">Example: Plotting gap percentage per column and coverage per sequence</a><a id="Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence" title="Permalink"></a></h4><p>The <code>gapfraction</code> and <code>coverage</code> functions return a vector of numbers between <code>0.0</code> and <code>1.0</code> (fraction of...). Sometime it&#39;s useful to plot this data to quickly understand the MSA structure. In this example, we are going to use the <a href="http://plots.readthedocs.org/en/latest/">Plots<img src="../assets/external-link.png" alt/></a> package for plotting, with the <a href="https://github.com/jheinen/GR.jl">GR<img src="../assets/external-link.png" alt/></a> backend, but you are free to use any of the Julia plotting libraries.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;, Stockholm)

using Plots

gr(size=(600,300))

plot(   1:ncolumns(msa), # x is a range from 1 to the number of columns
        vec(columngapfraction(msa)) .* 100.0, # y is a Vector{Float64} with the percentage of gaps of each column
        linetype = :line,
        ylabel = &quot;gaps [%]&quot;,
        xlabel = &quot;columns&quot;,
        legend=false)</code></pre><p><img src="../msa_gaps.png" alt/>  </p><pre><code class="language-julia hljs">plot(   1:nsequences(msa), # x is a range from 1 to the number of sequences
        vec(coverage(msa)) .* 100, # y is a Vector{Float64} with the coverage of each sequence
        linetype = :line,
        ylabel = &quot;coverage [%]&quot;,
        xlabel = &quot;sequences&quot;,
        legend=false)</code></pre><p><img src="../msa_coverage.png" alt/>  </p><pre><code class="language-julia hljs">plot(msa)</code></pre><p><img src="../msa_msa.png" alt/>  </p><h4 id="Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction"><a class="docs-heading-anchor" href="#Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction">Example: Filter sequences per coverage and columns per gap fraction</a><a id="Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction" title="Permalink"></a></h4><p>Taking advantage of the <code>filter...!</code> functions and the <code>coverage</code> and <code>columngapfraction</code> functions, it&#39;s possible to delete short sequences or columns with a lot of gaps.  </p><pre><code class="language-julia hljs">println(&quot;\tsequences\tcolumns&quot;)
println( &quot;Before:\t&quot;, nsequences(msa), &quot;\t\t&quot;, ncolumns(msa)  )
# delete sequences with less than 90% coverage of the MSA length:
filtersequences!(msa, coverage(msa) .&gt;= 0.9)
# delete columns with more than 10% of gaps:
filtercolumns!(msa, columngapfraction(msa) .&lt;= 0.1)
println( &quot;After:\t&quot;, nsequences(msa), &quot;\t\t&quot;,  ncolumns(msa)  )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">	sequences	columns
Before:	811		113
After:	541		100</code></pre><pre><code class="language-julia hljs">histogram(  vec(columngapfraction(msa)),
            # Using vec() to get a Vector{Float64} with the fraction of gaps of each column
            xlabel = &quot;gap fraction in [0,1]&quot;, bins = 20, legend = false)</code></pre><p><img src="../msa_hist_gaps.png" alt/>  </p><pre><code class="language-julia hljs">histogram(  vec(coverage(msa) .* 100.0), #  Column with the coverage of each sequence
            xlabel = &quot;coverage [%]&quot;, legend=false)</code></pre><p><img src="../msa_hist_coverage.png" alt/>  </p><h4 id="Example:-Plotting-the-percentage-of-identity-between-sequences"><a class="docs-heading-anchor" href="#Example:-Plotting-the-percentage-of-identity-between-sequences">Example: Plotting the percentage of identity between sequences</a><a id="Example:-Plotting-the-percentage-of-identity-between-sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Plotting-the-percentage-of-identity-between-sequences" title="Permalink"></a></h4><p>The distribution of the percentage of identity between every pair of sequences in an MSA, gives an idea of the MSA diversity. In this example, we are  using <code>percentidentity</code> over an MSA to get those identity values.  </p><pre><code class="language-julia hljs">using MIToS.MSA
msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;, Stockholm)
pid = percentidentity(msa)</code></pre><p>MIToS stores the matrix of percentage of identity between the aligned sequences as a PairwiseListMatrix from the <a href="http://diegozea.github.io/PairwiseListMatrices.jl/">PairwiseListMatrices<img src="../assets/external-link.png" alt/></a> package. This matrix type saves RAM, allowing the storage of  big matrices. In this example, we use the <code>to_table</code> function of <em>PairwiseListMatrices</em> to convert the matrix into a table with indices.  </p><pre><code class="language-julia hljs">using PairwiseListMatrices

pidtable = to_table(pid, diagonal=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">328455×3 Matrix{Any}:
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;D1AVB4_STRM9/461-568&quot;      25.2336
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A2T5HR93_9PSED/761-875&quot;  37.1681
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A427CBK0_9GAMM/418-540&quot;  33.6449
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A1I1MWW5_9BURK/779-907&quot;  35.514
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;C6JIE8_FUSVA/367-481&quot;      39.0909
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A017H8U7_9FUSO/691-802&quot;  30.3571
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A085VLZ6_PSESX/333-446&quot;  42.9907
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;L0M846_ENTBF/1414-1524&quot;    53.7736
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A0S3PYS2_9BRAD/380-494&quot;  48.1481
 &quot;A0A370X5B3_9GAMM/1736-1853&quot;  &quot;A0A371WV37_9RHIZ/683-796&quot;  42.9907
 ⋮                                                         
 &quot;A0A2S8VQP6_9CAUL/182-287&quot;    &quot;A6T0K2_JANMA/343-459&quot;      24.2991
 &quot;A0A2S8VQP6_9CAUL/182-287&quot;    &quot;Q2KVL9_BORA1/480-598&quot;      20.354
 &quot;A0A2S8VQP6_9CAUL/182-287&quot;    &quot;A0A2W4CX06_9RHIZ/331-444&quot;  25.0
 &quot;A0A1A9RWJ5_9NEIS/1004-1099&quot;  &quot;A6T0K2_JANMA/343-459&quot;      18.9189
 &quot;A0A1A9RWJ5_9NEIS/1004-1099&quot;  &quot;Q2KVL9_BORA1/480-598&quot;      20.5357
 &quot;A0A1A9RWJ5_9NEIS/1004-1099&quot;  &quot;A0A2W4CX06_9RHIZ/331-444&quot;  20.5357
 &quot;A6T0K2_JANMA/343-459&quot;        &quot;Q2KVL9_BORA1/480-598&quot;      35.7143
 &quot;A6T0K2_JANMA/343-459&quot;        &quot;A0A2W4CX06_9RHIZ/331-444&quot;  37.963
 &quot;Q2KVL9_BORA1/480-598&quot;        &quot;A0A2W4CX06_9RHIZ/331-444&quot;  38.0531</code></pre><p>The function <code>quantile</code> gives a quick idea of the percentage identity distribution of the MSA.  </p><pre><code class="language-julia hljs">using Statistics

quantile(convert(Vector{Float64}, pidtable[:,3]), [0.00, 0.25, 0.50, 0.75, 1.00])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
   0.0
  27.77777777777778
  34.31372549019608
  40.0
 100.0</code></pre><p>The function <code>meanpercentidentity</code> gives the mean value of the percent identity distribution for MSA with less than 300 sequences, or a quick estimate (mean PID in a random sample of sequence pairs) otherwise unless you set <code>exact</code> to <code>true</code>.  </p><pre><code class="language-julia hljs">meanpercentidentity(msa)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">34.08304185834541</code></pre><p>One can easily plot that matrix and its distribution using the <code>heatmap</code> and <code>histogram</code> functions of the <a href="https://github.com/tbreloff/Plots.jl">Plots<img src="../assets/external-link.png" alt/></a> package.  </p><pre><code class="language-julia hljs">using Plots
gr()
heatmap(convert(Matrix, pid), yflip=true, ratio=:equal)</code></pre><p><img src="../msa_heatmap_pid.png" alt/>  </p><pre><code class="language-julia hljs">histogram(pidtable[:,3], xlabel =&quot;Percentage of identity&quot;, legend=false)</code></pre><p><img src="../msa_hist_pid.png" alt/>  </p><h2 id="Sequence-clustering"><a class="docs-heading-anchor" href="#Sequence-clustering">Sequence clustering</a><a id="Sequence-clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence-clustering" title="Permalink"></a></h2><p>The <code>MSA</code> module allows to clusterize sequences in an MSA. The <code>hobohmI</code> function takes as input an MSA followed by an identity threshold value, and returns a <code>Clusters</code> type with the result of a <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2142204/">Hobohm I<img src="../assets/external-link.png" alt/></a> sequence clustering. The Hobohm I algorithm will add a sequence to an existing cluster, if the percentage of identity is equal or greater than the threshold.   The <code>Clusters</code> is sub-type of <code>ClusteringResult</code> from the <a href="http://clusteringjl.readthedocs.org/en/latest/index.html">Clustering.jl<img src="../assets/external-link.png" alt/></a> package. One advantage of use a sub-type of <code>ClusteringResult</code>is that you are able to use any method defined on <code>Clustering.jl</code> like <code>varinfo</code> (Variation of Information) for example. Also, you can use any clustering algorithm included in <em>Clustering.jl</em>, and convert its result to an <code>Clusters</code> object to use it with MIToS.   <code>MSA</code> defines the functions <code>nclusters</code> to get the resulting number of clusters, <code>counts</code> to get the number of sequences on each cluster and <code>assignments</code> to get the cluster number of each sequence. The most important method is <code>getweight</code>, which returns the weight of each sequence. This method is used in the <code>Information</code> module of MIToS to reduce redundancy.  </p><h4 id="Example:-Reducing-redundancy-of-a-MSA"><a class="docs-heading-anchor" href="#Example:-Reducing-redundancy-of-a-MSA">Example: Reducing redundancy of a MSA</a><a id="Example:-Reducing-redundancy-of-a-MSA-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Reducing-redundancy-of-a-MSA" title="Permalink"></a></h4><p>MSAs can suffer from an unnatural sequence redundancy and a high number of protein fragments. In this example, we are using a sequence clustering to make a non-redundant set of representative sequences. We are going to use the function <code>hobohmI</code> to perform the clustering with the Hobohm I algorithm at 62% identity.  </p><pre><code class="language-julia hljs">using MIToS.MSA

msa = read(&quot;https://raw.githubusercontent.com/diegozea/MIToS.jl/master/docs/data/PF18883.stockholm.gz&quot;, Stockholm)

println(&quot;This MSA has &quot;, nsequences(msa), &quot; sequences...&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">This MSA has 811 sequences...</code></pre><pre><code class="language-julia hljs">clusters = hobohmI(msa, 62)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MIToS.MSA.Clusters([1, 4, 3, 1, 2, 1, 2, 9, 9, 3  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  297, 462, 463, 46, 122, 464, 111, 465, 429, 348], [1.0, 0.25, 0.3333333333333333, 1.0, 0.5, 1.0, 0.5, 0.1111111111111111, 0.1111111111111111, 0.3333333333333333  …  0.3333333333333333, 1.0, 1.0, 0.14285714285714285, 0.1111111111111111, 1.0, 0.3333333333333333, 1.0, 0.5, 0.3333333333333333])</code></pre><pre><code class="language-julia hljs">println(&quot;...but has only &quot;, nclusters(clusters), &quot; sequence clusters after a clustering at 62% identity.&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">...but has only 465 sequence clusters after a clustering at 62% identity.</code></pre><pre><code class="language-julia hljs">using Plots
gr()

plot(msa)</code></pre><p><img src="../msa_clusters_i.png" alt/>  </p><p>We are going to use the <a href="http://dataframesjl.readthedocs.org/en/latest/">DataFrames<img src="../assets/external-link.png" alt/></a> package to easily select the sequence with the highest coverage of each cluster.  </p><pre><code class="language-julia hljs">using DataFrames

df = DataFrame( seqnum = 1:nsequences(msa),
                seqname = sequencenames(msa),
                cluster = assignments(clusters), # the cluster number/index of each sequence
                coverage = vec(coverage(msa)))

first(df, 5)</code></pre><div><div style = "float: left;"><span>5×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">seqnum</th><th style = "text-align: left;">seqname</th><th style = "text-align: left;">cluster</th><th style = "text-align: left;">coverage</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "String" style = "text-align: left;">String</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">1</td><td style = "text-align: left;">A0A370X5B3_9GAMM/1736-1853</td><td style = "text-align: right;">1</td><td style = "text-align: right;">0.929204</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">2</td><td style = "text-align: left;">D1AVB4_STRM9/461-568</td><td style = "text-align: right;">2</td><td style = "text-align: right;">0.884956</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">3</td><td style = "text-align: left;">A0A2T5HR93_9PSED/761-875</td><td style = "text-align: right;">3</td><td style = "text-align: right;">0.99115</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">4</td><td style = "text-align: left;">A0A427CBK0_9GAMM/418-540</td><td style = "text-align: right;">4</td><td style = "text-align: right;">0.920354</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: left;">A0A1I1MWW5_9BURK/779-907</td><td style = "text-align: right;">5</td><td style = "text-align: right;">0.734513</td></tr></tbody></table></div><p>It is possible to use this <code>DataFrame</code> and <code>Plots</code> to plot the sequence coverage of the MSA and also an histogram of the number of sequences in each cluster:  </p><pre><code class="language-julia hljs">using StatsPlots # Plotting DataFrames
h = @df df histogram(:cluster, ylabel=&quot;nseq&quot;)
p = @df df plot(:cluster, :coverage, linetype=:scatter)
plot(p, h, nc=1, xlim=(0, nclusters(clusters)+1 ), legend=false)</code></pre><p><img src="../msa_clusters_ii.png" alt/>  </p><p>We use the <em>Split-Apply-Combine</em> strategy, though the <code>groupby</code> and <code>combine</code> function of  the <code>DataFrames</code> package, to select the sequence of highest coverage for each cluster.  </p><pre><code class="language-julia hljs">grouped_df = groupby(df, :cluster)

maxcoverage = combine(grouped_df) do cl
    row_index = findmax(cl.coverage)[2]
    cl[row_index, [:seqnum, :seqname, :coverage]]
end

first(maxcoverage, 5)</code></pre><div><div style = "float: left;"><span>5×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">cluster</th><th style = "text-align: left;">seqnum</th><th style = "text-align: left;">seqname</th><th style = "text-align: left;">coverage</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">1</td><td style = "text-align: right;">1</td><td style = "text-align: left;">A0A370X5B3_9GAMM/1736-1853</td><td style = "text-align: right;">0.929204</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">2</td><td style = "text-align: right;">2</td><td style = "text-align: left;">D1AVB4_STRM9/461-568</td><td style = "text-align: right;">0.884956</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">3</td><td style = "text-align: right;">3</td><td style = "text-align: left;">A0A2T5HR93_9PSED/761-875</td><td style = "text-align: right;">0.99115</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">4</td><td style = "text-align: right;">4</td><td style = "text-align: left;">A0A427CBK0_9GAMM/418-540</td><td style = "text-align: right;">0.920354</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: left;">A0A1I1MWW5_9BURK/779-907</td><td style = "text-align: right;">0.734513</td></tr></tbody></table></div><pre><code class="language-julia hljs">p = @df maxcoverage plot(:cluster, :coverage, linetype=:scatter)
h = @df maxcoverage histogram(:cluster, ylabel=&quot;nseq&quot;)
plot(p, h, nc=1, xlim=(0, nclusters(clusters)+1 ), legend=false)</code></pre><p><img src="../msa_clusters_iii.png" alt/>  </p><p>We can easily generate a mask using list comprehension, to select only the representative sequences of the MSA (deleting the rest of the sequences with <code>filtersequences!</code>).  </p><pre><code class="language-julia hljs">cluster_references = Bool[ seqnum in maxcoverage.seqnum for seqnum in 1:nsequences(msa) ]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">811-element Vector{Bool}:
 1
 1
 1
 1
 1
 1
 1
 0
 0
 0
 ⋮
 1
 1
 0
 0
 1
 0
 1
 0
 0</code></pre><pre><code class="language-julia hljs">filtersequences!(msa, cluster_references)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnnotatedMultipleSequenceAlignment with 489 annotations : 465×113 Named Matrix{MIToS.MSA.Residue}
                 Seq ╲ Col │  53   54   55   56   57  …  428  429  430  431  432
───────────────────────────┼────────────────────────────────────────────────────
A0A370X5B3_9GAMM/1736-1853 │   -    -    -    -    -  …    Y    A    Y    R    L
D1AVB4_STRM9/461-568       │   -    -    -    -    -       Y    R    Y    R    L
A0A2T5HR93_9PSED/761-875   │   S    N    L    T    S       Y    Q    Y    T    L
A0A427CBK0_9GAMM/418-540   │   -    -    -    -    -       F    R    Y    R    L
A0A1I1MWW5_9BURK/779-907   │   -    -    -    -    -       Y    E    Y    R    L
C6JIE8_FUSVA/367-481       │   -    I    I    S    N       Y    E    Y    F    L
A0A017H8U7_9FUSO/691-802   │   S    S    V    T    E       Y    E    Y    T    L
A0A371WV37_9RHIZ/683-796   │   -    -    -    -    -       Y    Q    Y    K    L
⋮                              ⋮    ⋮    ⋮    ⋮    ⋮  ⋱    ⋮    ⋮    ⋮    ⋮    ⋮
A0A1N7SRG0_9BURK/2401-2512 │   -    -    V    G    N       Y    T    Y    Q    L
A0A2C6DQK9_9GAMM/347-456   │   -    -    I    A    T       Y    E    Y    Y    L
D1AFP2_SEBTE/555-660       │   -    -    I    R    D       Y    E    Y    N    L
A0A085H9D8_9GAMM/2879-2989 │   -    -    -    -    N       Y    E    Y    F    L
A0A2C6C2K4_9GAMM/553-666   │   -    -    -    -    -       Y    E    Y    D    -
A0A318T6N3_9RHIZ/636-751   │   -    -    -    K    T       Y    V    Y    Q    L
A0A2S8VQP6_9CAUL/182-287   │   -    -    -    -    R       V    R    Y    R    -
A6T0K2_JANMA/343-459       │   -    -    -    -    -  …    Y    A    Y    T    L</code></pre><pre><code class="language-julia hljs">plot(msa)</code></pre><p><img src="../msa_clusters_iv.png" alt/>  </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Example/">« Example</a><a class="docs-footer-nextpage" href="../Information/">Information »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 5 January 2024 16:33">Friday 5 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
