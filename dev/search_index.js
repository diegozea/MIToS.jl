var documenterSearchIndex = {"docs":
[{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"@info \"Scripts docs\"","category":"page"},{"location":"Scripts/#Scripts","page":"Scripts","title":"Scripts","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"MIToS implements several useful scripts to command line execution (without requiring Julia coding). All this scripts are located in the scripts folder of the MIToS directory. You can copy them to your working directory, use the path to their folder or put them in the path (look into the Installation section of this manual).  ","category":"page"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"Pages = [\"Scripts.md\"]\nDepth = 4","category":"page"},{"location":"Scripts/#Buslje09.jl","page":"Scripts","title":"Buslje09.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"Buslje09.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#BLMI.jl","page":"Scripts","title":"BLMI.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"BLMI.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#Conservation.jl","page":"Scripts","title":"Conservation.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"Conservation.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#DownloadPDB.jl","page":"Scripts","title":"DownloadPDB.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"import Pkg\nPkg.add(\"ArgParse\")\nusing MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"DownloadPDB.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#Distances.jl","page":"Scripts","title":"Distances.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"Distances.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#MSADescription.jl","page":"Scripts","title":"MSADescription.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"MSADescription.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#PercentIdentity.jl","page":"Scripts","title":"PercentIdentity.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"PercentIdentity.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#AlignedColumns.jl","page":"Scripts","title":"AlignedColumns.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"using MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"AlignedColumns.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"Scripts/#SplitStockholm.jl","page":"Scripts","title":"SplitStockholm.jl","text":"","category":"section"},{"location":"Scripts/","page":"Scripts","title":"Scripts","text":"import Pkg\nPkg.add(\"ArgParse\")\nPkg.add(\"CodecZlib\")\nPkg.add(\"ProgressMeter\")\nusing MIToS\njulia_path = joinpath(Base.Sys.BINDIR, \"julia\")\nscript_path = joinpath(dirname(pathof(MIToS)), \"..\", \"scripts\", \"SplitStockholm.jl\")\nread(`$julia_path $script_path -h`, String) |> println","category":"page"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"@info \"MSA API docs\"","category":"page"},{"location":"MSA_API/#MSA","page":"MSA","title":"MSA","text":"","category":"section"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"MIToS.MSA","category":"page"},{"location":"MSA_API/#MIToS.MSA","page":"MSA","title":"MIToS.MSA","text":"The MSA module of MIToS has utilities for working with Multiple Sequence Alignments of protein Sequences (MSA).\n\nFeatures\n\nRead and write MSAs in Stockholm, FASTA or Raw format\nHandle MSA annotations\nEdit the MSA, e.g. delete columns or sequences, change sequence order, shuffling...\nKeep track of positions and annotations after modifications on the MSA\nDescribe a MSA, e.g. mean percent identity, sequence coverage, gap percentage...\n\nusing MIToS.MSA\n\n\n\n\n\n","category":"module"},{"location":"MSA_API/#Contents","page":"MSA","title":"Contents","text":"","category":"section"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"Pages = [\"MSA_API.md\"]\nDepth = 2","category":"page"},{"location":"MSA_API/#Types","page":"MSA","title":"Types","text":"","category":"section"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"Modules = [MIToS.MSA]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"MSA_API/#MIToS.MSA.AbstractAlignedObject","page":"MSA","title":"MIToS.MSA.AbstractAlignedObject","text":"MIToS MSA and aligned sequences (aligned objects) are subtypes of AbstractMatrix{Residue}, because MSAs and sequences are stored as Matrix of Residues.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.AbstractAlignedSequence","page":"MSA","title":"MIToS.MSA.AbstractAlignedSequence","text":"A MIToS aligned sequence is an AbstractMatrix{Residue} with only 1 row/sequence.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.AbstractMultipleSequenceAlignment","page":"MSA","title":"MIToS.MSA.AbstractMultipleSequenceAlignment","text":"MSAs are stored as Matrix{Residue}. It's possible to use a NamedResidueMatrix{Array{Residue,2}} as the most simple MSA with sequence identifiers and column names.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.AlignedSequence","page":"MSA","title":"MIToS.MSA.AlignedSequence","text":"An AlignedSequence wraps a NamedResidueMatrix{Array{Residue,2}} with only 1 row/sequence. The NamedArray stores the sequence name and original column numbers as Strings.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.AnnotatedAlignedSequence","page":"MSA","title":"MIToS.MSA.AnnotatedAlignedSequence","text":"This type represent an aligned sequence, similar to AlignedSequence, but It also stores its Annotations.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.AnnotatedMultipleSequenceAlignment","page":"MSA","title":"MIToS.MSA.AnnotatedMultipleSequenceAlignment","text":"This type represent an MSA, similar to MultipleSequenceAlignment, but It also stores Annotations. This annotations are used to store residue coordinates (i.e. mapping to UniProt residue numbers).\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.Annotations","page":"MSA","title":"MIToS.MSA.Annotations","text":"The Annotations type is basically a container for Dicts with the annotations of a multiple sequence alignment. Annotations was designed for storage of annotations of the Stockholm format.\n\nMIToS also uses MSA annotations to keep track of:\n\nModifications of the MSA (MIToS_...) as deletion of sequences or columns.\nPositions numbers in the original MSA file (column mapping: ColMap)\nPosition of the residues in the sequence (sequence mapping: SeqMap)\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.Clusters","page":"MSA","title":"MIToS.MSA.Clusters","text":"Data structure to represent sequence clusters. The sequence data itself is not included.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.GappedAlphabet","page":"MSA","title":"MIToS.MSA.GappedAlphabet","text":"This type defines the usual alphabet of the 20 natural residues and a gap character.\n\njulia> using MIToS.MSA\n\njulia> GappedAlphabet()\nGappedAlphabet of length 21. Residues : res\"ARNDCQEGHILKMFPSTWYV-\"\n\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.MultipleSequenceAlignment","page":"MSA","title":"MIToS.MSA.MultipleSequenceAlignment","text":"This MSA type include a NamedArray wrapping a Matrix of Residues. The use of NamedArray allows to store sequence names and original column numbers as Strings, and fast indexing using them.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.NoClustering","page":"MSA","title":"MIToS.MSA.NoClustering","text":"Use NoClustering() to avoid the use of clustering where a Clusters type is needed.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.ReducedAlphabet","page":"MSA","title":"MIToS.MSA.ReducedAlphabet","text":"ReducedAlphabet allows the construction of reduced residue alphabets, where residues inside parenthesis belong to the same group.\n\njulia> using MIToS.MSA\n\njulia> ab = ReducedAlphabet(\"(AILMV)(RHK)(NQST)(DE)(FWY)CGP\")\nReducedAlphabet of length 8 : \"(AILMV)(RHK)(NQST)(DE)(FWY)CGP\"\n\njulia> ab[Residue('K')]\n2\n\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.Residue","page":"MSA","title":"MIToS.MSA.Residue","text":"Most of the MIToS design is created around the Residue bitstype. It has representations for the 20 natural amino acids, a value representing insertions and deletions (GAP, '-') and one representing unknown, ambiguous and non standard residues (XAA, 'X'). Each Residue is encoded as an integer number, with the same bit representation and size than a Int. This allows fast indexing operation of probability or frequency matrices.\n\nResidue creation and conversion\n\nCreation and conversion of Residues should be treated carefully. Residue is encoded as a 32 or 64 bits type similar to Int, to get fast indexing using Int(x::Residue). Int simply calls reinterpret without checking if the residue is valid. Valid residues have integer values in the closed interval [1,22]. convert from Int  and Char always returns valid residues, however it's possible to find invalid residues (they are shown using the character '�') after the creation of uninitialized Residue arrays (i.e. using Array). You can use zeros, ones or rand to get initialized Residue arrays with valid residues. Conversions to and from Chars changes the bit representation and allows the use of the usual character representation of residues and amino acids. This conversions are used in IO operations and always return valid residues. In conversions from Char, lowercase letters, '*', '-' and '.' are translated to GAP, letters representing the 20 natural amino (ARNDCQEGHILKMFPSTWYV) acids are translated to their corresponding Residue and any other character is translated to XAA. Since lowercase letters and dots are translated to gaps, Pfam MSA insert columns are converted to columns full of gaps.\n\njulia> using MIToS.MSA\n\njulia> alanine = Residue('A')\nA\n\njulia> Char(alanine)\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\njulia> for residue in res\"ARNDCQEGHILKMFPSTWYV-X\"\n           println(residue, \" \", Int(residue))\n       end\nA 1\nR 2\nN 3\nD 4\nC 5\nQ 6\nE 7\nG 8\nH 9\nI 10\nL 11\nK 12\nM 13\nF 14\nP 15\nS 16\nT 17\nW 18\nY 19\nV 20\n- 21\nX 22\n\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.ResidueAlphabet","page":"MSA","title":"MIToS.MSA.ResidueAlphabet","text":"Abstract type to define residue alphabet types.\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#MIToS.MSA.UngappedAlphabet","page":"MSA","title":"MIToS.MSA.UngappedAlphabet","text":"This type defines the usual alphabet of the 20 natural residues, without the gap character.\n\njulia> using MIToS.MSA\n\njulia> UngappedAlphabet()\nUngappedAlphabet of length 20. Residues : res\"ARNDCQEGHILKMFPSTWYV\"\n\n\n\n\n\n\n","category":"type"},{"location":"MSA_API/#Constants","page":"MSA","title":"Constants","text":"","category":"section"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"Modules = [MIToS.MSA]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"MSA_API/#MIToS.MSA.GAP","page":"MSA","title":"MIToS.MSA.GAP","text":"GAP is the Residue representation on MIToS for gaps ('-', insertions and deletions). Lowercase residue characters, dots and '*' are encoded as GAP in conversion from Strings and Chars. This Residue constant is encoded as Residue(21).\n\n\n\n\n\n","category":"constant"},{"location":"MSA_API/#MIToS.MSA.XAA","page":"MSA","title":"MIToS.MSA.XAA","text":"XAA is the Residue representation for unknown, ambiguous and non standard residues. This Residue constant is encoded as Residue(22).\n\n\n\n\n\n","category":"constant"},{"location":"MSA_API/#Macros","page":"MSA","title":"Macros","text":"","category":"section"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"Modules = [MIToS.MSA]\nPrivate = false\nOrder   = [:macro]","category":"page"},{"location":"MSA_API/#MIToS.MSA.@res_str-Tuple{Any}","page":"MSA","title":"MIToS.MSA.@res_str","text":"The MIToS macro @res_str takes a string and returns a Vector of Residues (sequence).\n\njulia> using MIToS.MSA\n\njulia> res\"MIToS\"\n5-element Vector{Residue}:\n M\n I\n T\n -\n S\n\n\n\n\n\n\n","category":"macro"},{"location":"MSA_API/#Methods-and-functions","page":"MSA","title":"Methods and functions","text":"","category":"section"},{"location":"MSA_API/","page":"MSA","title":"MSA","text":"Modules = [MIToS.MSA]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"MSA_API/#Base.isvalid-Tuple{Type{MIToS.MSA.Residue}, MIToS.MSA.Residue}","page":"MSA","title":"Base.isvalid","text":"isvalid(res::Residue)\n\nIt returns true if the encoded integer is in the closed interval [1,22].\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#Base.names-Tuple{MIToS.MSA.ReducedAlphabet}","page":"MSA","title":"Base.names","text":"It returns the name of each group. The name is a string with the one letter code of each residue that belong to the group.\n\njulia> using MIToS.MSA\n\njulia> ab = ReducedAlphabet(\"(AILMV)(RHK)(NQST)(DE)(FWY)CGP\")\nReducedAlphabet of length 8 : \"(AILMV)(RHK)(NQST)(DE)(FWY)CGP\"\n\njulia> names(ab)\n8-element Vector{String}:\n \"AILMV\"\n \"RHK\"\n \"NQST\"\n \"DE\"\n \"FWY\"\n \"C\"\n \"G\"\n \"P\"\n\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#Base.parse","page":"MSA","title":"Base.parse","text":"parse(io, format[, output; generatemapping, useidcoordinates, deletefullgaps])\n\nThe keyword argument generatemapping (false by default) indicates if the mapping of the sequences (\"SeqMap\") and columns (\"ColMap\") and the number of columns in the original MSA (\"NCol\") should be generated and saved in the annotations. If useidcoordinates is true (default: false) the sequence IDs of the form \"ID/start-end\" are parsed and used for determining the start and end positions when the mappings are generated. deletefullgaps (true by default) indicates if columns 100% gaps (generally inserts from a HMM) must be removed from the MSA.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#Base.rand-Tuple{Random.AbstractRNG, Random.SamplerType{MIToS.MSA.Residue}}","page":"MSA","title":"Base.rand","text":"It chooses from the 20 natural residues (it doesn't generate gaps).\n\njulia> using MIToS.MSA\n\njulia> using Random\n\njulia> Random.seed!(1); # Reseed the random number generator.\n\njulia> rand(Residue)\nP\n\njulia> rand(Residue, 4, 4)\n4×4 Matrix{Residue}:\n N  N  T  D\n G  Y  L  I\n R  V  F  L\n P  C  K  L\n\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#Clustering.assignments-Tuple{MIToS.MSA.Clusters}","page":"MSA","title":"Clustering.assignments","text":"Get a vector of assignments, where the i value is the index/number of the cluster to which the i-th sequence is assigned.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#Clustering.nclusters-Tuple{MIToS.MSA.Clusters}","page":"MSA","title":"Clustering.nclusters","text":"Get the number of clusters in a Clusters object.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.adjustreference","page":"MSA","title":"MIToS.MSA.adjustreference","text":"Creates a new matrix of residues. This function deletes positions/columns of the MSA with gaps in the reference (first) sequence.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.adjustreference!","page":"MSA","title":"MIToS.MSA.adjustreference!","text":"It removes positions/columns of the MSA with gaps in the reference (first) sequence.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.annotate_modification!-Tuple{MIToS.MSA.Annotations, String}","page":"MSA","title":"MIToS.MSA.annotate_modification!","text":"Annotates on file annotations the modifications realized by MIToS on the MSA. It always returns true, so It can be used in a boolean context.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.annotations-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment}","page":"MSA","title":"MIToS.MSA.annotations","text":"annotations returns the Annotations of an MSA or aligned sequence.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.columngapfraction-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.columngapfraction","text":"Fraction of gaps per column/position on the MSA\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.columnnames-Union{Tuple{NamedArrays.NamedMatrix{MIToS.MSA.Residue, AT, Tuple{OrderedCollections.OrderedDict{String, Int64}, OrderedCollections.OrderedDict{String, Int64}}}}, Tuple{AT}} where AT","page":"MSA","title":"MIToS.MSA.columnnames","text":"columnnames(msa)\n\nIt returns a Vector{String} with the sequence names/identifiers. If the msa is a Matrix{Residue} this function returns the actual column numbers as strings. Otherwise it returns the column number of the original MSA through the wrapped NamedArray column names.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.columnpairsmatrix-Union{Tuple{diagonal}, Tuple{T}, Tuple{AbstractMatrix{MIToS.MSA.Residue}, Type{T}, Type{Val{diagonal}}, T}} where {T, diagonal}","page":"MSA","title":"MIToS.MSA.columnpairsmatrix","text":"Initialize an empty PairwiseListMatrix for a pairwise measure in sequence pairs. It uses the sequence names if they are available, otherwise it uses the actual sequence numbers. You can use the positional argument to indicate the number Type (default: Float64), if the PairwiseListMatrix should store the diagonal values on the list (default: false) and a default value for the diagonal (default: NaN).\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.coverage-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.coverage","text":"Coverage of the sequences with respect of the number of positions on the MSA\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.delete_annotated_modifications!-Tuple{MIToS.MSA.Annotations}","page":"MSA","title":"MIToS.MSA.delete_annotated_modifications!","text":"Deletes all the MIToS annotated modifications\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.deletefullgapcolumns!","page":"MSA","title":"MIToS.MSA.deletefullgapcolumns!","text":"Deletes columns with 100% gaps, this columns are generated by inserts.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.filtercolumns!","page":"MSA","title":"MIToS.MSA.filtercolumns!","text":"filtercolumns!(msa, mask[, annotate::Bool=true])\n\nIt allows to filter MSA or aligned sequence columns/positions using a AbstractVector{Bool} mask. Annotations are updated if annotate is true (default).\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.filtercolumns!-Tuple{MIToS.MSA.Annotations, Any}","page":"MSA","title":"MIToS.MSA.filtercolumns!","text":"filtercolumns!(data::Annotations, mask)\n\nIt is useful for deleting column annotations (creating a subset in place).\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.filtercolumns-Tuple{AbstractMatrix{MIToS.MSA.Residue}, Any}","page":"MSA","title":"MIToS.MSA.filtercolumns","text":"It's similar to filtercolumns! but for an AbstractMatrix{Residue}\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.filtersequences!","page":"MSA","title":"MIToS.MSA.filtersequences!","text":"filtersequences!(msa, mask[, annotate::Bool=true])\n\nIt allows to filter msa sequences using a AbstractVector{Bool} mask (It removes sequences with false values). AnnotatedMultipleSequenceAlignment annotations are updated if annotate is true (default).\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.filtersequences!-Tuple{MIToS.MSA.Annotations, Vector{String}, AbstractVector{Bool}}","page":"MSA","title":"MIToS.MSA.filtersequences!","text":"filtersequences!(data::Annotations, ids::Vector{String}, mask::AbstractArray{Bool,1})\n\nIt is useful for deleting sequence annotations. ids should be a list of the sequence names and mask should be a logical vector.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.filtersequences-Tuple{AbstractMatrix{MIToS.MSA.Residue}, Any}","page":"MSA","title":"MIToS.MSA.filtersequences","text":"It's similar to filtersequences! but for an AbstractMatrix{Residue}\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.gapfraction-Tuple{AbstractArray{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.gapfraction","text":"It calculates the fraction of gaps on the Array (alignment, sequence, column, etc.). This function can take an extra dimension argument for calculation of the gap fraction over the given dimension.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.gapstrip!","page":"MSA","title":"MIToS.MSA.gapstrip!","text":"This functions deletes/filters sequences and columns/positions on the MSA on the following order:\n\nRemoves all the columns/position on the MSA with gaps on the reference (first) sequence.\nRemoves all the sequences with a coverage with respect to the number of\n\ncolumns/positions on the MSA less than a coveragelimit (default to 0.75: sequences with 25% of gaps).\n\nRemoves all the columns/position on the MSA with more than a gaplimit\n\n(default to 0.5: 50% of gaps).\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.gapstrip-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.gapstrip","text":"Creates a new matrix of Residues (MSA) with deleted sequences and columns/positions. The MSA is edited in the following way:\n\nRemoves all the columns/position on the MSA with gaps on the reference (first) sequence\nRemoves all the sequences with a coverage with respect to the number of\n\ncolumns/positions on the MSA less than a coveragelimit  (default to 0.75: sequences with 25% of gaps)\n\nRemoves all the columns/position on the MSA with more than a gaplimit\n\n(default to 0.5: 50% of gaps)\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.getannotcolumn","page":"MSA","title":"MIToS.MSA.getannotcolumn","text":"getannotcolumn(ann[, feature[,default]])\n\nIt returns per column annotation for feature\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.getannotfile","page":"MSA","title":"MIToS.MSA.getannotfile","text":"getannotfile(ann[, feature[,default]])\n\nIt returns per file annotation for feature\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.getannotresidue","page":"MSA","title":"MIToS.MSA.getannotresidue","text":"getannotresidue(ann[, seqname, feature[,default]])\n\nIt returns per residue annotation for (seqname, feature)\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.getannotsequence","page":"MSA","title":"MIToS.MSA.getannotsequence","text":"getannotsequence(ann[, seqname, feature[,default]])\n\nIt returns per sequence annotation for (seqname, feature)\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.getcolumnmapping-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment}","page":"MSA","title":"MIToS.MSA.getcolumnmapping","text":"It returns a Vector{Int} with the original column number of each column on the actual MSA. The mapping is annotated in the \"ColMap\" file annotation of an AnnotatedMultipleSequenceAlignment or in the column names of an NamedArray or MultipleSequenceAlignment.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.gethcatmapping-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment}","page":"MSA","title":"MIToS.MSA.gethcatmapping","text":"It returns a vector of numbers from 1 to N for each column that indicates the source MSA. The mapping is annotated in the \"HCat\" file annotation of an AnnotatedMultipleSequenceAlignment or in the column names of an NamedArray or MultipleSequenceAlignment.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.getnamedict-Tuple{MIToS.MSA.ReducedAlphabet}","page":"MSA","title":"MIToS.MSA.getnamedict","text":"It takes a ResidueAlphabet and returns a dictionary from group name to group position.\n\njulia> using MIToS.MSA\n\njulia> ab = ReducedAlphabet(\"(AILMV)(RHK)(NQST)(DE)(FWY)CGP\")\nReducedAlphabet of length 8 : \"(AILMV)(RHK)(NQST)(DE)(FWY)CGP\"\n\njulia> getnamedict(ab)\nOrderedCollections.OrderedDict{String,Int64} with 8 entries:\n  \"AILMV\" => 1\n  \"RHK\"   => 2\n  \"NQST\"  => 3\n  \"DE\"    => 4\n  \"FWY\"   => 5\n  \"C\"     => 6\n  \"G\"     => 7\n  \"P\"     => 8\n\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.getresidues-Tuple{Matrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.getresidues","text":"getresidues allows you to access the residues stored inside an MSA or aligned sequence as a Matrix{Residue} without annotations nor column/row names.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.getresiduesequences-Tuple{Matrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.getresiduesequences","text":"getresiduesequences returns a Vector{Vector{Residue}} with all the MSA sequences without annotations nor column/sequence names.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.getsequence","page":"MSA","title":"MIToS.MSA.getsequence","text":"getsequence takes an MSA and a sequence number or identifier and returns an aligned sequence object. If the MSA is an AnnotatedMultipleSequenceAlignment, it returns an AnnotatedAlignedSequence with the sequence annotations. From a MultipleSequenceAlignment, It returns an AlignedSequence object. If an Annotations object and a sequence identifier are used, this function returns the annotations related to the sequence.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.getsequencemapping-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment, String}","page":"MSA","title":"MIToS.MSA.getsequencemapping","text":"It returns the sequence coordinates as a Vector{Int} for an MSA sequence. That vector has one element for each MSA column. If the number if 0 in the mapping, there is a gap in that column for that sequence.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.getweight-Tuple{MIToS.MSA.NoClustering, Int64}","page":"MSA","title":"MIToS.MSA.getweight","text":"getweight(c[, i::Int])\n\nThis function returns the weight of the sequence number i. getweight should be defined for any type used for count!/count in order to use his weigths. If i isn't used, this function returns a vector with the weight of each sequence.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.hobohmI-Tuple{AbstractMatrix{MIToS.MSA.Residue}, Any}","page":"MSA","title":"MIToS.MSA.hobohmI","text":"Sequence clustering using the Hobohm I method from Hobohm et. al. 1992.\n\nHobohm, Uwe, et al. \"Selection of representative protein data sets.\" Protein Science 1.3 (1992): 409-417.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.meanpercentidentity","page":"MSA","title":"MIToS.MSA.meanpercentidentity","text":"Returns the mean of the percent identity between the sequences of a MSA. If the MSA has 300 sequences or less, the mean is exact. If the MSA has more sequences and the exact keyword is false (defualt), 44850 random pairs of sequences are used for the estimation. The number of samples can be changed using the second argument. Use exact=true to perform all the pairwise comparison (the calculation could be slow).\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.namedmatrix-Tuple{MIToS.MSA.AbstractAlignedObject}","page":"MSA","title":"MIToS.MSA.namedmatrix","text":"namedmatrix returns the NamedResidueMatrix{Array{Residue,2}} stored in an MSA or aligned sequence.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.ncolumns-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.ncolumns","text":"ncolumns returns the number of MSA columns or positions.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.ncolumns-Tuple{MIToS.MSA.Annotations}","page":"MSA","title":"MIToS.MSA.ncolumns","text":"ncolumns(ann::Annotations) returns the number of columns/residues with annotations. This function returns -1 if there is not annotations per column/residue.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.nsequences-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.nsequences","text":"nsequences returns the number of sequences on the MSA.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.percentidentity-Tuple{Any, Any, Any}","page":"MSA","title":"MIToS.MSA.percentidentity","text":"percentidentity(seq1, seq2, threshold)\n\nComputes quickly if two aligned sequences have a identity value greater than a given threshold value. Returns a boolean value. Positions with gaps in both sequences doesn't count to the length of the sequences. Positions with a XAA in at least one sequence aren't counted.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.percentidentity-Tuple{Any, Any}","page":"MSA","title":"MIToS.MSA.percentidentity","text":"percentidentity(seq1, seq2)\n\nCalculates the fraction of identities between two aligned sequences. The identity value is calculated as the number of identical characters in the i-th position of both sequences divided by the length of both sequences. Positions with gaps in both sequences doesn't count to the length of the sequences. Positions with a XAA in at least one sequence aren't counted.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.percentidentity-Union{Tuple{AbstractMatrix{MIToS.MSA.Residue}}, Tuple{T}, Tuple{AbstractMatrix{MIToS.MSA.Residue}, Type{T}}} where T","page":"MSA","title":"MIToS.MSA.percentidentity","text":"percentidentity(msa[, out::Type=Float64])\n\nCalculates the identity between all the sequences on a MSA. You can indicate the output element type with the last optional parameter (Float64 by default). For a MSA with a lot of sequences, you can use Float32 or Flot16 in order to avoid the OutOfMemoryError().\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.percentsimilarity","page":"MSA","title":"MIToS.MSA.percentsimilarity","text":"Calculates the similarity percent between two aligned sequences. The 100% is the length of the aligned sequences minus the number of columns with gaps in both sequences and the number of columns with at least one residue outside the alphabet. So, columns with residues outside the alphabet (other than the specially treated GAP) aren't counted to the protein length. Two residues are considered similar if they below to the same group in a ReducedAlphabet. The alphabet (third positional argument) by default is:\n\nReducedAlphabet(\"(AILMV)(NQST)(RHK)(DE)(FWY)CGP\")\n\nThe first group is composed of the non polar residues (AILMV), the second group is composed of polar residues, the third group are positive residues, the fourth group are negative residues, the fifth group is composed by the aromatic residues (FWY). C, G and P are considered unique residues.\n\nOther residue groups/alphabets:\n\nSMS (Sequence Manipulation Suite) Ident and Sim:\n\nReducedAlphabet(\"(GAVLI)(FYW)(ST)(KRH)(DENQ)P(CM)\")\n\nStothard P (2000) The Sequence Manipulation Suite: JavaScript programs for analyzing and formatting protein and DNA sequences. Biotechniques 28:1102-1104.\n\nBio3D 2.2 seqidentity:\n\nReducedAlphabet(\"(GA)(MVLI)(FYW)(ST)(KRH)(DE)(NQ)PC\")\n\nGrant, B.J. et al. (2006) Bioinformatics 22, 2695–2696.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.percentsimilarity-Tuple{AbstractMatrix{MIToS.MSA.Residue}, Vararg{Any}}","page":"MSA","title":"MIToS.MSA.percentsimilarity","text":"Calculates the similarity percent between all the sequences on a MSA. You can indicate the output element type with the out keyword argument (Float64 by default). For an MSA with a lot of sequences, you can use out=Float32 or out=Flot16 in order to avoid the OutOfMemoryError().\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.printmodifications-Tuple{MIToS.MSA.Annotations}","page":"MSA","title":"MIToS.MSA.printmodifications","text":"Prints MIToS annotated modifications\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.residue2three-Tuple{MIToS.MSA.Residue}","page":"MSA","title":"MIToS.MSA.residue2three","text":"This function returns the three letter name of the Residue.\n\njulia> using MIToS.MSA\n\njulia> residue2three(Residue('G'))\n\"GLY\"\n\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.residuefraction-Tuple{AbstractArray{MIToS.MSA.Residue}}","page":"MSA","title":"MIToS.MSA.residuefraction","text":"It calculates the fraction of residues (no gaps) on the Array (alignment, sequence, column, etc.). This function can take an extra dimension argument for calculation of the residue fraction over the given dimension\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.sequencenames-Union{Tuple{NamedArrays.NamedMatrix{MIToS.MSA.Residue, AT, Tuple{OrderedCollections.OrderedDict{String, Int64}, OrderedCollections.OrderedDict{String, Int64}}}}, Tuple{AT}} where AT<:AbstractArray","page":"MSA","title":"MIToS.MSA.sequencenames","text":"sequencenames(msa)\n\nIt returns a Vector{String} with the sequence names/identifiers.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.sequencepairsmatrix-Union{Tuple{diagonal}, Tuple{T}, Tuple{AbstractMatrix{MIToS.MSA.Residue}, Type{T}, Type{Val{diagonal}}, T}} where {T, diagonal}","page":"MSA","title":"MIToS.MSA.sequencepairsmatrix","text":"Initialize an empty PairwiseListMatrix for a pairwise measure in column pairs. It uses the column mapping (column number in the input MSA file) if it’s available, otherwise it uses the actual column numbers. You can use the positional argument to indicate the number Type (default: Float64), if the PairwiseListMatrix should store the diagonal values on the list (default: false) and a default value for the diagonal (default: NaN).\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.setannotcolumn!","page":"MSA","title":"MIToS.MSA.setannotcolumn!","text":"setannotcolumn!(ann, feature, annotation)\n\nIt stores per column annotation (1 char per column) for feature\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.setannotfile!","page":"MSA","title":"MIToS.MSA.setannotfile!","text":"setannotfile!(ann, feature, annotation)\n\nIt stores per file annotation for feature\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.setannotresidue!","page":"MSA","title":"MIToS.MSA.setannotresidue!","text":"setannotresidue!(ann, seqname, feature, annotation)\n\nIt stores per residue annotation (1 char per residue) for (seqname, feature)\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.setannotsequence!","page":"MSA","title":"MIToS.MSA.setannotsequence!","text":"setannotsequence!(ann, seqname, feature, annotation)\n\nIt stores per sequence annotation for (seqname, feature)\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.setreference!","page":"MSA","title":"MIToS.MSA.setreference!","text":"It puts the sequence i (name or position) as reference (first sequence) of the MSA. This function swaps the sequences 1 and i.\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#MIToS.MSA.stringsequence-Tuple{AbstractMatrix{MIToS.MSA.Residue}, Any}","page":"MSA","title":"MIToS.MSA.stringsequence","text":"stringsequence(seq)\nstringsequence(msa, i::Int)\nstringsequence(msa, id::String)\n\nIt returns the selected sequence as a String.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.swapsequences!-Tuple{Matrix{MIToS.MSA.Residue}, Int64, Int64}","page":"MSA","title":"MIToS.MSA.swapsequences!","text":"It swaps the sequences on the positions i and j of an MSA. Also it's possible to swap sequences using their sequence names/identifiers when the MSA object as names.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#MIToS.MSA.three2residue-Tuple{String}","page":"MSA","title":"MIToS.MSA.three2residue","text":"It takes a three letter residue name and returns the corresponding Residue. If the name isn't in the MIToS dictionary, a XAA is returned.\n\njulia> using MIToS.MSA\n\njulia> three2residue(\"ALA\")\nA\n\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#Random.shuffle!","page":"MSA","title":"Random.shuffle!","text":"It's like Random.shuffle. When a Matrix{Residue} is used, you can indicate if the gaps should remain their positions using the last boolean argument. The previous argument should be the dimension to shuffle, 1 for shuffling residues in a sequence (row) or 2 for shuffling residues in a column.\n\njulia> using MIToS.MSA\n\njulia> using Random\n\njulia> msa = hcat(res\"RRE\",res\"DDK\", res\"G--\")\n3×3 Matrix{Residue}:\n R  D  G\n R  D  -\n E  K  -\n\njulia> Random.seed!(42);\n\njulia> shuffle(msa, 1, true)\n3×3 Matrix{Residue}:\n G  D  R\n D  R  -\n E  K  -\n\njulia> Random.seed!(42);\n\njulia> shuffle(msa, 1, false)\n3×3 Matrix{Residue}:\n G  D  R\n D  -  R\n -  E  K\n\n\n\n\n\n\n","category":"function"},{"location":"MSA_API/#Random.shuffle-Tuple{Random.AbstractRNG, Matrix{MIToS.MSA.Residue}, Vararg{Any}}","page":"MSA","title":"Random.shuffle","text":"It's like shuffle but in-place. When a Matrix{Residue} or a AbstractAlignedObject (sequence or MSA) is used, you can indicate if the gaps should remain their positions using the last boolean argument.\n\n\n\n\n\n","category":"method"},{"location":"MSA_API/#StatsBase.counts-Tuple{MIToS.MSA.Clusters}","page":"MSA","title":"StatsBase.counts","text":"Get sample counts of clusters as a Vector. Each k value is the number of samples assigned to the k-th cluster.\n\n\n\n\n\n","category":"method"},{"location":"Information/","page":"Information","title":"Information","text":"CurrentModule = MIToS.Information","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"@info \"Information docs\"","category":"page"},{"location":"Information/#Module-Information","page":"Information","title":"Information","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"The Information module of MIToS defines types and functions useful to calculate information measures (e.g. Mutual Information (MI) and Entropy) over a Multiple Sequence Alignment (MSA). This module was designed to count Residues (defined in the MSA module) in special contingency tables (as fast as possible) and to derive probabilities from these counts. Also, includes methods for applying corrections to those tables, e.g. pseudocounts and pseudo frequencies. Finally, Information allows to use these probabilities and counts to estimate information measures and other frequency based values.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information # to load the Information module","category":"page"},{"location":"Information/#Features","page":"Information","title":"Features","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"Estimate multi dimensional frequencies and probability tables from sequences, MSAs, etc...\nCorrection for small number of observations\nCorrection for data redundancy on a MSA\nEstimate information measures\nCalculate corrected mutual information between residues  ","category":"page"},{"location":"Information/#Contents","page":"Information","title":"Contents","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"Pages = [\"Information.md\"]\nDepth = 4","category":"page"},{"location":"Information/#Counting-residues","page":"Information","title":"Counting residues","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"MIToS Information module defines a multidimensional ContingencyTable type and two types wrapping it, Counts and Probabilities, to store occurrences or probabilities. The ContingencyTable type stores the contingency matrix, its marginal values and total. These types are parametric, taking three ordered parameters:","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"T : The type used for storing the counts or probabilities, e.g. Float64. It's","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"possible to use BigFloat if more precision it's needed.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"N : It's the dimension of the table and should be an Int.\nA : This should be a type, subtype of ResidueAlphabet, i.e.: UngappedAlphabet,","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"GappedAlphabet or ReducedAlphabet.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"note: Note\nContingencyTable can be used for storing probabilities or counts. The wrapper types Probabilities and Counts are mainly intended to dispatch in methods that need to know if the matrix has probabilities or counts, e.g. entropy. In general, the use of ContingencyTable is recommended over the use of Probabilities and Counts.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"In this way, a matrix for storing pairwise probabilities of residues (without gaps) can be initialized using:  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information\n\nPij = ContingencyTable(Float64, Val{2}, UngappedAlphabet())","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"[High level interface] It is possible to use the functions count and probabilities to easily calculate the frequencies of sequences or columns of a MSA, where the number of sequences/columns determine the dimension of the resulting table.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information\nusing MIToS.MSA # to use res\"...\" to create Vector{Residue}\n\ncolumn_i = res\"AARANHDDRDC-\"\ncolumn_j = res\"-ARRNHADRAVY\"\n#   Nij[R,R] =   1     1   = 2\n\nNij = count(column_i, column_j)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"You can use sum to get the stored total:  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"sum(Nij) # There are 12 Residues, but 2 are gaps","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Contingency tables can be indexed using Int or Residues:  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Nij[2, 2] # Use Int to index the table","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Nij[Residue('R'), Residue('R')] # Use Residue to index the table","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"warning: Warning\nThe number makes reference to the specific index in the table e.g [2,2] references the second row and the second column. The use of the number used to encode the residue to index the table is dangerous. The equivalent index number of a residue depends on the used alphabet and Int(Residue('X')) will be always out of bounds.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Indexing with Residues works as expected. It uses the alphabet of the contingency table to find the index of the Residue.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information\nusing MIToS.MSA\n\nalphabet = ReducedAlphabet(\"(AILMV)(NQST)(RHK)(DE)(FWY)CGP\")\n\ncolumn_i = res\"AARANHDDRDC-\"\ncolumn_j = res\"-ARRNHADRAVY\"\n#   Fij[R,R] =   1  1  1   = 3 # RHK\n\nFij = count(column_i, column_j, alphabet=alphabet)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Fij[Residue('R'), Residue('R')] # Use Residue to index the table","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"The function getcontingencytable allows to access the wrapped ContingencyTable in a Counts object. You can use it, in combination with normalize to get a contingency table of probabilities. The result can be wrapped inside a Probabilities object:  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Probabilities(normalize(getcontingencytable(Fij)))","category":"page"},{"location":"Information/#Example:-Plotting-the-probabilities-of-each-residue-in-a-sequence","page":"Information","title":"Example: Plotting the probabilities of each residue in a sequence","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"Similar to the count function, the probabilities function can take at least one sequence (vector of residues) and returns the probabilities of each residue. Optionally, the keyword argument alphabet could be used to count some residues in the same cell of the table.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"probabilities(res\"AARANHDDRDC\", alphabet=alphabet)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Here, we are going to use the probabilities function to get the residue probabilities of a particular sequence from UniProt.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"use the getsequence function, from the MSA module, to get the sequence from a FASTA downloaded from UniProt.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information # to use the probabilities function\nusing MIToS.MSA # to use getsequence on the one sequence FASTA (canonical) from UniProt\nseq = read(\"http://www.uniprot.org/uniprot/P29374.fasta\", FASTA) # Small hack: read the single sequence as a MSA\nprobabilities(seq[1,:]) # Select the single sequence and calculate the probabilities","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"note: Note\nIn the previous example, using getsequence(seq,1) instead of seq[1,:] will return the sequence as a matrix with a single column to keep information for both dimensions. To use probabilities (or count) you can make use of the Julia's vec function to transform the matrix to a vector, e.g.: probabilities(vec(getsequence(seq,1))).","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"@info \"Information: Plots\"\nusing Plots\ngr(size=(600,300))\nusing MIToS.Information # to use the probabilities function\nusing MIToS.MSA # to use getsequence on the one sequence FASTA (canonical) from UniProt\nseq = read(\"http://www.uniprot.org/uniprot/P29374.fasta\", FASTA) # Small hack: read the single sequence as a MSA\nfrequencies = probabilities(seq[1,:]) # Select the single sequence and calculate the probabilities","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using Plots # We choose Plots because it's intuitive, concise and backend independent\ngr(size=(600,300))","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"You can plot together with the probabilities of each residue in a given sequence, the probabilities of each residue estimated with the BLOSUM62 substitution matrix. That matrix is exported as a constant by the Information module as BLOSUM62_Pi.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"bar(\n    1:20,\n    [ frequencies  BLOSUM62_Pi ],\n    lab = [ \"Sequence\"  \"BLOSUM62\"   ],\n    alpha=0.5\n    )\npng(\"inf_plotfreq.png\") # hide\nnothing # hide","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"(Image: )  ","category":"page"},{"location":"Information/#Low-count-corrections","page":"Information","title":"Low count corrections","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"Low number of observations can lead to sparse contingency tables, that lead to wrong probability estimations. It is shown in Buslje et. al. 2009(Image: ) that low-count corrections, can lead to improvements in the contact prediction capabilities of the Mutual Information. The Information module has available two low-count corrections:  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Additive Smoothing(Image: ); the constant value pseudocount described in Buslje et. al. 2009(Image: ).  \nBLOSUM62 based pseudo frequencies of residues pairs, similar to Altschul et. al. 1997(Image: ).  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.MSA\n\nmsa = read(\"http://pfam.xfam.org/family/PF09776/alignment/full\", Stockholm)\n\nfiltercolumns!(msa, columngapfraction(msa) .< 0.5) # delete columns with 50% gaps or more\n\ncolumn_i = msa[:,1]\ncolumn_j = msa[:,2]","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"If you have a preallocated ContingencyTable you can use count! to fill it, this prevent to create a new table as count do. However, you should note that count! adds the new counts to the pre existing values, so in this case, we want to start with a table initialized with zeros.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information\n\nconst alphabet = ReducedAlphabet(\"(AILMV)(NQST)(RHK)(DE)(FWY)CGP\")\n\nNij = ContingencyTable(Float64, Val{2}, alphabet)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"#      table  weights         pseudocount      sequences...\ncount!(Nij,   NoClustering(), NoPseudocount(), column_i, column_j)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"note: Note\nYou can use NoClustering() in places where clustering weights are required to not use weights. Also, NoPseudocount() in places where pseudocount values are required to not use pseudocounts.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"In cases like the above, where there are few observations, it is possible to apply a constant pseudocount to the counting table.  This module defines the type AdditiveSmoothing and the correspond fill! and  apply_pseudocount! methods to efficiently add or fill with a constant value each element of the table.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"apply_pseudocount!(Nij, AdditiveSmoothing(1.0))","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"[High level interface.] The count function has a pseudocounts keyword argument that can take a AdditiveSmoothing value to easily calculate occurrences with pseudocounts. Also the alphabet keyword argument can be used to chage the default alphabet (i.e. )","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"count(column_i, column_j, pseudocounts=AdditiveSmoothing(1.0), alphabet=alphabet)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"To use the conditional probability matrix BLOSUM62_Pij in the calculation of pseudo frequencies G for the pair of residues a, b, it should be calculated first the real frequencies/probabilities p_ab. The observed probabilities are then used to estimate the pseudo frequencies.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"G_ab = sum_cd  p_cd cdot BLOSUM62( a  c ) cdot BLOSUM62( b  d )","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Finally, the probability P of each pair of residues a, b between the columns i, j is the weighted mean between the observed frequency p and BLOSUM62-based pseudo frequency G, where α is generally the number of clusters or the number of sequences of the MSA and β is an empiric weight value. β was determined to be close to 8.512.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"P_ab = fracalpha cdot p_ab + beta cdot G_ab alpha + beta","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"This could be easily achieved using the pseudofrequencies keyword argument of the probabilities function. That argument can take a BLOSUM_Pseudofrequencies object that is created with α and β as first and second argument, respectively.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Pij = probabilities(column_i, column_j, pseudofrequencies=BLOSUM_Pseudofrequencies(nsequences(msa), 8.512))","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"You can also use apply_pseudofrequencies! in a previously filled probability contingency table. i.e. apply_pseudofrequencies!(Pij, BLOSUM_Pseudofrequencies(α, β))","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"warning: Warning\nBLOSUM_Pseudofrequencies can be only be applied in normalized/probability tables with UngappedAlphabet.  ","category":"page"},{"location":"Information/#Correction-for-data-redundancy-in-a-MSA","page":"Information","title":"Correction for data redundancy in a MSA","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"A simple way to reduce redundancy in a MSA without losing sequences, is clusterization and sequence weighting. The weight of each sequence should be 1/N, where N is the number of sequences in its cluster. The Clusters type of the MSA module stores the weights. This vector of weights can be extracted (with the getweight function) and used by the count and probabilities functions with the keyword argument weights. Also it's possible to use the Clusters as second argument of the function count!.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"clusters = hobohmI(msa, 62) # from MIToS.MSA","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"count(msa[:,1], msa[:,2], weights=clusters)","category":"page"},{"location":"Information/#Estimating-information-measures-on-an-MSA","page":"Information","title":"Estimating information measures on an MSA","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"The Information module has a number of functions defined to calculate information measures from Counts and Probabilities:","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"entropy : Shannon entropy (H)\nmarginal_entropy : Shannon entropy (H) of the marginals\nkullback_leibler : Kullback-Leibler (KL) divergence\nmutual_information : Mutual Information (MI)\nnormalized_mutual_information : Normalized Mutual Information (nMI) by Entropy\ngap_intersection_percentage\ngap_union_percentage","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Information measure functions take optionally the base as the last positional argument (default: e). You can use 2.0 to measure information in bits.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information\nusing MIToS.MSA\n\nNi = count(res\"PPCDPPPPPKDKKKKDDGPP\") # Ni has the count table of residues in this low complexity sequence\n\nH = entropy(Ni) # returns the Shannon entropy in nats (base e)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"H = entropy(Ni, 2.0) # returns the Shannon entropy in bits (base 2)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Information module defines special iteration functions to easily and efficiently compute a measure over a MSA. In particular, mapcolfreq! and mapseqfreq! map a function that takes a table of Counts or Probabilities. The table is filled in place with the counts or probabilities of each column or sequence of a MSA, respectively. mapcolpairfreq! and mapseqpairfreq! are similar, but they fill the table using pairs of columns or sequences, respectively.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"This functions take three positional arguments: the function f to be calculated, the msa and table of Counts or Probabilities.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"After that, this function takes some keyword arguments:","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"weights (default: NoClustering()) : Weights to be used for table counting.\npseudocounts (default: NoPseudocount()) : Pseudocount object to be applied to table.\npseudofrequencies (default: NoPseudofrequencies()) : Pseudofrequencies to be","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"applied to the normalized (probabilities) table.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"mapcolpairfreq! and mapseqpairfreq! also have a fourth positional argument usediagonal that indicates if the function should be applied to identical element pairs (default to Val{true}). This two functions also have an extra keyword argument diagonalvalue (default to zero) to indicate the value used to fill the diagonal elements if usediagonal is Val{false}.  ","category":"page"},{"location":"Information/#Example:-Estimating-*H(X)*-and-*H(X,-Y)*-over-an-MSA","page":"Information","title":"Example: Estimating H(X) and H(X, Y) over an MSA","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"In this example, we are going to use mapcolfreq! and mapcolpairfreq! to estimate Shannon entropy of MSA columns H(X) and the joint entropy H(X, Y) of columns pairs, respectively.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"@info \"Information: Entropy\"\nusing Plots\ngr()","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.MSA\n\nmsa = read(\"http://pfam.xfam.org/family/PF09776/alignment/full\", Stockholm)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"We are going to count residues to estimate the entropy. The entropy estimation is performed over a rehused Counts object. The result will be a vector containing the values estimated over each column without counting gaps (UngappedAlphabet).  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.Information\n\nHx = mapcolfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{1}, UngappedAlphabet())))","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"If we want the joint entropy between columns pairs, we need to use a bidimensional table of Counts and mapcolpairfreq!.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Hxy = mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"In the above examples, we indicate the type of each occurrence in the counting and the probability table to use. Also, it's possible for some measures as entropy and mutual information, to estimate the values only with the count table (without calculate the probability table). Estimating measures only with a ResidueCount table, when this is possible, should be faster than using a probability table.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Time_Pab = map(1:100) do x\n    time = @elapsed mapcolpairfreq!(entropy, msa, Probabilities(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))\nend\n\nTime_Nab = map(1:100) do x\n    time = @elapsed mapcolpairfreq!(entropy, msa, Counts(ContingencyTable(Float64, Val{2}, UngappedAlphabet())))\nend\n\nusing Plots\ngr()\n\nhistogram( [Time_Pab Time_Nab],\n    labels = [\"Using ResidueProbability\" \"Using ResidueCount\"],\n    xlabel = \"Execution time [seconds]\" )\n\npng(\"inf_entropy.png\") # hide\nnothing # hide","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"(Image: )   ","category":"page"},{"location":"Information/#Corrected-Mutual-Information","page":"Information","title":"Corrected Mutual Information","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"MIToS ships with two methods to easily calculate corrected mutual information.   The first is the algorithm described in Buslje et. al. 2009(Image: ). This algorithm can be accessed through the buslje09 function and includes:  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Low count correction using AdditiveSmoothing\nSequence weighting after a hobohmI clustering\nAverage Product Correction (APC) proposed by","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Dunn et. al. 2008(Image: ), through the APC! function that takes a MI matrix.","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"Z score correction using the functions shuffle! from the MSA module and zscore","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"from the PairwiseListMatrices package.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"buslje09","category":"page"},{"location":"Information/#MIToS.Information.buslje09","page":"Information","title":"MIToS.Information.buslje09","text":"buslje09 takes a MSA or a file and a FileFormat as first arguments. It calculates a Z score and a corrected MI/MIp as described on Busjle et. al. 2009.\n\nkeyword argument, type, default value and descriptions:\n\n  - lambda      Float64   0.05    Low count value\n  - clustering  Bool      true    Sequence clustering (Hobohm I)\n  - threshold             62      Percent identity threshold for clustering\n  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation\n  - apc         Bool      true    Use APC correction (MIp)\n  - samples     Int       100     Number of samples for Z-score\n  - fixedgaps   Bool      true    Fix gaps positions for the random samples\n  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used\n\nThis function returns:\n\n  - Z score\n  - MI or MIp\n\n\n\n\n\n","category":"function"},{"location":"Information/","page":"Information","title":"Information","text":"The second, implemented in the BLMI function, has the same corrections that the above algorithm, but use BLOSUM62 pseudo frequencies. This function is slower than buslje09 (at the same number of samples), but gives better performance (for structural contact prediction) when the MSA has less than 400 clusters after a Hobohm I at 62% identity.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"BLMI","category":"page"},{"location":"Information/#MIToS.Information.BLMI","page":"Information","title":"MIToS.Information.BLMI","text":"BLMI takes a MSA or a file and a FileFormat as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on Busjle et. al. 2009 but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.\n\nKeyword argument, type, default value and descriptions:\n\n  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies\n  - lambda      Float64   0.0     Low count value\n  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)\n  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation\n  - apc         Bool      true    Use APC correction (MIp)\n  - samples     Int       50      Number of samples for Z-score\n  - fixedgaps   Bool      true    Fix gaps positions for the random samples\n\nThis function returns:\n\n  - Z score (ZBLMI)\n  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)\n\n\n\n\n\n","category":"function"},{"location":"Information/#Example:-Estimating-corrected-MI-from-an-MSA","page":"Information","title":"Example: Estimating corrected MI from an MSA","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"@info \"Information: MI\"\nusing Plots\ngr()","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using MIToS.MSA\nusing MIToS.Information\n\nmsa = read(\"http://pfam.xfam.org/family/PF16078/alignment/full\", Stockholm)\nZMIp, MIp  = buslje09(msa)\nZMIp","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"ZBLMIp, BLMIp  = BLMI(msa)\nZBLMIp","category":"page"},{"location":"Information/#Visualize-Mutual-Information","page":"Information","title":"Visualize Mutual Information","text":"","category":"section"},{"location":"Information/","page":"Information","title":"Information","text":"You can use the function of the Plots package to visualize the Mutual Information (MI) network between residues. As an example, we are going to visualize the MI between residues of the Pfam domain PF16078. The heatmap is the simplest way to visualize the values of the Mutual Information matrix.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using Plots\ngr()\n\nheatmap(ZMIp, yflip=true)\npng(\"inf_heatmap.png\") # hide\nnothing # hide","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"(Image: )   ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"ZMIp is a Z score of the corrected MIp against its distribution on a random MSA (shuffling the residues in each sequence), so pairs with highest values are more likely to co-evolve. Here, we are going to use the top 1% pairs of MSA columns.  ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"using PairwiseListMatrices # to use getlist\nusing Statistics # to use quantile\n\nthreshold = quantile(getlist(ZMIp), 0.99)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"ZMIp[ ZMIp .< threshold ] .= NaN\nheatmap(ZMIp, yflip=true)\npng(\"inf_heatmap_top.png\") # hide\nnothing # hide","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"(Image: )   ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"We are going to calculate the cMI (cumulative mutual information) value of each node. Where cMI is a mutual information score per position that characterizes the extent of mutual information \"interactions\" in its neighbourhood. This score is calculated as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network and we are going to indicate it using the node color. To calculate cMI we are going to use the cumulative function:   ","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"cMI = cumulative(ZMIp, threshold)","category":"page"},{"location":"Information/","page":"Information","title":"Information","text":"# # Setup block to hide this until PlotRecipes get fixed\n\n# The nodes have an order, because they are columns in a MSA. So, the **arc diagram** it's\n# useful to visualize long and short association between MSA positions. In general, long\n# interactions has more interest.\n\n# ` ` `@example inf_buslje09\n# using PlotRecipes\n\n# graphplot(ZMIp, size=(600,250), method=:arcdiagram) # , zcolor=cMI)\n# png(\"inf_arcdiagram.png\") # hide\n# nothing # hide\n# ` ` `  \n\n# ![](inf_arcdiagram.png)   \n\n# You can also use a **chord diagram** to see the same pattern.  \n\n# ` ` `@example inf_buslje09\n# graphplot(ZMIp, size=(600,600), method=:chorddiagram)\n# png(\"inf_chorddiagram.png\") # hide\n# nothing # hide\n# ` ` `  \n\n# ![](inf_chorddiagram.png)   \n","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"@info \"MSA docs\"","category":"page"},{"location":"MSA/#Module-MSA","page":"MSA","title":"MSA","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The MSA module of MIToS has utilities for working with Multiple Sequence Alignments of protein Sequences (MSA).  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA # to load the MSA module","category":"page"},{"location":"MSA/#Features","page":"MSA","title":"Features","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Read and write MSAs in Stockholm, FASTA, PIR or Raw format.\nHandle MSA annotations.\nEdit the MSA, e.g. delete columns or sequences, change sequence order, shuffling...\nKeep track of positions and annotations after modifications on the MSA.\nDescribe an MSA, e.g. mean percent identity, sequence coverage, gap percentage...\nSequence clustering with Hobohm I.","category":"page"},{"location":"MSA/#Contents","page":"MSA","title":"Contents","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Pages = [\"MSA.md\"]\nDepth = 4","category":"page"},{"location":"MSA/#MSA-IO","page":"MSA","title":"MSA IO","text":"","category":"section"},{"location":"MSA/#Reading-MSA-files","page":"MSA","title":"Reading MSA files","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The main function for reading MSA files in MIToS is read and it is defined in the Utils module. This function takes a filename/path as a first argument followed by other arguments. It opens the file and uses the arguments to call the parse function. read decides how to open the file, using the prefixes (e.g. https) and suffixes (i.e. extensions) of the file name, while parse does the actual parsing of the file. You can read gzipped files if they have the .gz extension and also urls pointing to a web file.   The second argument of read and parse is the file FileFormat. The supported MSA formats at the moment are Stockholm, FASTA, PIR (NBRF) and Raw.   For example, reading with MIToS the full Stockholm MSA of the family PF07388 using the Pfam RESTful interface will be:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nread(\"http://pfam.xfam.org/family/PF07388/alignment/full\", Stockholm)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The third (and optional) argument of read and parse is the output MSA type:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Matrix{Residue} : It only contains the aligned sequences.  \nMultipleSequenceAlignment : It contains the aligned sequences and their","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"names/identifiers.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"AnnotatedMultipleSequenceAlignment : It's the richest MIToS' MSA format and it's the","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"default. It includes the aligned sequences, their names and the MSA annotations.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Example of Matrix{Residue} output using a Stockholm file as input:","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"read(\"http://pfam.xfam.org/family/PF07388/alignment/full\", Stockholm, Matrix{Residue})","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Because read calls parse, you should look into the documentation of parse to know the available keyword arguments. The optional keyword arguments of those functions are:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"generatemapping : If generatemapping is true (default: false), sequences and","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"columns mappings are generated and saved in the MSA annotations. The default is false to not overwrite mappings by mistake when you read an annotated MSA file saved with MIToS.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"useidcoordinates : If useidcoordinates is true (default: false) and the names","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"have the form seqname/start-end, MIToS uses this coordinates to generate sequence mappings. This is safe and useful with unmodified Pfam MSAs. Do not use it when reading an MSA saved with MIToS. MIToS deletes unaligned insert columns, therefore disrupts sequences that have them.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"deletefullgaps : Given that lowercase characters and dots are converted to gaps,","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"unaligned insert columns in the MSA (derived from a HMM profile) are converted into full gap columns. deletefullgaps is true by default, deleting full gaps columns and therefore insert columns.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"note: Note\nIf you want to keep the insert columns...  Use the keyword argument keepinserts to true in read/parse. This only works with an AnnotatedMultipleSequenceAlignment output. A column annotation (\"Aligned\") is stored in the annotations, where insert columns are marked with 0 and aligned columns with 1.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"When read returns an AnnotatedMultipleSequenceAlignment, it uses the MSA Annotations to keep track of performed modifications. To access these notes, use printmodifications:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"msa = read(\"http://pfam.xfam.org/family/PF01565/alignment/full\", Stockholm)\n\nprintmodifications(msa)","category":"page"},{"location":"MSA/#Writing-MSA-files","page":"MSA","title":"Writing MSA files","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Julia REPL shows MSAs as Matrices. If you want to print them in another format, you should use the print function with an MSA object as first argument and the FileFormat FASTA, Stockholm, PIR or Raw as second argument.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = read(\"http://pfam.xfam.org/family/PF16996/alignment/full\", Stockholm) # reads a Stockholm MSA file\n\nprint(msa, FASTA) # prints msa in FASTA format","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"To save an MSA object to a file, use the write function. This function takes a filename as a first argument. If the filename ends with .gz, the output will be a compressed (gzipped) file. The next two arguments of write are passed to print, so write behaves as print.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"write(\"msa.gz\", msa, FASTA) # writes msa in FASTA format in a gzipped file","category":"page"},{"location":"MSA/#MSA-Annotations","page":"MSA","title":"MSA Annotations","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MSA annotations are based on the Stockholm format mark-ups. There are four types of annotations stored as dictionaries. All the annotations have a feature name as part of the key, which should be a single \"word\" (without spaces) and less than 50 characters long.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"File annotations : The annotations can contain either file or MSA information. They","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"have feature names as keys and the values are strings (free text). Lines starting with #=GF in Stockholm format.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Column annotations : They have feature names as keys and strings with exactly 1 char","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"per column as values. Lines starting with #=GC in Stockholm format.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Sequence annotations : The keys are tuples with the sequence name and the feature","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"name. The values are free text (strings). Lines starting with #=GS in Stockholm format. Annotations in the PIR/NBRF format are also stored as sequence annotations. In particular, we use the names \"Type\" and \"Title\" to name the sequence type in the identifier line and the first comment line before the sequence in PIR files, respectively.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Residue annotations : The keys are tuples with the sequence name and the feature","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"name. The values are strings with exactly 1 char per column/residues. #=GR lines in Stockholm format.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Julia REPL shows the Annotations type as they are represented in the Stockholm format(Image: ). You can get the Annotations inside an annotated MSA or sequence using the annotations function.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"annotations(msa)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Particular annotations can be accessed using the functions getannot.... These functions take the MSA/sequence as first argument and the feature name of the desired annotation as the last. In the case of getannotsequence and getannotresidue, the second argument should be the sequence name.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"getannotsequence(msa, \"A0A139NPI6_9STRE/5-59\", \"AC\") # (\"A0A139NPI6_9STRE/5-59\", \"AC\") is the key in the dictionary","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"If you want to add new annotations, you should use the setannot…! functions. These functions have the same arguments that getannot... functions except for an extra argument used to indicate the new annotation value.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"setannotsequence!(msa, \"A0A139NPI6_9STRE/5-59\", \"New_Feature_Name\", \"New_Annotation\")","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"A getannot... function without the key (last arguments), returns the particular annotation dictionary. As you can see, the new sequence annotation is now part of our MSA annotations.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"getannotsequence(msa)","category":"page"},{"location":"MSA/#Editing-your-MSA","page":"MSA","title":"Editing your MSA","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MIToS offers functions to edit your MSA. Because these functions modify the msa, their names end with a bang !, following the Julia convention. Some of these functions have an annotate keyword argument (in general, it's true by default) to indicate if the modification should be recorded in the MSA/sequence annotations.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"One common task is to delete sequences or columns of the MSA. This could be done using the functions filtersequences! and filtercolumns!. These functions take the MSA or sequence (if it's possible) as first argument and a BitVector or Vector{Bool} mask as second argument. It deletes all the sequences or columns where the mask is false. These functions are also defined for Annotations, this allows to automatically update (modify) the annotations (and therefore, sequence and column mappings) in the MSA.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"This two deleting operations are used in the second and third mutating functions of the following list:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"setreference! : Sets one of the sequences as the first sequence of the MSA (query or","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"reference sequence).  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"adjustreference! : Deletes columns with gaps in the first sequence of the MSA","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(reference).  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"gapstrip! : This function first calls adjustreference!, then deletes sequences with","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"low (user defined) MSA coverage and finally, columns with user defined % of gaps.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Also, there are several available funtions shuffle_…!. These functions are useful to generate random alignments. The Information module of MIToS uses them to calculate the Z scores of MI values.  ","category":"page"},{"location":"MSA/#Example:-Deleting-sequences","page":"MSA","title":"Example: Deleting sequences","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"For example, if you want to keep only the proteins from Actinobacteria you can delete all the sequences that don't have _9ACTN in their UniProt entry names:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = read(\"http://pfam.xfam.org/family/PF07388/alignment/full\", Stockholm)\n\nsequencenames(msa) # the function sequencenames returns the sequence names in the MSA","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"mask = map(x -> occursin(r\"_9ACTN\", x), sequencenames(msa)) # an element of mask is true if \"_9ACTN\" is in the name","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"filtersequences!(msa, mask) # deletes all the sequences where mask is false\n\nsequencenames(msa)","category":"page"},{"location":"MSA/#Example:-Exporting-a-MSA-for-freecontact-(part-I)","page":"MSA","title":"Example: Exporting a MSA for freecontact (part I)","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The most simple input for the command line tool freecontact(Image: ) (if you don't want to set --mincontsep) is a Raw MSA file with a reference sequence without insertions or gaps. This is easy to get with MIToS using read (deletes the insert columns), setreference! (to choose a reference), adjustreference! (to delete columns with gaps in the reference) and write (to save it in Raw format) functions.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\nmsa = read(\"http://pfam.xfam.org/family/PF02476/alignment/full\", Stockholm)\nmsa_coverage = coverage(msa)\nmaxcoverage, maxindex = findmax(msa_coverage) # chooses the sequence with more coverage of the MSA\nsetreference!(msa, maxindex[1])\nadjustreference!(msa)\nwrite(\"tofreecontact.msa\", msa, Raw)\nprint(read(\"tofreecontact.msa\", String)) # It displays the contents of the output file","category":"page"},{"location":"MSA/#Column-and-sequence-mappings","page":"MSA","title":"Column and sequence mappings","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Inserts in a Stockholm MSA allow to access the full fragment of the aligned sequences. Using this, combined with the sequence names that contain coordinates used in Pfam, you can know what is the UniProt residue number of each residue in the MSA.   ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"\"PROT_SPECI/3-15 .....insertALIGNED\"\n#                     3456789111111\n#                            012345","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MIToS read and parse functions delete the insert columns, but they do the mapping between each residue and its residue number before deleting insert columns when generatemapping is true. If you don't set useidcoordinates to true, the residue first i residue will be 1 instead of 3 in the previous example.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = parse(\"PROT_SPECI/3-15 .....insertALIGNED\", Stockholm, generatemapping=true, useidcoordinates=true)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MIToS also keeps the column number of the input MSA and its total number of columns. All this data is stored in the MSA annotations using the SeqMap, ColMap and NCol feature names.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"annotations(msa)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"To have an easy access to mapping data, MIToS provides the getsequencemapping and getcolumnmapping functions.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"getsequencemapping(msa, \"PROT_SPECI/3-15\")","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"getcolumnmapping(msa)","category":"page"},{"location":"MSA/#Example:-Exporting-a-MSA-for-freecontact-(part-II)","page":"MSA","title":"Example: Exporting a MSA for freecontact (part II)","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"If we want to use the --mincontsep argument of freecontact to calculate scores between distant residues, we will need to add a header to the MSA. This header should contains the residue number of the first residue of the sequence and the full fragment of that sequence (with the inserts). This data is used by FreeContact to calculate the residue number of each residue in the reference sequence.   We are going to use MIToS mapping data to create this header, so we read the MSA with generatemapping and useidcoordinates set to true.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = read( \"http://pfam.xfam.org/family/PF02476/alignment/full\", Stockholm,\n            generatemapping=true, useidcoordinates=true)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Here, we are going to choose the sequence with more coverage of the MSA as our reference sequence.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"msa_coverage = coverage(msa)\nmaxcoverage, maxindex = findmax(msa_coverage)\nsetreference!(msa, maxindex[1])\nadjustreference!(msa)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MIToS deletes the residues in insert columns, so we are going to use the sequence mapping to generate the whole fragment of the reference sequence (filling the missing regions with 'x').  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"seqmap = getsequencemapping(msa, 1) # seqmap will be a vector with the residue numbers of the first sequence (reference)\n\nseq = collect( stringsequence(msa, 1) ) # seq will be a Vector of Chars with the reference sequence\n\nsequence = map(seqmap[1]:seqmap[end]) do seqpos # for each position in the whole fragment\n    if seqpos in seqmap                         # if that position is in the MSA\n        popfirst!(seq)                          # the residue is taken from seq\n    else                                        # otherwise\n        'x'                                     # 'x' is included\n    end\nend\n\nsequence = join(sequence) # join the Chars on the Vector to create a string","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Once we have the whole fragment of the sequence, we create the file and write the header in the required format (as in the man page of freecontact).  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"open(\"tofreecontact.msa\", \"w\") do fh\n\n    println(fh, \"# querystart=\", seqmap[1])\n\n    println(fh, \"# query=\", sequence )\n\nend","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"As last (optional) argument, write takes the mode in which is opened the file. We use \"a\" here to append the MSA to the header.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"write(\"tofreecontact.msa\", msa, Raw, \"a\")","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"print(read(\"tofreecontact.msa\", String)) # It displays the contents of the output file","category":"page"},{"location":"MSA/#Get-sequences-from-a-MSA","page":"MSA","title":"Get sequences from a MSA","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"It's possible to index the MSA as any other matrix to get an aligned sequence. This will be return a Array of Residues without annotations but keeping names/identifiers.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = read( \"http://pfam.xfam.org/family/PF16996/alignment/full\", Stockholm,\n            generatemapping=true, useidcoordinates=true)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"msa[2,:] # second sequence of the MSA, it keeps column names","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"msa[2:2,:] # Using the range 2:2 to select the second sequence, keeping also the sequence name","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"If you want to obtain the aligned sequence with its name and annotations (and therefore sequence and column mappings), you should use the function getsequence. This function returns an AlignedSequence with the sequence name from a MultipleSequenceAlignment or an AnnotatedAlignedSequence, that also contains annotations, from an AnnotatedMultipleSequenceAlignment.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"secondsequence = getsequence(msa, 2)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"annotations(secondsequence)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Use stringsequence if you want to get the sequence as a string.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"stringsequence(msa, 2)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Because matrices are stored columnwise in Julia, you will find useful the getresiduesequences function when you need to heavily operate over sequences.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"getresiduesequences(msa)","category":"page"},{"location":"MSA/#Describing-your-MSA","page":"MSA","title":"Describing your MSA","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The MSA module has a number of functions to gain insight about your MSA. Using MIToS.MSA, one can easily ask for...  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The number of columns and sequences with the ncolumns and nsequences functions.  \nThe fraction of columns with residues (coverage) for each sequence making use of the","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"coverage method.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The fraction or percentage of gaps/residues using with the functions gapfraction,","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"residuefraction and columngapfraction.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The percentage of identity (PID) between each sequence of the MSA or its mean value","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"with percentidentity and meanpercentidentity.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The percentage identity between two aligned sequences is a common measure of sequence similarity and is used by the hobohmI method to estimate and reduce MSA redundancy. MIToS functions to calculate percent identity don't align the sequences, they need already aligned sequences. Full gaps columns don't count to the alignment length.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = permutedims(\n        hcat(   res\"--GGG-\",      # res\"...\" uses the @res_str macro to create a (column) Vector{Residue}\n                res\"---GGG\" ), (2,1))\n#        identities 000110 sum 2\n#  aligned residues 001111 sum 4","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"percentidentity(msa[1,:], msa[2,:]) # 2 / 4","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"To quickly calculate if the percentage of identity is greater than a determined value, use that threshold as third argument. percentidentity(seqa, seqb, pid) is a lot more faster than percentidentity(seqa, seqb) >= pid.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"percentidentity(msa[1,:], msa[2,:], 62) # 50% >= 62%","category":"page"},{"location":"MSA/#Example:-Plotting-gap-percentage-per-column-and-coverage-per-sequence","page":"MSA","title":"Example: Plotting gap percentage per column and coverage per sequence","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The gapfraction and coverage functions return a vector of numbers between 0.0 and 1.0 (fraction of...). Sometime it's useful to plot this data to quickly understand the MSA structure. In this example, we are going to use the Plots(Image: ) package for plotting, with the GR(Image: ) backend, but you are free to use any of the Julia plotting libraries.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"@info \"MSA: Plots\"\nusing Plots\ngr() # Hide possible warnings","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = read(\"http://pfam.xfam.org/family/PF09776/alignment/full\", Stockholm)\n\nusing Plots\n\ngr(size=(600,300))\n\nplot(   1:ncolumns(msa), # x is a range from 1 to the number of columns\n        vec(columngapfraction(msa)) .* 100.0, # y is a Vector{Float64} with the percentage of gaps of each column\n        linetype = :line,\n        ylabel = \"gaps [%]\",\n        xlabel = \"columns\",\n        legend=false)\n\npng(\"msa_gaps.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"plot(   1:nsequences(msa), # x is a range from 1 to the number of sequences\n        vec(coverage(msa)) .* 100, # y is a Vector{Float64} with the coverage of each sequence\n        linetype = :line,\n        ylabel = \"coverage [%]\",\n        xlabel = \"sequences\",\n        legend=false)\n\npng(\"msa_coverage.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"plot(msa)\npng(\"msa_msa.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/#Example:-Filter-sequences-per-coverage-and-columns-per-gap-fraction","page":"MSA","title":"Example: Filter sequences per coverage and columns per gap fraction","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"Taking advantage of the filter...! functions and the coverage and columngapfraction functions, it's possible to delete short sequences or columns with a lot of gaps.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"println(\"\\tsequences\\tcolumns\")\nprintln( \"Before:\\t\", nsequences(msa), \"\\t\\t\", ncolumns(msa)  )\n# delete sequences with less than 90% coverage of the MSA length:\nfiltersequences!(msa, coverage(msa) .>= 0.9)\n# delete columns with more than 10% of gaps:\nfiltercolumns!(msa, columngapfraction(msa) .<= 0.1)\nprintln( \"After:\\t\", nsequences(msa), \"\\t\\t\",  ncolumns(msa)  )","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"histogram(  vec(columngapfraction(msa)),\n            # Using vec() to get a Vector{Float64} with the fraction of gaps of each column\n            xlabel = \"gap fraction in [0,1]\", bins = 20, legend = false)\npng(\"msa_hist_gaps.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"histogram(  vec(coverage(msa) .* 100.0), #  Column with the coverage of each sequence\n            xlabel = \"coverage [%]\", legend=false)\npng(\"msa_hist_coverage.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/#Example:-Plotting-the-percentage-of-identity-between-sequences","page":"MSA","title":"Example: Plotting the percentage of identity between sequences","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The distribution of the percentage of identity between every pair of sequences in an MSA, gives an idea of the MSA diversity. In this example, we are  using percentidentity over an MSA to get those identity values.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\nmsa = read(\"http://pfam.xfam.org/family/PF09776/alignment/full\", Stockholm)\npid = percentidentity(msa)\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MIToS stores the matrix of percentage of identity between the aligned sequences as a PairwiseListMatrix from the PairwiseListMatrices(Image: ) package. This matrix type saves RAM, allowing the storage of  big matrices. In this example, we use the to_table function of PairwiseListMatrices to convert the matrix into a table with indices.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using PairwiseListMatrices\n\npidtable = to_table(pid, diagonal=false)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The function quantile gives a quick idea of the percentage identity distribution of the MSA.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using Statistics\n\nquantile(convert(Vector{Float64}, pidtable[:,3]), [0.00, 0.25, 0.50, 0.75, 1.00])","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The function meanpercentidentity gives the mean value of the percent identity distribution for MSA with less than 300 sequences, or a quick estimate (mean PID in a random sample of sequence pairs) otherwise unless you set exact to true.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"meanpercentidentity(msa)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"One can easily plot that matrix and its distribution using the heatmap and histogram functions of the Plots(Image: ) package.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"@info \"MSA: PID\"\nusing Plots\ngr() # Hide possible warnings","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using Plots\ngr()\nheatmap(convert(Matrix, pid), yflip=true, ratio=:equal)\npng(\"msa_heatmap_pid.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"histogram(pidtable[:,3], xlabel =\"Percentage of identity\", legend=false)\npng(\"msa_hist_pid.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/#Sequence-clustering","page":"MSA","title":"Sequence clustering","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"The MSA module allows to clusterize sequences in an MSA. The hobohmI function takes as input an MSA followed by an identity threshold value, and returns a Clusters type with the result of a Hobohm I(Image: ) sequence clustering. The Hobohm I algorithm will add a sequence to an existing cluster, if the percentage of identity is equal or greater than the threshold.   The Clusters is sub-type of ClusteringResult from the Clustering.jl(Image: ) package. One advantage of use a sub-type of ClusteringResultis that you are able to use any method defined on Clustering.jl like varinfo (Variation of Information) for example. Also, you can use any clustering algorithm included in Clustering.jl, and convert its result to an Clusters object to use it with MIToS.   MSA defines the functions nclusters to get the resulting number of clusters, counts to get the number of sequences on each cluster and assignments to get the cluster number of each sequence. The most important method is getweight, which returns the weight of each sequence. This method is used in the Information module of MIToS to reduce redundancy.  ","category":"page"},{"location":"MSA/#Example:-Reducing-redundancy-of-a-MSA","page":"MSA","title":"Example: Reducing redundancy of a MSA","text":"","category":"section"},{"location":"MSA/","page":"MSA","title":"MSA","text":"MSAs can suffer from an unnatural sequence redundancy and a high number of protein fragments. In this example, we are using a sequence clustering to make a non-redundant set of representative sequences. We are going to use the function hobohmI to perform the clustering with the Hobohm I algorithm at 62% identity.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"@info \"MSA: Clusters\"\nusing Plots\nusing StatsPlots\nusing DataFrames\ngr() # Hide possible warnings","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using MIToS.MSA\n\nmsa = read(\"http://pfam.xfam.org/family/PF09776/alignment/full\", Stockholm)\n\nprintln(\"This MSA has \", nsequences(msa), \" sequences...\")","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"clusters = hobohmI(msa, 62)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"println(\"...but has only \", nclusters(clusters), \" sequence clusters after a clustering at 62% identity.\")","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using Plots\ngr()\n\nplot(msa)\npng(\"msa_clusters_i.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"We are going to use the DataFrames(Image: ) package to easily select the sequence with the highest coverage of each cluster.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using DataFrames\n\ndf = DataFrame( seqnum = 1:nsequences(msa),\n                seqname = sequencenames(msa),\n                cluster = assignments(clusters), # the cluster number/index of each sequence\n                coverage = vec(coverage(msa)))\n\nfirst(df, 5)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"It is possible to use this DataFrame and Plots to plot the sequence coverage of the MSA and also an histogram of the number of sequences in each cluster:  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"using StatsPlots # Plotting DataFrames\nh = @df df histogram(:cluster, ylabel=\"nseq\")\np = @df df plot(:cluster, :coverage, linetype=:scatter)\nplot(p, h, nc=1, xlim=(0, nclusters(clusters)+1 ), legend=false)\npng(\"msa_clusters_ii.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"We use the Split-Apply-Combine strategy, though the by function of the DataFrames package, to select the sequence of highest coverage for each cluster.  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"maxcoverage = by(df, :cluster, cl -> cl[ findmax(cl[:coverage])[2] ,\n                 [:seqnum, :seqname, :coverage]])\n\nfirst(maxcoverage, 5)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"p = @df maxcoverage plot(:cluster, :coverage, linetype=:scatter)\nh = @df maxcoverage histogram(:cluster, ylabel=\"nseq\")\nplot(p, h, nc=1, xlim=(0, nclusters(clusters)+1 ), legend=false)\npng(\"msa_clusters_iii.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"We can easily generate a mask using list comprehension, to select only the representative sequences of the MSA (deleting the rest of the sequences with filtersequences!).  ","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"cluster_references = Bool[ seqnum in maxcoverage[:seqnum] for seqnum in 1:nsequences(msa) ]","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"filtersequences!(msa, cluster_references)","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"plot(msa)\npng(\"msa_clusters_iv.png\") # hide\nnothing # hide","category":"page"},{"location":"MSA/","page":"MSA","title":"MSA","text":"(Image: )  ","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"EditURL = \"https://github.com/diegozea/MIToS.jl/blob/master/docs/src/cookbook/03_RMSF.jl\"","category":"page"},{"location":"03_RMSF/#Root-Mean-Squared-Fluctuation-(RMSF)","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"","category":"section"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"md # (Image: ) md # (Image: )","category":"page"},{"location":"03_RMSF/#Problem-description","page":"Root Mean Squared Fluctuation (RMSF)","title":"Problem description","text":"","category":"section"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"The Root Mean Squared Fluctuation (RMSF) is a common way to measure residue flexibility in a structural ensemble. It is a measure of how far is the residue moving from its average position in the group of structures. Usually, we represent a residue position with the spatial coordinates of its alpha carbon.","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"The protein structures should be previously superimposed to calculate the RMSF, for example, by using the superimpose function of the PDB module of MIToS. In this example, we are going to measure the RMSF of each residue from an NMR ensemble using the rmsf function.","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"The structure superimposition could be the most complicated step of the process, depending on the input data. In particular, it structures come from different PDB structures or homologous proteins can require the use of external programs, as MAMMOTH-mult or MUSTANG among others, tailored for this task.","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"In this case, we are going to use an NMR ensemble. Therefore, we are not going to need to superimpose the structures as NMR models have the same protein sequence and are, usually, well-aligned.","category":"page"},{"location":"03_RMSF/#MIToS-solution","page":"Root Mean Squared Fluctuation (RMSF)","title":"MIToS solution","text":"","category":"section"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"import MIToS\nusing MIToS.PDB\nusing Plots","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"Lets read the NMR ensemble:","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"pdb_file   = abspath(pathof(MIToS), \"..\", \"..\", \"test\", \"data\", \"1AS5.pdb\")\npdb_res = read(pdb_file, PDBFile, occupancyfilter=true)","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"md nothing # hide","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"We set occupancyfilter to true to ensure that we have one single set of coordinates for each atom. That filter isn't essential for NMR structures, but It can avoid multiple alpha carbons in crystallographic structures with disordered atoms. We can get an idea of the alpha carbon positions by plotting these residues:","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"scatter(pdb_res, legend=false)","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"As we saw in the previous plot, the structure doesn't need to be superimposed. Now, we are going to separate each model into different vectors, storing each vector into a Dict:","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"models = Dict{String,Vector{PDBResidue}}()\nfor res in pdb_res\n\tpush!(get!(models, res.id.model, []), res)\nend","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"Then, we simply need to collect all the PDB models in the values of the Dict, to get the vector of PDBResidues vectors required to calculate the RMSF.","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"pdb_models = collect(values(models))","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"md nothing # hide","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"And, finally, call the rmsf function on the list of structures. It is important that all the vectors has the same number of PDBResidues. This function assumes that the nth element of each vector corresponds to the same residue:","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"RMSF = rmsf(pdb_models)","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"This return the vector of RMSF values for each residue, calculated using the coordinates of the alpha carbons. You can plot this vector to get an idea of the which are the most flexible position in your structure:","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"plot(RMSF, legend=false, xlab=\"Residue\", ylab=\"RMSF [Å]\")","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"","category":"page"},{"location":"03_RMSF/","page":"Root Mean Squared Fluctuation (RMSF)","title":"Root Mean Squared Fluctuation (RMSF)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"@info \"Utils API docs\"","category":"page"},{"location":"Utils_API/#API-Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"MIToS.Utils","category":"page"},{"location":"Utils_API/#MIToS.Utils","page":"Utils","title":"MIToS.Utils","text":"The Utils has common utils functions and types used in other modules.\n\nusing MIToS.Utils\n\n\n\n\n\n","category":"module"},{"location":"Utils_API/#Contents","page":"Utils","title":"Contents","text":"","category":"section"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"Pages = [\"Utils_API.md\"]\nDepth = 2","category":"page"},{"location":"Utils_API/#Types","page":"Utils","title":"Types","text":"","category":"section"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"Modules = [MIToS.Utils]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"Utils_API/#MIToS.Utils.All","page":"Utils","title":"MIToS.Utils.All","text":"All is used instead of MIToS 1.0 \"all\" or \"*\", because it's possible to dispatch on it.\n\n\n\n\n\n","category":"type"},{"location":"Utils_API/#MIToS.Utils.FileFormat","page":"Utils","title":"MIToS.Utils.FileFormat","text":"FileFormat is used for write special parse (and read) methods on it.\n\n\n\n\n\n","category":"type"},{"location":"Utils_API/#Constants","page":"Utils","title":"Constants","text":"","category":"section"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"Modules = [MIToS.Utils]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"Utils_API/#Macros","page":"Utils","title":"Macros","text":"","category":"section"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"Modules = [MIToS.Utils]\nPrivate = false\nOrder   = [:macro]","category":"page"},{"location":"Utils_API/#Methods-and-functions","page":"Utils","title":"Methods and functions","text":"","category":"section"},{"location":"Utils_API/","page":"Utils","title":"Utils","text":"Modules = [MIToS.Utils]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"Utils_API/#Base.read-Union{Tuple{T}, Tuple{AbstractString, Type{T}, Vararg{Any}}} where T<:MIToS.Utils.FileFormat","page":"Utils","title":"Base.read","text":"read(pathname, FileFormat [, Type [, … ] ] ) -> Type\n\nThis function opens a file in the pathname and calls parse(io, ...) for the given FileFormat and Type on it. If the  pathname is an HTTP or FTP URL, the file is downloaded with download in a temporal file. Gzipped files should end on .gz.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#Base.write-Union{Tuple{T}, Tuple{AbstractString, Any, Type{T}}, Tuple{AbstractString, Any, Type{T}, String}} where T<:MIToS.Utils.FileFormat","page":"Utils","title":"Base.write","text":"write{T<:FileFormat}(filename::AbstractString, object, format::Type{T}, mode::ASCIIString=\"w\")\n\nThis function opens a file with filename and mode (default: \"w\") and writes (print) the object with the given format. Gzipped files should end on .gz.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.check_file-Tuple{Any}","page":"Utils","title":"MIToS.Utils.check_file","text":"Returns the filename. Throws an ErrorException if the file doesn't exist, or a warning if the file is empty.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.check_pdbcode-Tuple{String}","page":"Utils","title":"MIToS.Utils.check_pdbcode","text":"It checks if a PDB code has the correct format.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.download_file-Tuple{AbstractString, AbstractString}","page":"Utils","title":"MIToS.Utils.download_file","text":"download_file uses HTTP.jl instead of system calls to download files from the web. It takes the file url as first argument and, optionally, a path to save it. Keyword arguments (ie. redirect, retry, readtimeout) are are directly passed to to HTTP.open (HTTP.request). Use the headers keyword argument to pass a Dict{String,String} with the header information. Set the HTTPS_PROXY and HTTPS_PROXY ENViromental variables if you are behind a proxy.\n\njulia> using MIToS.Utils\n\njulia> download_file(\"http://www.uniprot.org/uniprot/P69905.fasta\",\"seq.fasta\",\n       headers = Dict(\"User-Agent\" =>\n                      \"Mozilla/5.0 (compatible; MSIE 7.01; Windows NT 5.0)\"),\n       redirect=true)\n\"seq.fasta\"\n\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.get_n_words-Tuple{String, Int64}","page":"Utils","title":"MIToS.Utils.get_n_words","text":"get_n_words{T <: Union{ASCIIString, UTF8String}}(line::T, n::Int) It returns a Vector{T} with the first n (possibles) words/fields (delimited by space or tab). If there is more than n words, the last word returned contains the finals words and the delimiters. The length of the returned vector is n or less (if the number of words is less than n). This is used for parsing the Stockholm format.\n\njulia> using MIToS.Utils\n\njulia> get_n_words(\"#=GR O31698/18-71 SS    CCCHHHHHHHHHHHHHHHEEEEEEEEEEEEEEEEHHH\", 3)\n3-element Array{String,1}:\n \"#=GR\"\n \"O31698/18-71\"\n \"SS    CCCHHHHHHHHHHHHHHHEEEEEEEEEEEEEEEEHHH\"\n\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.getarray-Tuple{NamedArrays.NamedArray}","page":"Utils","title":"MIToS.Utils.getarray","text":"Getter for the array field of NamedArrays\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.hascoordinates-Tuple{Any}","page":"Utils","title":"MIToS.Utils.hascoordinates","text":"hascoordinates(id) It returns true if id/sequence name has the format: UniProt/start-end (i.e. O83071/192-246)\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.isnotemptyfile-Tuple{Any}","page":"Utils","title":"MIToS.Utils.isnotemptyfile","text":"Returns true if the file exists and isn't empty.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.lineiterator-Tuple{String}","page":"Utils","title":"MIToS.Utils.lineiterator","text":"Create an iterable object that will yield each line from a stream or string.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.list2matrix-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T","page":"Utils","title":"MIToS.Utils.list2matrix","text":"Returns a square symmetric matrix from the vector vec. side is the number of rows/columns. The diagonal is not included by default, set to true if there are diagonal elements in the list.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.matrix2list-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Utils","title":"MIToS.Utils.matrix2list","text":"Returns a vector with the part (\"upper\" or \"lower\") of the square matrix mat. The diagonal is not included by default.\n\n\n\n\n\n","category":"method"},{"location":"Utils_API/#MIToS.Utils.select_element-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, String}} where T","page":"Utils","title":"MIToS.Utils.select_element","text":"Selects the first element of the vector. This is useful for unpacking one element vectors. Throws a warning if there are more elements. element_name is element by default, but the name can be changed using the second argument.\n\n\n\n\n\n","category":"method"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"@info \"SIFTS docs\"","category":"page"},{"location":"SIFTS/#Module-SIFTS","page":"SIFTS","title":"SIFTS","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"The SIFTS module of MIToS allows to obtain the residue-level mapping between databases stored in the SIFTS XML files. It makes easy to assign PDB residues to UniProt/Pfam positions.   Given the fact that pairwise alignments can lead to misleading association between residues in both sequences, SIFTS offers  more reliable association between sequence and structure residue numbers.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS # to load the SIFTS module","category":"page"},{"location":"SIFTS/#Features","page":"SIFTS","title":"Features","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Download and parse SIFTS XML files\nStore residue-level mapping in Julia\nEasy generation of Dicts between residues numbers","category":"page"},{"location":"SIFTS/#Contents","page":"SIFTS","title":"Contents","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Pages = [\"SIFTS.md\"]\nDepth = 4","category":"page"},{"location":"SIFTS/#Simplest-residue-level-mapping","page":"SIFTS","title":"Simplest residue-level mapping","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"This module export the function siftsmapping to generate a Dict between residue numbers. This function takes 5 positional arguments.     1) The name of the SIFTS XML file to parse,       2) the source database,       3) the source protein/structure identifier,       4) the destiny database and,       5) the destiny protein/structure identifier.   Optionally it’s possible to indicate a particular PDB chain and if missings will be used.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Databases should be indicated using an available sub-type of DataBase. Keys and values types will be depend on the residue number type in that database.","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Type db... Database Residue number type\ndbPDBe PDBe (Protein Data Bank in Europe) Int\ndbInterPro InterPro String\ndbUniProt UniProt Int\ndbPfam Pfam (Protein families database) Int\ndbNCBI NCBI (National Center for Biotechnology Information) Int\ndbPDB PDB (Protein Data Bank) String\ndbCATH CATH String\ndbSCOP SCOP (Structural Classification of Proteins) String\ndbEnsembl Ensembl String","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"To download the XML SIFTS file of a determined PDB use the downloadsifts function.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS\n\nimport MIToS # to use pathof(MIToS)\nsiftsfile = joinpath(dirname(pathof(MIToS)), \"..\", \"docs\", \"data\", \"1ivo.xml.gz\");","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"siftsfile = downloadsifts(\"1IVO\")","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"The following example, shows the residue number mapping between Pfam and PDB. Pfam uses UniProt coordinates and PDB uses their own residue numbers with insertion codes. Note that the siftsmapping function is case sensitive, and that SIFTS stores PDB identifiers using lowercase characters.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"siftsmap = siftsmapping(siftsfile,\n                        dbPfam,\n                        \"PF00757\",\n                        dbPDB,\n                        \"1ivo\", # SIFTS stores PDB identifiers in lowercase\n                        chain=\"A\", # In this example we are only using the chain A of the PDB\n                        missings=false) # Residues without coordinates aren't used in the mapping","category":"page"},{"location":"SIFTS/#Storing-residue-level-mapping","page":"SIFTS","title":"Storing residue-level mapping","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"If you need more than the residue number mapping between two databases, you could access all the residue-level cross references using the function read in the SIFTSXMLFile.Format file. The parse function (and therefore the read function) for the SIFTSXML format, also takes the keyword arguments chain and missings. The read/parse function returns a Vector of SIFTSResidues objects that stores the cross references between residues in each database.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"siftsresidues = read(siftsfile, SIFTSXML, chain=\"A\", missings=false) # Array{SIFTSResidue,1}\nresidue_data = siftsresidues[301];","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"You are free to access the SIFTSResidue fields in order to get the desired information. SIFTSResidue objects contain db... objects (sub-types of DataBase), with the cross referenced information. You should note that, except for the PDBe and InterPro fields, the field values can be missing. The ismissing function is helpful to know if there is a db... object. For example, getting the UniProt residue name (one letter code of the amino acid) would be:  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"ismissing(residue_data.UniProt) ? \"\" : residue_data.UniProt.name","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"That line of code returns an empty string if the UniProt field is missing. Otherwise, it returns a string with the name of the residue in UniProt. Because that way of access values in a SIFT residue is too verbose, MIToS defines a more complex signature for get. Using MIToS get the previous line of code will be:  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"#   SIFTSResidue  database   field  default\nget(residue_data, dbUniProt, :name, \"\")","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"The is not need to use the full signature. Other signatures are possible depending on the value you want to access. In particular, a missing object is returned if a default value is not given at the end of the signature and the value to access is missing:","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"import MIToS # to use pathof(MIToS)\nsiftsfile = joinpath(dirname(pathof(MIToS)), \"..\", \"docs\", \"data\", \"1ivo.xml.gz\")\n\nusing MIToS.SIFTS\nresidue_data = read(siftsfile, SIFTSXML)[301]; # hide","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"get(residue_data, dbUniProt) # get takes the database type (`db...`)\nget(residue_data, dbUniProt, :name) # and can also take a field name (Symbol)","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"But you don't need the get function to access the three letter code of the residue in PDBe because the PDBe field can not be missing.","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"residue_data.PDBe.name","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"SIFTSResidue also store information about if that residue is missing (i.e. not resolved) in the PDB structure and the information about the secondary structure (sscode and ssname):  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"residue_data.missing\nresidue_data.sscode\nresidue_data.ssname","category":"page"},{"location":"SIFTS/#Accessing-residue-level-cross-references","page":"SIFTS","title":"Accessing residue-level cross references","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"You can ask for particular values in a single SIFTSResidue using the get function.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS\nresidue_data = read(siftsfile, SIFTSXML)[301]\n# Is the UniProt residue name in the list of basic amino acids [\"H\", \"K\", \"R\"]?\nget(residue_data, dbUniProt, :name, \"\") in [\"H\", \"K\", \"R\"]","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Use higher order functions and lambda expressions (anonymous functions) or list comprehension to easily ask for information on the Vector{SIFTSResidue}. You can use get with the previous signature or simple direct field access and ismissing.","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"# Captures PDB residue numbers if the Pfam id is \"PF00757\"\nresnums = [ res.PDB.number for res in siftsresidues if !ismissing(res.PDB) && get(res, dbPfam, :id, \"\") == \"PF00757\" ]","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Useful higher order functions are:","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"findall  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"# Which of the residues have UniProt residue names in the list [\"H\", \"K\", \"R\"]? (basic residues)\nindexes = findall(res -> get(res, dbUniProt, :name, \"\") in [\"H\", \"K\", \"R\"], siftsresidues)","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"map  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"map(i -> siftsresidues[i].UniProt, indexes) # UniProt data of the basic residues","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"filter  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"# SIFTSResidues with UniProt names in [\"H\", \"K\", \"R\"]\nbasicresidues = filter(res -> get(res, dbUniProt, :name, \"\") in [\"H\", \"K\", \"R\"], siftsresidues)\n\nbasicresidues[1].UniProt # UniProt data of the first basic residue","category":"page"},{"location":"SIFTS/#Example:-Which-residues-are-missing-in-the-PDB-structure","page":"SIFTS","title":"Example: Which residues are missing in the PDB structure","text":"","category":"section"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"Given that SIFTSResidue objects store a missing residue flag, it’s easy to get a vector where there is a true value if the residue is missing in the structure.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"import MIToS # to use pathof(MIToS)\nsiftsfile = joinpath(dirname(pathof(MIToS)), \"..\", \"docs\", \"data\", \"1ivo.xml.gz\");","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS\nsifts_1ivo = read(siftsfile, SIFTSXML, chain=\"A\"); # SIFTSResidues of the 1IVO chain A\n[res.missing for res in sifts_1ivo]","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"However, if you need to filter using other conditions, you’ll find useful the get function. In this example, we are going to ask for the UniProt id (to avoid problems with fragments, tags or chimeric/fusion proteins). We are also using get to select an specific PDB chain.  ","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS\n\nimport MIToS # to use pathof(MIToS)\nsiftsfile = joinpath(dirname(pathof(MIToS)), \"..\", \"docs\", \"data\", \"1jqz.xml.gz\");","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"siftsfile = downloadsifts(\"1JQZ\")","category":"page"},{"location":"SIFTS/","page":"SIFTS","title":"SIFTS","text":"using MIToS.SIFTS\nsifts_1jqz = read(siftsfile, SIFTSXML); # It has an amino terminal his tag\nmissings = [ (  ( get(res, dbUniProt, :id, \"\") == \"P05230\" ) &\n                ( get(res, dbPDB, :chain, \"\") ==  \"A\" ) &\n                res.missing ) for res in sifts_1jqz             ];\nprintln(\"There are only \", sum(missings), \" missing residues in the chain A, associated to UniProt P05230\")\nprintln(\"But there are \", sum([ res.missing for res in sifts_1jqz ]), \" missing residues in the PDB file.\")","category":"page"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"@info \"Pfam API docs\"","category":"page"},{"location":"Pfam_API/#Pfam","page":"Pfam","title":"Pfam","text":"","category":"section"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"MIToS.Pfam","category":"page"},{"location":"Pfam_API/#MIToS.Pfam","page":"Pfam","title":"MIToS.Pfam","text":"The Pfam module, defines functions to measure the protein contact prediction performance of information measure between column pairs from a Pfam MSA.\n\nFeatures\n\nRead and download Pfam MSAs\nObtain PDB information from alignment annotations\nMap between sequence/alignment residues/columns and PDB structures\nMeasure of AUC (ROC curve) for contact prediction of MI scores\n\nusing MIToS.Pfam\n\n\n\n\n\n","category":"module"},{"location":"Pfam_API/#Contents","page":"Pfam","title":"Contents","text":"","category":"section"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"Pages = [\"Pfam_API.md\"]\nDepth = 2","category":"page"},{"location":"Pfam_API/#Types","page":"Pfam","title":"Types","text":"","category":"section"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"Modules = [MIToS.Pfam]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"Pfam_API/#Constants","page":"Pfam","title":"Constants","text":"","category":"section"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"Modules = [MIToS.Pfam]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"Pfam_API/#Macros","page":"Pfam","title":"Macros","text":"","category":"section"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"Modules = [MIToS.Pfam]\nPrivate = false\nOrder   = [:macro]","category":"page"},{"location":"Pfam_API/#Methods-and-functions","page":"Pfam","title":"Methods and functions","text":"","category":"section"},{"location":"Pfam_API/","page":"Pfam","title":"Pfam","text":"Modules = [MIToS.Pfam]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"Pfam_API/#MIToS.Pfam.downloadpfam-Tuple{String}","page":"Pfam","title":"MIToS.Pfam.downloadpfam","text":"It downloads a gzipped Stockholm alignment from InterPro for the Pfam family  with the given pfamcode. By default, it downloads the full Pfam  alignment. You can use the alignment keyword argument to download the  seed or the uniprot alignment instead. The extension of the downloaded  file is .stockholm.gz by default; you can change it using the filename  keyword argument, but the .gz at the end is mandatory.\n\n\n\n\n\n","category":"method"},{"location":"Pfam_API/#MIToS.Pfam.getcontactmasks-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractFloat","page":"Pfam","title":"MIToS.Pfam.getcontactmasks","text":"This function takes a msacontacts or its list of contacts contact_list with 1.0 for true contacts and 0.0 for not contacts (NaN or other numbers for missing values). Returns two BitVectors, the first with trues where contact_list is 1.0 and the second with trues where contact_list is 0.0. There are useful for AUC calculations.\n\n\n\n\n\n","category":"method"},{"location":"Pfam_API/#MIToS.Pfam.getseq2pdb-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment}","page":"Pfam","title":"MIToS.Pfam.getseq2pdb","text":"Generates from a Pfam msa a Dict{String, Vector{Tuple{String,String}}}. Keys are sequence IDs and each value is a list of tuples containing PDB code and chain.\n\njulia> getseq2pdb(msa)\nDict{String,Array{Tuple{String,String},1}} with 1 entry:\n  \"F112_SSV1/3-112\" => [(\"2VQC\",\"A\")]\n\n\n\n\n\n\n","category":"method"},{"location":"Pfam_API/#MIToS.Pfam.hasresidues-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment, AbstractDict{Int64, String}}","page":"Pfam","title":"MIToS.Pfam.hasresidues","text":"Returns a BitVector where there is a true for each column with PDB residue.\n\n\n\n\n\n","category":"method"},{"location":"Pfam_API/#MIToS.Pfam.msacolumn2pdbresidue-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment, String, String, String, String, String}","page":"Pfam","title":"MIToS.Pfam.msacolumn2pdbresidue","text":"msacolumn2pdbresidue(msa, seqid, pdbid, chain, pfamid, siftsfile; strict=false, checkpdbname=false, missings=true)\n\nThis function returns a OrderedDict{Int,String} with MSA column numbers on the input file as keys and PDB residue numbers (\"\" for missings) as values. The mapping is performed using SIFTS. This function needs correct ColMap and SeqMap annotations. This checks correspondence of the residues between the MSA sequence and SIFTS (It throws a warning if there are differences). Missing residues are included if the keyword argument missings is true (default: true). If the keyword argument strict is true (default: false), throws an Error, instead of a Warning, when residues don't match. If the keyword argument checkpdbname is true (default: false), throws an Error if the three letter name of the PDB residue isn't the MSA residue. If you are working with a downloaded Pfam MSA without modifications, you should read it using generatemapping=true and useidcoordinates=true. If you don't indicate the path to the siftsfile used in the mapping, this function downloads the SIFTS file in the current folder. If you don't indicate the Pfam accession number (pfamid), this function tries to read the AC file annotation.\n\n\n\n\n\n","category":"method"},{"location":"Pfam_API/#MIToS.Pfam.msacontacts","page":"Pfam","title":"MIToS.Pfam.msacontacts","text":"This function takes an AnnotatedMultipleSequenceAlignment with correct ColMap annotations and two dicts:\n\nThe first is an OrderedDict{String,PDBResidue} from PDB residue number to PDBResidue.\nThe second is a Dict{Int,String} from MSA column number on the input file to PDB residue number.\n\nmsacontacts returns a PairwiseListMatrix{Float64,false} of 0.0 and 1.0 where 1.0 indicates a residue contact. Contacts are defined with an inter residue distance less or equal to distance_limit (default to 6.05) angstroms between any heavy atom. NaN indicates a missing value.\n\n\n\n\n\n","category":"function"},{"location":"Pfam_API/#MIToS.Pfam.msaresidues-Tuple{MIToS.MSA.AnnotatedMultipleSequenceAlignment, AbstractDict{String, MIToS.PDB.PDBResidue}, AbstractDict{Int64, String}}","page":"Pfam","title":"MIToS.Pfam.msaresidues","text":"This function takes an AnnotatedMultipleSequenceAlignment with correct ColMap annotations and two dicts:\n\nThe first is an OrderedDict{String,PDBResidue} from PDB residue number to PDBResidue.\nThe second is a Dict{Int,String} from MSA column number on the input file to PDB residue number.\n\nmsaresidues returns an OrderedDict{Int,PDBResidue} from input column number (ColMap) to PDBResidue. Residues on inserts are not included.\n\n\n\n\n\n","category":"method"},{"location":"Pfam_API/#ROCAnalysis.AUC-Union{Tuple{NR}, Tuple{NL}, Tuple{VR}, Tuple{VL}, Tuple{R}, Tuple{L}, Tuple{NamedArrays.NamedArray{L, 2, PairwiseListMatrices.PairwiseListMatrix{L, false, VL}, NL}, NamedArrays.NamedArray{R, 2, PairwiseListMatrices.PairwiseListMatrix{L, false, VR}, NR}}} where {L<:AbstractFloat, R<:AbstractFloat, VL, VR, NL, NR}","page":"Pfam","title":"ROCAnalysis.AUC","text":"AUC(scores::PairwiseListMatrix, msacontacts::PairwiseListMatrix)\n\nReturns the Area Under a ROC (Receiver Operating Characteristic) Curve (AUC) of the scores for msacontact prediction. score and msacontact lists are vinculated (inner join) by their labels (i.e. column number in the file). msacontact should have 1.0 for true contacts and 0.0 for not contacts (NaN or other numbers for missing values). You need to do using ROCAnalysis before using this function.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"@info \"PDB API docs\"","category":"page"},{"location":"PDB_API/#PDB","page":"PDB","title":"PDB","text":"","category":"section"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"MIToS.PDB","category":"page"},{"location":"PDB_API/#MIToS.PDB","page":"PDB","title":"MIToS.PDB","text":"The module PDB defines types and methods to work with protein structures inside Julia. It is useful to link structural and sequential information, and needed for measure the predictive performance at protein contact prediction of mutual information scores.\n\nFeatures\n\nRead and parse PDF and PDBML files\nCalculate distance and contacts between atoms or residues\nDetermine interaction between residues\n\nusing MIToS.PDB\n\n\n\n\n\n","category":"module"},{"location":"PDB_API/#Contents","page":"PDB","title":"Contents","text":"","category":"section"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"Pages = [\"PDB_API.md\"]\nDepth = 2","category":"page"},{"location":"PDB_API/#Types","page":"PDB","title":"Types","text":"","category":"section"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"Modules = [MIToS.PDB]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"PDB_API/#MIToS.PDB.Coordinates","page":"PDB","title":"MIToS.PDB.Coordinates","text":"A Coordinates object is a fixed size vector with the coordinates x,y,z.\n\n\n\n\n\n","category":"type"},{"location":"PDB_API/#MIToS.PDB.PDBAtom","page":"PDB","title":"MIToS.PDB.PDBAtom","text":"A PDBAtom object contains the information from a PDB atom, without information of the residue. It has the following fields that you can access at any moment for query purposes:\n\n- `coordinates` : x,y,z coordinates, e.g. `Coordinates(109.641,73.162,42.7)`.\n- `atom` : Atom name, e.g. `\"CA\"`.\n- `element` : Element type of the atom, e.g. `\"C\"`.\n- `occupancy` : A float number with the occupancy, e.g. `1.0`.\n- `B` : B factor as a string, e.g. `\"23.60\"`.\n\n\n\n\n\n","category":"type"},{"location":"PDB_API/#MIToS.PDB.PDBFile","page":"PDB","title":"MIToS.PDB.PDBFile","text":"PDBFile <: FileFormat\n\nProtein Data Bank (PDB) format. It provides a standard representation for macromolecular structure data derived from X-ray diffraction and NMR studies.\n\n\n\n\n\n","category":"type"},{"location":"PDB_API/#MIToS.PDB.PDBML","page":"PDB","title":"MIToS.PDB.PDBML","text":"PDBML <: FileFormat\n\nProtein Data Bank Markup Language (PDBML), a representation of PDB data in XML format.\n\n\n\n\n\n","category":"type"},{"location":"PDB_API/#MIToS.PDB.PDBResidue","page":"PDB","title":"MIToS.PDB.PDBResidue","text":"A PDBResidue object contains all the information about a PDB residue. It has the following fields that you can access at any moment for query purposes:\n\n- `id` : A `PDBResidueIdentifier` object.\n- `atoms` : A vector of `PDBAtom`s.\n\n\n\n\n\n","category":"type"},{"location":"PDB_API/#MIToS.PDB.PDBResidueIdentifier","page":"PDB","title":"MIToS.PDB.PDBResidueIdentifier","text":"A PDBResidueIdentifier object contains the information needed to identity PDB residues. It has the following fields that you can access at any moment for query purposes:\n\n- `PDBe_number` : It's only used when a PDBML is readed (PDBe number as a string).\n- `number` : PDB residue number, it includes insertion codes, e.g. `\"34A\"`.\n- `name` : Three letter residue name in PDB, e.g. `\"LYS\"`.\n- `group` : It can be `\"ATOM\"` or `\"HETATM\"`.\n- `model` : The model number as a string, e.g. `\"1\"`.\n- `chain` : The chain as a string, e.g. `\"A\"`.\n\n\n\n\n\n","category":"type"},{"location":"PDB_API/#Constants","page":"PDB","title":"Constants","text":"","category":"section"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"Modules = [MIToS.PDB]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"PDB_API/#MIToS.PDB.covalentradius","page":"PDB","title":"MIToS.PDB.covalentradius","text":"Covalent radius in Å of each element from the Additional file 1 of PICCOLO [1]. Hydrogen was updated using the value on Table 2 from Cordero et. al. [2].\n\nBickerton, G. R., Higueruelo, A. P., & Blundell, T. L. (2011).\n\nComprehensive, atomic-level characterization of structurally characterized protein-protein interactions: the PICCOLO database. BMC bioinformatics, 12(1), 313.\n\nCordero, B., Gómez, V., Platero-Prats, A. E., Revés, M.,\n\nEcheverría, J., Cremades, E., ... & Alvarez, S. (2008). Covalent radii revisited. Dalton Transactions, (21), 2832-2838.\n\n\n\n\n\n","category":"constant"},{"location":"PDB_API/#MIToS.PDB.vanderwaalsradius","page":"PDB","title":"MIToS.PDB.vanderwaalsradius","text":"van der Waals radius in Å from the Additional file 1 of Bickerton et. al. 2011\n\nBickerton, G. R., Higueruelo, A. P., & Blundell, T. L. (2011).\n\nComprehensive, atomic-level characterization of structurally characterized protein-protein interactions: the PICCOLO database. BMC bioinformatics, 12(1), 313.\n\n\n\n\n\n","category":"constant"},{"location":"PDB_API/#Macros","page":"PDB","title":"Macros","text":"","category":"section"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"Modules = [MIToS.PDB]\nPrivate = false\nOrder   = [:macro]","category":"page"},{"location":"PDB_API/#MIToS.PDB.@atoms-Tuple{Any, Symbol, Any, Symbol, Any, Symbol, Any, Symbol, Any, Symbol, Any}","page":"PDB","title":"MIToS.PDB.@atoms","text":"@atoms ... model ... chain ... group ... residue ... atom ...\n\nThese return a vector of PDBAtoms with the selected subset of atoms. You can use the type All to avoid filtering that option.\n\n\n\n\n\n","category":"macro"},{"location":"PDB_API/#MIToS.PDB.@residues-Tuple{Any, Symbol, Any, Symbol, Any, Symbol, Any, Symbol, Any}","page":"PDB","title":"MIToS.PDB.@residues","text":"@residues ... model ... chain ... group ... residue ...\n\nThese return a new vector with the selected subset of residues from a list of residues. You can use the type All to avoid filtering that option.\n\n\n\n\n\n","category":"macro"},{"location":"PDB_API/#MIToS.PDB.@residuesdict-Tuple{Any, Symbol, Any, Symbol, Any, Symbol, Any, Symbol, Any}","page":"PDB","title":"MIToS.PDB.@residuesdict","text":"@residuesdict ... model ... chain ... group ... residue ...\n\nThese return a dictionary (using PDB residue numbers as keys) with the selected subset of residues. You can use the type All to avoid filtering that option.\n\n\n\n\n\n","category":"macro"},{"location":"PDB_API/#Methods-and-functions","page":"PDB","title":"Methods and functions","text":"","category":"section"},{"location":"PDB_API/","page":"PDB","title":"PDB","text":"Modules = [MIToS.PDB]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"PDB_API/#Base.angle-Tuple{MIToS.PDB.Coordinates, MIToS.PDB.Coordinates, MIToS.PDB.Coordinates}","page":"PDB","title":"Base.angle","text":"angle(a::Coordinates, b::Coordinates, c::Coordinates)\n\nAngle (in degrees) at b between a-b and b-c\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#Base.any-Tuple{Function, MIToS.PDB.PDBResidue, MIToS.PDB.PDBResidue, Function}","page":"PDB","title":"Base.any","text":"any(f::Function, a::PDBResidue, b::PDBResidue, criteria::Function)\n\nTest if the function f is true for any pair of atoms between the residues a and b. This function only test atoms that returns true for the fuction criteria.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#Base.any-Tuple{Function, MIToS.PDB.PDBResidue, MIToS.PDB.PDBResidue}","page":"PDB","title":"Base.any","text":"any(f::Function, a::PDBResidue, b::PDBResidue)\n\nTest if the function f is true for any pair of atoms between the residues a and b\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#Base.parse-Tuple{LightXML.XMLDocument, Type{MIToS.PDB.PDBML}}","page":"PDB","title":"Base.parse","text":"parse(pdbml, ::Type{PDBML}; chain=All, model=All, group=All, atomname=All, onlyheavy=false, label=true, occupancyfilter=false)\n\nReads a LightXML.XMLDocument representing a pdb file. Returns a list of PDBResidues (view MIToS.PDB.PDBResidues). Setting chain, model, group, atomname and onlyheavy values can be used to select of a subset of all residues. If not set, all residues are returned. If the keyword argument label (default: true) is false,the auth_ attributes will be use instead of the label_ attributes for chain, atom and residue name fields. The auth_ attributes are alternatives provided by an author in order to match the identification/values used in the publication that describes the structure. If the keyword argument occupancyfilter (default: false) is true, only the atoms with the best occupancy are returned.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#Base.parse-Tuple{Union{IO, String}, Type{MIToS.PDB.PDBFile}}","page":"PDB","title":"Base.parse","text":"parse(io, ::Type{PDBFile}; chain=All, model=All, group=All, atomname=All, onlyheavy=false, occupancyfilter=false)\n\nReads a text file of a PDB entry. Returns a list of PDBResidue (view MIToS.PDB.PDBResidues). Setting chain, model, group, atomname and onlyheavy values can be used to select of a subset of all residues. Group can be \"ATOM\" or \"HETATM\". If not set, all residues are returned. If the keyword argument occupancyfilter (default: false) is true, only the atoms with the best occupancy are returned.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#Base.print","page":"PDB","title":"Base.print","text":"print(io, res, format::Type{PDBFile}) print(res, format::Type{PDBFile})\n\nPrint a PDBResidue or a vector of PDBResidues in PDB format.\n\n\n\n\n\n","category":"function"},{"location":"PDB_API/#MIToS.PDB.CAmatrix-Tuple{AbstractVector{MIToS.PDB.PDBResidue}}","page":"PDB","title":"MIToS.PDB.CAmatrix","text":"Returns a matrix with the x, y and z coordinates of the Cα with best occupancy for each PDBResidue of the ATOM group. If a residue doesn't have a Cα, its Cα coordinates are NaNs.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.aromatic-Tuple{MIToS.PDB.PDBResidue, MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.aromatic","text":"There's an aromatic interaction if centriods are at 6.0 Å or less.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.aromaticsulphur-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.aromaticsulphur","text":"Returns true if an sulphur and an aromatic atoms are 5.3 Å or less\"\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.atoms","page":"PDB","title":"MIToS.PDB.atoms","text":"atoms(residue_list, model, chain, group, residue, atom)\n\nThese return a vector of PDBAtoms with the selected subset of atoms. You can use the type All (default value of the positional arguments) to avoid filtering a that level.\n\n\n\n\n\n","category":"function"},{"location":"PDB_API/#MIToS.PDB.bestoccupancy-Tuple{Vector{MIToS.PDB.PDBAtom}}","page":"PDB","title":"MIToS.PDB.bestoccupancy","text":"Takes a Vector of PDBAtoms and returns a Vector of the PDBAtoms with best occupancy.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.center!-Tuple{AbstractMatrix{Float64}}","page":"PDB","title":"MIToS.PDB.center!","text":"center!(A::AbstractMatrix{Float64})\n\nTakes a set of points A as an NxD matrix (N: number of points, D: dimension). Translates A in place so that its centroid is at the origin of coordinates\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.centeredcoordinates","page":"PDB","title":"MIToS.PDB.centeredcoordinates","text":"Returns a Matrix{Float64} with the centered coordinates of all the atoms in residues. An optional positional argument CA (default: true) defines if only Cα carbons should be used to center the matrix.\n\n\n\n\n\n","category":"function"},{"location":"PDB_API/#MIToS.PDB.centeredresidues","page":"PDB","title":"MIToS.PDB.centeredresidues","text":"Returns a new Vector{PDBResidue} with the PDBResidues having centered coordinates. An optional positional argument CA (default: true) defines if only Cα carbons should be used to center the matrix.\n\n\n\n\n\n","category":"function"},{"location":"PDB_API/#MIToS.PDB.change_coordinates","page":"PDB","title":"MIToS.PDB.change_coordinates","text":"change_coordinates(residue::PDBResidue, coordinates::AbstractMatrix{Float64}, offset::Int=1)\n\nReturns a new PDBResidues with (x,y,z) from a coordinates AbstractMatrix{Float64} You can give an offset indicating in wich matrix row starts the (x,y,z) coordinates of the residue.\n\n\n\n\n\n","category":"function"},{"location":"PDB_API/#MIToS.PDB.change_coordinates-Tuple{AbstractVector{MIToS.PDB.PDBResidue}, AbstractMatrix{Float64}}","page":"PDB","title":"MIToS.PDB.change_coordinates","text":"change_coordinates(residues::AbstractVector{PDBResidue}, coordinates::AbstractMatrix{Float64})\n\nReturns a new Vector{PDBResidues} with (x,y,z) from a coordinates Matrix{Float64}\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.change_coordinates-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.Coordinates}","page":"PDB","title":"MIToS.PDB.change_coordinates","text":"change_coordinates(atom::PDBAtom, coordinates::Coordinates)\n\nReturns a new PDBAtom but with a new coordinates\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.check_atoms_for_interactions-Tuple{MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.check_atoms_for_interactions","text":"This function takes a PDBResidue and returns true only if all the atoms can be used for checking interactions.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.contact-Tuple{MIToS.PDB.Coordinates, MIToS.PDB.Coordinates, AbstractFloat}","page":"PDB","title":"MIToS.PDB.contact","text":"contact(a::Coordinates, b::Coordinates, limit::AbstractFloat)\n\nIt returns true if the distance is less or equal to the limit. It doesn't call sqrt because it does squared_distance(a,b) <= limit^2.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.contact-Tuple{MIToS.PDB.PDBResidue, MIToS.PDB.PDBResidue, AbstractFloat}","page":"PDB","title":"MIToS.PDB.contact","text":"contact(A::PDBResidue, B::PDBResidue, limit::AbstractFloat; criteria::String=\"All\")\n\nReturns true if the residues A and B are at contact distance (limit). The available distance criteria are: Heavy, All, CA, CB (CA for GLY)\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.contact-Tuple{Vector{MIToS.PDB.PDBResidue}, AbstractFloat}","page":"PDB","title":"MIToS.PDB.contact","text":"contact(residues::Vector{PDBResidue}, limit::AbstractFloat; criteria::String=\"All\")\n\nIf contact takes a Vector{PDBResidue}, It returns a matrix with all the pairwise comparisons (contact map).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.coordinatesmatrix-Tuple{MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.coordinatesmatrix","text":"Returns a matrix with the x, y, z coordinates of each atom in each PDBResidue\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.covalent-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.covalent","text":"Returns true if the distance between atoms is less than the sum of the covalentradius of each atom.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.distance-Tuple{MIToS.PDB.Coordinates, MIToS.PDB.Coordinates}","page":"PDB","title":"MIToS.PDB.distance","text":"It calculates the squared euclidean distance.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.distance-Tuple{Vector{MIToS.PDB.PDBResidue}}","page":"PDB","title":"MIToS.PDB.distance","text":"distance(residues::Vector{PDBResidue}; criteria::String=\"All\")\n\nIf distance takes a Vector{PDBResidue} returns a PairwiseListMatrix{Float64, false} with all the pairwise comparisons (distance matrix).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.disulphide-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.disulphide","text":"Returns true if two CYS's S are at 2.08 Å or less\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.downloadpdb-Union{Tuple{String}, Tuple{T}} where T<:MIToS.Utils.FileFormat","page":"PDB","title":"MIToS.PDB.downloadpdb","text":"It downloads a gzipped PDB file from PDB database. It requires a four character pdbcode. Its default format is PDBML (PDB XML) and It uses the baseurl \"http://www.rcsb.org/pdb/files/\". filename is the path/name of the output file. This function calls MIToS.Utils.download_file that calls HTTP.open. You can use keyword arguments from HTTP.request (e.g. redirect). Use the headers keyword argument to pass a Dict{String, String} with the header information.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.downloadpdbheader-Tuple{String}","page":"PDB","title":"MIToS.PDB.downloadpdbheader","text":"It downloads a JSON file containing the PDB header information.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.findCB-Tuple{MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.findCB","text":"Returns a vector of indices for CB (CA for GLY)\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.findatoms-Tuple{Vector{MIToS.PDB.PDBAtom}, String}","page":"PDB","title":"MIToS.PDB.findatoms","text":"findatoms(res::PDBResidue, atom::String)\n\nReturns a index vector of the atoms with the given atom name.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.findheavy-Tuple{Vector{MIToS.PDB.PDBAtom}}","page":"PDB","title":"MIToS.PDB.findheavy","text":"Returns a list with the index of the heavy atoms (all atoms except hydrogen) in the PDBResidue\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.getCA-Tuple{MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.getCA","text":"Returns the Cα with best occupancy in the PDBResidue.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.getpdbdescription-Tuple{String}","page":"PDB","title":"MIToS.PDB.getpdbdescription","text":"Access general information about a PDB entry (e.g., Header information) using the GraphQL interface of the PDB database. It parses the JSON answer into a Dict.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.hydrogenbond-Tuple{MIToS.PDB.PDBResidue, MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.hydrogenbond","text":"This function only works if there are hydrogens in the structure. The criteria for a hydrogen bond are:\n\nd(Ai, Aj) < 3.9Å\nd(Ah, Aacc) < 2.5Å\nθ(Adon, Ah, Aacc) > 90°\nθ(Adon, Aacc, Aacc-antecedent) > 90°\nθ(Ah, Aacc, Aacc-antecedent) > 90°\n\nWhere Ah is the donated hydrogen atom, Adon is the hydrogen bond donor atom, Aacc is the hydrogen bond acceptor atom and Aacc-antecednt is the atom antecedent to the hydrogen bond acceptor atom.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.hydrophobic-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.hydrophobic","text":"There's an hydrophobic interaction if two hydrophobic atoms are at 5.0 Å or less.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.ionic-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.ionic","text":"There's an ionic interaction if a cationic and an anionic atoms are at 6.0 Å or less.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.isanionic-Tuple{MIToS.PDB.PDBAtom, String}","page":"PDB","title":"MIToS.PDB.isanionic","text":"Returns true if the atom, e.g. (\"GLU\",\"CD\"), is an anionic atom in the residue.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.isaromatic-Tuple{MIToS.PDB.PDBAtom, String}","page":"PDB","title":"MIToS.PDB.isaromatic","text":"Returns true if the atom, e.g. (\"HIS\",\"CG\"), is an aromatic atom in the residue.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.isatom-Tuple{MIToS.PDB.PDBAtom, Any}","page":"PDB","title":"MIToS.PDB.isatom","text":"It tests if the atom has the indicated atom name.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.iscationic-Tuple{MIToS.PDB.PDBAtom, String}","page":"PDB","title":"MIToS.PDB.iscationic","text":"Returns true if the atom, e.g. (\"ARG\",\"NE\"), is a cationic atom in the residue.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.ishbondacceptor-Tuple{MIToS.PDB.PDBAtom, String}","page":"PDB","title":"MIToS.PDB.ishbondacceptor","text":"Returns true if the atom, e.g. (\"ARG\",\"O\"), is an acceptor in H bonds.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.ishbonddonor-Tuple{MIToS.PDB.PDBAtom, String}","page":"PDB","title":"MIToS.PDB.ishbonddonor","text":"Returns true if the atom, e.g. (\"ARG\",\"N\"), is a donor in H bonds.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.isresidue-Tuple{MIToS.PDB.PDBResidueIdentifier, Any, Any, Any, Any}","page":"PDB","title":"MIToS.PDB.isresidue","text":"It tests if the PDB residue has the indicated model, chain, group and residue number.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.kabsch-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"PDB","title":"MIToS.PDB.kabsch","text":"kabsch(A::AbstractMatrix{Float64}, B::AbstractMatrix{Float64})\n\nThis function takes two sets of points, A (refrence) and B as NxD matrices, where D is the dimension and N is the number of points. Assumes that the centroids of A and B are at the origin of coordinates. You can call center! on each matrix before calling kabsch to center the matrices in the (0.0, 0.0, 0.0). Rotates B so that rmsd(A,B) is minimized. Returns the rotation matrix. You should do B * RotationMatrix to get the rotated B.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.mean_coordinates-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractMatrix{Float64}","page":"PDB","title":"MIToS.PDB.mean_coordinates","text":"Calculates the average/mean position of each atom in a set of structure. The function takes a vector (AbstractVector) of vectors (AbstractVector{PDBResidue}) or matrices (AbstractMatrix{Float64}) as first argument. As second (optional) argument this function can take an AbstractVector{Float64} of matrix/structure weights to return a weighted mean. When a AbstractVector{PDBResidue} is used, if the keyword argument calpha is false the RMSF is calculated for all the atoms. By default only alpha carbons are used (default: calpha=true).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.pication-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.pication","text":"There's a Π-Cation interaction if a cationic and an aromatic atoms are at 6.0 Å or less\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.proximitymean-Union{Tuple{T}, Tuple{Vector{MIToS.PDB.PDBResidue}, AbstractVector{T}}, Tuple{Vector{MIToS.PDB.PDBResidue}, AbstractVector{T}, T}} where T<:AbstractFloat","page":"PDB","title":"MIToS.PDB.proximitymean","text":"proximitymean calculates the proximity mean/average for each residue as the average score (from a scores list) of all the residues within a certain physical distance to a given amino acid. The score of that residue is not included in the mean unless you set include to true. The default values are 6.05 for the distance threshold/limit and \"Heavy\" for the criteria keyword argument. This function allows to calculate pMI (proximity mutual information) and pC (proximity conservation) as in Buslje et. al. 2010.\n\nBuslje, Cristina Marino, Elin Teppa, Tomas Di Doménico, José María Delfino, and Morten Nielsen. Networks of high mutual information define the structural proximity of catalytic sites: implications for catalytic residue identification. PLoS Comput Biol 6, no. 11 (2010): e1000978.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.residuepairsmatrix-Union{Tuple{diagonal}, Tuple{T}, Tuple{Vector{MIToS.PDB.PDBResidue}, Type{T}, Type{Val{diagonal}}, T}} where {T, diagonal}","page":"PDB","title":"MIToS.PDB.residuepairsmatrix","text":"It creates a NamedArray containing a PairwiseListMatrix where each element (column, row) is identified with a PDBResidue from the input vector. You can indicate the value type of the matrix (default to Float64), if the list should have the diagonal values (default to Val{false}) and the diagonal values (default to NaN).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.residues-Union{Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}}, Tuple{N}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any, Any}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any, Any, Any}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any, Any, Any, Any}} where N","page":"PDB","title":"MIToS.PDB.residues","text":"residues(residue_list, model, chain, group, residue)\n\nThese return a new vector with the selected subset of residues from a list of residues. You can use the type All (default value) to avoid filtering a that level.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.residuesdict-Union{Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}}, Tuple{N}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any, Any}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any, Any, Any}, Tuple{AbstractArray{MIToS.PDB.PDBResidue, N}, Any, Any, Any, Any}} where N","page":"PDB","title":"MIToS.PDB.residuesdict","text":"residuesdict(residue_list, model, chain, group, residue)\n\nThese return a dictionary (using PDB residue numbers as keys) with the selected subset of residues. You can use the type All (default value) to avoid filtering a that level.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.rmsd-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"PDB","title":"MIToS.PDB.rmsd","text":"rmsd(A::AbstractMatrix{Float64}, B::AbstractMatrix{Float64})\n\nReturn RMSD between two sets of points A and B, given as NxD matrices (N: number of points, D: dimension).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.rmsd-Tuple{AbstractVector{MIToS.PDB.PDBResidue}, AbstractVector{MIToS.PDB.PDBResidue}}","page":"PDB","title":"MIToS.PDB.rmsd","text":"rmsd(A::AbstractVector{PDBResidue}, B::AbstractVector{PDBResidue}; superimposed::Bool=false)\n\nReturns the Cα RMSD value between two PDB structures: A and B. If the structures are already superimposed between them, use superimposed=true to avoid a new superimposition (superimposed is false by default).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.rmsf-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractMatrix{Float64}","page":"PDB","title":"MIToS.PDB.rmsf","text":"Calculates the RMSF (Root Mean-Square-Fluctuation) between an atom and its average position in a set of structures. The function takes a vector (AbstractVector) of vectors (AbstractVector{PDBResidue}) or matrices (AbstractMatrix{Float64}) as first argument. As second (optional) argument this function can take an AbstractVector{Float64} of matrix/structure weights to return the root weighted mean-square-fluctuation around the weighted mean structure. When a Vector{PDBResidue} is used, if the keyword argument calpha is false the RMSF is calculated for all the atoms. By default only alpha carbons are used (default: calpha=true).\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.selectbestoccupancy-Tuple{Vector{MIToS.PDB.PDBAtom}, Vector{Int64}}","page":"PDB","title":"MIToS.PDB.selectbestoccupancy","text":"Takes a PDBResidue and a Vector of atom indices. Returns the index value of the Vector with maximum occupancy.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.squared_distance-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom}","page":"PDB","title":"MIToS.PDB.squared_distance","text":"It calculates the squared euclidean distance, i.e. it doesn't spend time in sqrt\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.squared_distance-Tuple{MIToS.PDB.PDBResidue, MIToS.PDB.PDBResidue}","page":"PDB","title":"MIToS.PDB.squared_distance","text":"squared_distance(A::PDBResidue, B::PDBResidue; criteria::String=\"All\")\n\nReturns the squared distance between the residues A and B. The available criteria are: Heavy, All, CA, CB (CA for GLY)\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.superimpose","page":"PDB","title":"MIToS.PDB.superimpose","text":"Asuper, Bsuper, RMSD = superimpose(A, B, matches=nothing)\n\nThis function takes A::AbstractVector{PDBResidue} (reference) and B::AbstractVector{PDBResidue}. Translates A and B to the origin of coordinates, and rotates B so that rmsd(A,B) is minimized with the Kabsch algorithm (using only their α carbons). Returns the rotated and translated versions of A and B, and the RMSD value.\n\nOptionally provide matches which iterates over matched index pairs in A and B, e.g., matches = [(3, 5), (4, 6), ...]. The alignment will be constructed using just the matching residues.\n\n\n\n\n\n","category":"function"},{"location":"PDB_API/#MIToS.PDB.vanderwaals-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.vanderwaals","text":"Test if two atoms or residues are in van der Waals contact using: distance(a,b) <= 0.5 + vanderwaalsradius[a] + vanderwaalsradius[b]. It returns distance <= 0.5 if the atoms aren't in vanderwaalsradius.\n\n\n\n\n\n","category":"method"},{"location":"PDB_API/#MIToS.PDB.vanderwaalsclash-Tuple{MIToS.PDB.PDBAtom, MIToS.PDB.PDBAtom, Any, Any}","page":"PDB","title":"MIToS.PDB.vanderwaalsclash","text":"Returns true if the distance between the atoms is less than the sum of the vanderwaalsradius of the atoms. If the atoms aren't on the list (i.e. OXT), the vanderwaalsradius of the element is used. If there is not data in the dict, distance 0.0 is used.\n\n\n\n\n\n","category":"method"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"EditURL = \"https://github.com/diegozea/MIToS.jl/blob/master/docs/src/cookbook/01_Change_B_factors.jl\"","category":"page"},{"location":"01_Change_B_factors/#Change-B-factors","page":"Change B-factors","title":"Change B-factors","text":"","category":"section"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"(Image: ) (Image: )","category":"page"},{"location":"01_Change_B_factors/#Problem-description","page":"Change B-factors","title":"Problem description","text":"","category":"section"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"It is a common practice to change the B-factors of a PDB to store information about atoms or residues to be used by other programs. In particular, values in the B-factor column can be easily used to colour residues with PyMOL or Chimera.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"We cannot simply assign a new value to the B field of a PDBAtom because this type is immutable. However, we can make use of the @set macro of the Setfield package to create a new PDBAtom with a different B-factor value.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"In a PDB file, B-factors are stored from the column 61 to 66. Therefore, new B-factors should be a String with 6 or fewer characters, normally using two characters for decimal values. We can use fmt and FormatSpec from the Formatting package to create a proper B-factor string.","category":"page"},{"location":"01_Change_B_factors/#MIToS-solution","page":"Change B-factors","title":"MIToS solution","text":"","category":"section"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"For this example we are going to use the small heat shock protein AgsA from Salmonella typhimurium (PDB code: 4ZJ9) available in MIToS docs data:","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"using MIToS\npdbfile = abspath(pathof(MIToS), \"..\", \"..\", \"docs\", \"data\", \"4zj9.pdb\")\nnothing # hide","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"First, we need to read the PDB file using the MIToS.PDB module:","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"using MIToS.PDB\npdb_residues = read(pdbfile, PDBFile)\nnothing # hide","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"For this example, we are going to replace the B-factor of the alpha-carbons by the residue hydrophobicity according to the hydrophobicity scale of Kyte and Doolittle used by Chimera:","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"hydrophobicity = Dict(\n\t\"ILE\" => 4.5,\n\t\"VAL\" => 4.2,\n\t\"LEU\" => 3.8,\n\t\"PHE\" => 2.8,\n\t\"CYS\" => 2.5,\n\t\"MET\" => 1.9,\n\t\"ALA\" => 1.8,\n\t\"GLY\" => -0.4,\n\t\"THR\" => -0.7,\n\t\"SER\" => -0.8,\n\t\"TRP\" => -0.9,\n\t\"TYR\" => -1.3,\n\t\"PRO\" => -1.6,\n\t\"HIS\" => -3.2,\n\t\"GLU\" => -3.5,\n\t\"GLN\" => -3.5,\n\t\"ASP\" => -3.5,\n\t\"ASN\" => -3.5,\n\t\"LYS\" => -3.9,\n\t\"ARG\" => -4.5 )\nnothing # hide","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"First, we define a helper function using Formatting to create a proper B-factor string with the PDB format; 6 characters and 2 digits after the decimal point. The PDB format description describe this field as:","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"COLUMNS      DATA TYPE        FIELD      DEFINITION\n------------------------------------------------------\n61 - 66      Real(6.2)        tempFactor Temperature factor.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"using Formatting\n\n\"Return value as a string with the B factor format described in PDB.\"\nformat_b_factor(value) = fmt(FormatSpec(\"6.2f\"), value) # e.g. 1.5 -> \"  1.50\"\nnothing # hide","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"Then, where are using that helper function to define a function that returns a new PDBAtom by changing the B factor field using the Setfield package.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"using Setfield\n\n\"Return a new PDBAtom with the B-factor changed to value.\"\nfunction change_b_factor(atom::PDBAtom, value)\n\tb_factor_string = format_b_factor(value)\n\tb_factor_string = strip(b_factor_string) # e.g. \"  1.50\" -> \"1.50\"\n\tif length(b_factor_string) > 6\n\t\tthrow(ErrorException(\"$b_factor_string has more than 6 characters.\"))\n\tend\n\t@set atom.B = b_factor_string\nend\nnothing # hide","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"Now, we can use the change_b_factor function to change the B-factor of each \"CA\" atom:","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"for res in pdb_residues\n\tfor i in eachindex(res.atoms)\n\t\tatom = res.atoms[i]\n\t\tif atom.atom == \"CA\"\n\t\t\tres.atoms[i] = change_b_factor(atom, hydrophobicity[res.id.name])\n\t\tend\n\tend\nend","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"Finally, we can save the changed residues in a new PDB file.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"write(\"4zj9_hydrophobicity.pdb\", pdb_residues, PDBFile)","category":"page"},{"location":"01_Change_B_factors/#Discussion","page":"Change B-factors","title":"Discussion","text":"","category":"section"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"While we have focused on changing the B-factor field of a PDBAtom, you can use the same approach to change other fields. However, if you want to change atom coordinates, it is better to use the change_coordinates function from the PDB module of MIToS.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"MIToS atoms and residues generally stores the string present in the input file without surrounding spaces. You can use the Formatting module to create these strings and strip to get rid of the spaces. You can see the PDB format description to know what is the format of the expected string or see the MIToS PDB print source code to get a quick idea.","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"","category":"page"},{"location":"01_Change_B_factors/","page":"Change B-factors","title":"Change B-factors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"@info \"Example\"","category":"page"},{"location":"Example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"Example/","page":"Example","title":"Example","text":"In this simple demonstration, you will see how to calculate ZBLMIp (Z score of the corrected MIp using BLOSUM62 pseudo frequencies) for a Pfam(Image: ) MSA from the Julia REPL or using a MIToS script in the system command line.  ","category":"page"},{"location":"Example/#juliarepl","page":"Example","title":"MIToS in the Julia REPL","text":"","category":"section"},{"location":"Example/","page":"Example","title":"Example","text":"If you load the Pfam module from MIToS, you will get access to a set of functions that work with Pfam MSAs. In this case, we are going to use it for download a Stockholm(Image: ) MSA from the Pfam website and read it into Julia.  ","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"using Plots\ngr() # Just to avoid warnings in the output","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"using MIToS.Pfam\npfam_file = downloadpfam(\"PF10660\")\nmsa = read(pfam_file, Stockholm, generatemapping=true, useidcoordinates=true)","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"note: Note\nGeneration of sequence and column mappings   The keyword argument generatemapping of read allows to generate sequence and column mappings for the MSA. Column mapping is the map between of each column on the MSA object and the column number in the file. Sequence mappings will use the start and end coordinates in the sequence ids for enumerate each residue in the sequence if useidcoordinates is true.  ","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"You can plot this MSA and other MIToS’ objects using the Plots(Image: ) package. The installation of Plots is described in the Installation section of this site:","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"using Plots\ngr()\nplot(msa)\npng(\"msa.png\") # hide\nnothing # hide","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"(Image: )  ","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"The Information module of MIToS has functions to calculate measures from the Information Theory(Image: ), such as Entropy and Mutual Information (MI), on a MSA. In this example, we will estimate covariation between columns of the MSA with a corrected MI that use the BLOSUM62 matrix for calculate pseudo frequencies (BLMI).  ","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"using MIToS.Information\nZBLMIp, BLMIp = BLMI(msa)\nZBLMIp # shows ZBLMIp scores","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"Once the Plots package is installed and loaded, you can use its capabilities to visualize this results:","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"heatmap(ZBLMIp, yflip=true, c=:grays)\npng(\"blmi.png\") # hide\nnothing # hide","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"(Image: )  ","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"rm(pfam_file) # clean up","category":"page"},{"location":"Example/#commandline","page":"Example","title":"MIToS in system command line","text":"","category":"section"},{"location":"Example/","page":"Example","title":"Example","text":"Calculate ZBLMIp on the system shell is easy using the MIToS script called BLMI.jl. This script reads a MSA file, and writes a file with the same base name of the input but with the .BLMI.csv extension.  ","category":"page"},{"location":"Example/","page":"Example","title":"Example","text":"BLMI.jl PF14972.stockholm.gz","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"@info \"PDB docs\"","category":"page"},{"location":"PDB/#Module-PDB","page":"PDB","title":"PDB","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"The module PDB defines types and methods to work with protein structures inside Julia. It is useful to link structural and sequential information, and needed for measure the predictive performance at protein contact prediction of mutual information scores.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"using MIToS.PDB # to load the PDB module","category":"page"},{"location":"PDB/#Features","page":"PDB","title":"Features","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"Read and parse PDB and PDBML files.\nCalculate distance and contacts between atoms or residues.\nDetermine interaction between residues.","category":"page"},{"location":"PDB/#Contents","page":"PDB","title":"Contents","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"Pages = [\"PDB.md\"]\nDepth = 4","category":"page"},{"location":"PDB/#Retrieve-information-from-PDB-database","page":"PDB","title":"Retrieve information from PDB database","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"This module exports the downloadpdb function, to retrieve a PDB file from   PDB database(Image: ). This function downloads a gzipped PDBML file, which could be easily read it with MIToS by default, but you are able to determine the format as PDBFile if you want it.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"using MIToS.PDB\n\npdbfile = downloadpdb(\"1IVO\", format=PDBFile)","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"PDB module also exports a getpdbdescription to access the header information of a PDB entry.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"getpdbdescription(\"1IVO\")","category":"page"},{"location":"PDB/#Read-and-parse-PDB-files","page":"PDB","title":"Read and parse PDB files","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"This is easy using the read and parse functions, indicating the filename and the FileFormat: PDBML for PDB XML files or PDBFile for usual PDB files. These functions returns a Vector of PDBResidue objects with all the residues in the PDB.   To return only a specific subset of residues/atoms you can use any of the following keyword arguments:  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"keyword arguments default returns only ...\nchain All residues from a PDB chain, i.e. \"A\"\nmodel All residues from a determined model, i.e. \"1\"\ngroup All residues from a group: \"ATOM\", \"HETATM\" or All for both\natomname All atoms with a specific name, i.e. \"CA\"\nonlyheavy false heavy atoms (not hydrogens) if it's true\noccupancyfilter false only the atoms with the best occupancy are returned if it's true","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"note: Note\nFor PDBML files it is possible to use the keyword argument label to false (default to true) to get the auth_ attributes instead of the label_ attributes for chain, atom and residue name fields. The auth_ attributes are alternatives provided by an author in order to match the identification/values used in the publication that describes the structure.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"# Read α carbon of each residue from the 1ivo pdb file, in the model 1, chain A and in the ATOM group.\nCA_1ivo = read(pdbfile, PDBFile, model=\"1\", chain=\"A\", group=\"ATOM\", atomname=\"CA\")\n\nCA_1ivo[1] # First residue. It has only the α carbon.","category":"page"},{"location":"PDB/#Looking-for-particular-residues","page":"PDB","title":"Looking for particular residues","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"MIToS parse PDB files to vector of residues, instead of using a hierarchical structure like other packages. This approach makes the search and selection of residues or atoms a little different. To make it easy, this module exports a number of functions and macros to select particular residues or atoms. Given the fact that residue numbers from different chains, models, etc. can collide, it's mandatory to indicate the model, chain, group, residue number and atom name in a explicit way to these functions or macros. If you want to select all the residues in one of the categories, you are able to use the type All. You can also use regular expressions or functions to make the selections.","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"using MIToS.PDB\npdbfile = downloadpdb(\"1IVO\", format=PDBFile)\nresidues_1ivo = read(pdbfile, PDBFile)\n# Select residue number 9 from model 1 and chain B\nresidues(residues_1ivo, \"1\", \"B\", All, \"9\")","category":"page"},{"location":"PDB/#Getting-a-Dict-of-PDBResidues","page":"PDB","title":"Getting a Dict of PDBResidues","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"If you prefer a Dict of PDBResidue, indexed by their residue numbers, you can use the residuedict function or the @residuedict macro.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"# Dict of residues from the model 1, chain A and from the ATOM group\nchain_a = residuesdict(residues_1ivo, \"1\", \"A\", \"ATOM\", All)\nchain_a[\"9\"]","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"You can do the same with the macro @residuesdict to get a more readable code  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"chain_a = @residuesdict residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All\nchain_a[\"9\"]","category":"page"},{"location":"PDB/#Select-particular-residues","page":"PDB","title":"Select particular residues","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"Use the residues function to collect specific residues. It's possible to use a single residue number (i.e. \"2\") or even a function which should return true for the selected residue numbers. Also regular expressions can be used to select residues. Use All to select all the residues.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"residue_list = map(string, 2:5)\n\n# If the list is large, you can use a `Set` to gain performance\n# residue_set = Set(map(string, 2:5))","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"first_res = residues(residues_1ivo, \"1\", \"A\", \"ATOM\", resnum -> resnum in residue_list)\n\nfor res in first_res\n    println(res.id.name, \" \", res.id.number)\nend","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"A more complex example using an anonymous function:  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"# Select all the residues of the model 1, chain A of the ATOM group with residue number less than 5\n\nfirst_res = residues(residues_1ivo, \"1\", \"A\", \"ATOM\", x -> parse(Int, match(r\"^(\\d+)\", x)[1]) <= 5 )\n# The anonymous function takes the residue number (string) and use a regular expression\n# to extract the number (without insertion code).\n# It converts the number to `Int` to test if the it is `<= 5`.\n\nfor res in first_res\n    println(res.id.name, \" \", res.id.number)\nend","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"Use the @residues macro for a cleaner syntax.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"# You can use All, regular expressions or functions also for model, chain and group:\n\n# i.e. Takes the residue 10 from chains A and B\n\nfor res in @residues residues_1ivo model \"1\" chain ch -> ch in [\"A\",\"B\"] group \"ATOM\" residue \"10\"\n    println(res.id.chain, \" \", res.id.name, \" \", res.id.number)\nend","category":"page"},{"location":"PDB/#Select-particular-atoms","page":"PDB","title":"Select particular atoms","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"The atoms function or macro allow to select a particular set of atoms.","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"# Select all the atoms with name starting with \"C\" using a regular expression\n# from all the residues of the model 1, chain A of the ATOM group\n\ncarbons = @atoms residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All atom r\"C.+\"\n\ncarbons[1]","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"You can also use the atoms function instead of the @atoms macro:  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"atoms(residues_1ivo, \"1\", \"A\", \"ATOM\", All, r\"C.+\")[1]","category":"page"},{"location":"PDB/#Protein-contact-map","page":"PDB","title":"Protein contact map","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"The PDB module offers a number of functions to measure distances between atoms or residues, to detect possible interactions or contacts. In particular the contact function calls the distance function using a threshold or limit in an optimized way. The measure can be done between alpha carbons (\"CA\"), beta carbons (\"CB\") (alpha carbon for glycine), any heavy atom (\"Heavy\") or any (\"All\") atom of the residues.","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"In the following example, whe are going to plot a contact map for the 1ivo chain A. Two residues will be considered in contact if their β carbons (α carbon for glycine) have a distance of 8Å or less.  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"using MIToS.PDB\n\npdbfile = downloadpdb(\"1IVO\", format=PDBFile)\n\nresidues_1ivo = read(pdbfile, PDBFile)\n\npdb = @residues residues_1ivo model \"1\" chain \"A\" group \"ATOM\" residue All\n\ndmap = distance(pdb, criteria=\"All\") # Minimum distance between residues using all their atoms","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"Use the contact function to get a contact map:  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"cmap = contact(pdb, 8.0, criteria=\"CB\") # Contact map","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"@info \"PDB: Cmap\"\nusing Plots\ngr() # Hide possible warnings","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"using Plots\ngr()\n\nheatmap(dmap, grid=false, yflip=true, ratio=:equal)\n\npng(\"pdb_dmap.png\") # hide\nnothing # hide","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"(Image: )  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"heatmap(cmap, grid=false, yflip=true, ratio=:equal)\n\npng(\"pdb_cmap.png\") # hide\nnothing # hide","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"(Image: )  ","category":"page"},{"location":"PDB/#Structural-superposition","page":"PDB","title":"Structural superposition","text":"","category":"section"},{"location":"PDB/","page":"PDB","title":"PDB","text":"@info \"PDB: RMSD\"\nusing Plots\ngr() # Hide possible warnings","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"using MIToS.PDB\n\npdbfile = downloadpdb(\"2HHB\")\n\nres_2hhb = read(pdbfile, PDBML)\n\nchain_A = pdb = @residues res_2hhb model \"1\" chain \"A\" group \"ATOM\" residue All\nchain_C = pdb = @residues res_2hhb model \"1\" chain \"C\" group \"ATOM\" residue All\n\nusing Plots\ngr()\n\nscatter3d(chain_A, label=\"A\", alpha=0.5)\nscatter3d!(chain_C, label=\"C\", alpha=0.5)\n\npng(\"pdb_unaligned.png\") # hide\nnothing # hide","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"(Image: )  ","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"superimposed_A, superimposed_C, RMSD = superimpose(chain_A, chain_C)\n\nRMSD","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"scatter3d(superimposed_A, label=\"A\", alpha=0.5)\nscatter3d!(superimposed_C, label=\"C\", alpha=0.5)\npng(\"pdb_aligned.png\") # hide\nnothing # hide","category":"page"},{"location":"PDB/","page":"PDB","title":"PDB","text":"(Image: )  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"@info \"Pfam docs\"","category":"page"},{"location":"Pfam/#Module-Pfam","page":"Pfam","title":"Pfam","text":"","category":"section"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"MIToS defines methods and types useful for any MSA. The Pfam module uses other MIToS modules in the context of Pfam MSAs, where it’s possible to us determine how structure and sequence information should be mapped. This module defines functions that go from a Pfam MSA to the protein contact prediction performance of pairwise scores estimated from that MSA.","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"using MIToS.Pfam # to load the Pfam module","category":"page"},{"location":"Pfam/#Features","page":"Pfam","title":"Features","text":"","category":"section"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"Download and read Pfam MSAs.\nObtain PDB information from alignment annotations.\nMap between sequence/alignment residues/columns and PDB structures.\nMeasure of AUC (ROC curve) for protein contact prediction of MI scores.","category":"page"},{"location":"Pfam/#Contents","page":"Pfam","title":"Contents","text":"","category":"section"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"Pages = [\"Pfam.md\"]\nDepth = 4","category":"page"},{"location":"Pfam/#Getting-a-Pfam-MSA","page":"Pfam","title":"Getting a Pfam MSA","text":"","category":"section"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"The function downloadpfam takes a Pfam accession and downloads a Pfam MSA in Stockholm format. In that way, you can do","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"pfamfile = downloadpfam(\"PF18883\")","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"to get the MSA. But, we are going to use an already downloaded file in this case:","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"using MIToS\npfamfile = joinpath(dirname(pathof(MIToS)), \"..\", \"docs\", \"data\", \"PF18883.stockholm.gz\");","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"Use read function and the Stockholm FileFormat to get a AnnotatedMultipleSequenceAlignment object with the MSA and its Pfam annotations. You must set generatemapping and useidcoordinates to true the first time you read the downloaded MSA. This is necessary to some of the methods in the Pfam module.  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"msa = read(pfamfile, Stockholm, generatemapping=true, useidcoordinates=true)","category":"page"},{"location":"Pfam/#Getting-PDB-information-from-an-MSA","page":"Pfam","title":"Getting PDB information from an MSA","text":"","category":"section"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"The function getseq2pdb parses the MSA annotations to return a Dict from the sequence identifier in the MSA to PDB and chain codes.  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"getseq2pdb(msa)","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"Once you know the association between PDB chains and sequences, you can use that information together with the msacolumn2pdbresidue function to get the PDB residue number that correspond to each MSA column for given a determined sequence and PDB chain. That function downloads information from SIFTS to generate the mapping.  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"col2res = msacolumn2pdbresidue(msa, \"ICSA_SHIFL/611-720\", \"3ML3\", \"A\")","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"The returned dictionary can be used to get the PDB residue associated to each column (using the msaresidues function)...  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"using MIToS.PDB\npdbfile = downloadpdb(\"3ML3\")\npdb = read(pdbfile, PDBML)\nresdict = @residuesdict pdb model \"1\" chain \"A\" group \"ATOM\" residue All\n\nmsaresidues(msa, resdict, col2res)","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"...or to delete the columns without PDB residues (using the hasresidues function):  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"using MIToS.MSA\nfiltercolumns!(msa, hasresidues(msa, col2res))","category":"page"},{"location":"Pfam/#PDB-contacts-and-AUC","page":"Pfam","title":"PDB contacts and AUC","text":"","category":"section"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"The Dict between MSA columns and PDB residue number also can be used to generate a protein contact map associated to the MSA.  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"cmap = msacontacts(msa, resdict, col2res)","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"That protein contact map can be used to calculate the Area Under the ROC Curve for a given score with the AUC function.  ","category":"page"},{"location":"Pfam/","page":"Pfam","title":"Pfam","text":"using MIToS.Information\nZMIp, MIp = buslje09(msa)\n\nusing ROCAnalysis # You need to load ROCAnalysis to use the AUC function\n\nAUC(ZMIp, cmap)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"EditURL = \"https://github.com/diegozea/MIToS.jl/blob/master/docs/src/cookbook/02_Linking_structural_and_evolutionary_information.jl\"","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/#Linking-structural-and-evolutionary-information","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"","category":"section"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"(Image: ) (Image: )","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/#Problem-description","page":"Linking structural and evolutionary information","title":"Problem description","text":"","category":"section"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"It is a very common task to map sequence to structure residue number. For example, to link structural information coming from PDB and evolutionary information calculated from multiple sequence alignments.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"The naive way of mapping sequence and structure is to perform global pairwise alignment between the sequence and the PDB sequence (using the residues in ATOM). The problem with this approach is that the sequences can have missing regions and standard pairwise alignment algorithms often yield incorrect assignations around those regions (Velankar et.al. 2013). This is particularly important when aligning PDB sequences, that can have missing residues, and sequences coming from multiple sequence alignments, that can be incomplete or have unaligned regions (e.g. insert states).","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"The SIFTS (Structure Integration with Function, Taxonomy and Sequences) database solves this problem and provides residue level mapping between PDB and other databases (e.g. UniProt and Pfam).","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"The SIFTS module of MIToS has functions to access this residue level mapping between PDB and other databases. Also, MIToS keeps track of the residue number of each residue in a multiple sequence alignment (MSA) using its annotations. Both things together, allow the correct mapping of sequence and structure without performing error-prone pairwise alignments.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"Particular solutions depend on problem details, here we show some common ways to use MIToS and SIFTS to map evolutionary information calculated in an MSA (e.g. entropy) with structural information (e.g. B-factors).","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/#PDB-and-Pfam-alignment-mapping","page":"Linking structural and evolutionary information","title":"PDB and Pfam alignment mapping","text":"","category":"section"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"This is the easiest problem to solve with the MIToS Pfam module because SIFTS already has a residue level mapping between PDB and Pfam.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"For this example, we are going to map the columns in the multiple sequence alignment of the PF09645 Pfam family and the residues in the chain A from the 2VQC PDB file. The needed files are available in the MIToS test suite:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS\npdb_file   = abspath(pathof(MIToS), \"..\", \"..\", \"test\", \"data\", \"2VQC.pdb\")\npfam_file  = abspath(pathof(MIToS), \"..\", \"..\", \"test\", \"data\", \"PF09645_full.stockholm\")\nsifts_file = abspath(pathof(MIToS), \"..\", \"..\", \"test\", \"data\", \"2vqc.xml.gz\")\nnothing # hide","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"You can also use downloadpdb from MIToS.PDB, downloadpfam from MIToS.Pfam and downloadsifts from MIToS.SIFTS to get the corresponding files from those databases.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"It is important to read the Pfam MSA file using generatemapping=true and useidcoordinates=true because that allows keeping track of the residue number using the MSA annotations.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS.Pfam\nmsa = read(pfam_file, Stockholm, generatemapping=true, useidcoordinates=true)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"First, we need to know what is the sequence in the MSA that correspond to the PDB we want to link. Luckily, Pfam Stockholm files store the mapping between sequences and PDB chains. You can access that mapping using the getseq2pdb function from MIToS.Pfam","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"seq2pdbs = getseq2pdb(msa)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"The returned dictionary gives you all the PDB chains associated with a determined sequence in the MSA. But, in this case, we want to go in the other direction to find all the sequences associated with a determined PDB chain. We are going to use a list comprehension because it is possible for a single chain to be associated with more than one sequence in the Pfam MSA (e.g. domain repeats).","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"pdb_code  = \"2VQC\"\npdb_chain = \"A\"\nseq_ids = [ seq for (seq, pdbs) in seq2pdbs if (pdb_code, pdb_chain) in pdbs ]","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"In this example, we are going to use the only sequence we found for the A of 2VQC.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"seq_id = seq_ids[1]","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"Finally, we can use the msacolumn2pdbresidue function from the Pfam module to get a dictionary from the MSA column index to the PDB residue number:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"pfam_id = \"PF09645\"\nmsacol2pdbres = msacolumn2pdbresidue(msa, seq_id, pdb_code, pdb_chain, pfam_id, sifts_file)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"This dictionary has the mapping between MSA column and PDB residue that allows the mapping between evolutionary and structural information. For example, to measure the correlation between entropy (related to residue variation in an MSA column) and the mean B factor of the residue:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS.Information\nHx = mapcolfreq!(entropy,\n\t\t\t\t msa,\n\t\t\t\t Counts(ContingencyTable(Int, Val{1}, UngappedAlphabet())))","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"To get quick access to each PDB residue based on its residue number, we can read the PDB file into a dictionary using the read and residuesdict functions from the MIToS PDB module:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS.PDB\nres_dict = residuesdict(read(pdb_file, PDBFile, occupancyfilter=true), \"1\", \"A\") # model 1 chain A","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"Then, we can iterate the mapping dictionary to link the MSA and PDB based values:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using Statistics\n\nx = Float64[]\ny = Float64[]\n\nfor (col_index, res_number) in msacol2pdbres\n\tif res_number != \"\" # i.e. MSA column has an associated PDB residue\n\t\tpush!(x, Hx[col_index])\n\t\tpush!(y, mean(parse(Float64, atom.B) for atom in res_dict[res_number].atoms))\n\tend\nend\n\ncor(x, y)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/#Unknown-sequence-coordinates","page":"Linking structural and evolutionary information","title":"Unknown sequence coordinates","text":"","category":"section"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"While Pfam alignments have the start and end of the aligned region indicated in the sequence name, other multiple sequence alignments don't give any hint about that. In those cases, we should use pairwise alignments. However, instead of aligning the sequence coming from the MSA and the PDB sequence, we can align the MSA sequence to the UniProt sequence to reduce the possibility of mapping errors. Once we have the mapping of the MSA sequence to the UniProt sequence, we can use SIFTS to map the PDB sequence to the MSA sequence using the UniProt numeration.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"For this example, we are going to use the following files included in MIToS documentation:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS\npdb_file   = abspath(pathof(MIToS), \"..\", \"..\", \"docs\", \"data\", \"1dur.pdb\")\nmsa_file   = abspath(pathof(MIToS), \"..\", \"..\", \"docs\", \"data\", \"blast_alignment.fa\")\nsifts_file = abspath(pathof(MIToS), \"..\", \"..\", \"docs\", \"data\", \"1dur.xml.gz\")\nuniprot_file = abspath(pathof(MIToS), \"..\", \"..\", \"docs\", \"data\", \"P00193.fasta\")\nnothing # hide","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"First, we are going to read the MSA file. In this case, we can not use useidcoordinates=true because the sequence names don't have the sequence coordinates in the Pfam format. However, we are going to use generatemapping=true to get the default mapping for each sequence in the alignment (from 1 to the length of the aligned region):","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS.MSA\nmsa = read(msa_file, FASTA, generatemapping=true)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"After that, we get the first sequence of the MSA, the one we know that corresponds to the PDB of interest. We need the sequence as a String without gaps (unaligned), so we use the MIToS.MSA stringsequence function together with replace:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"msa_seq = replace(stringsequence(msa, 1), '-' => \"\")","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"Also, we are going to read the UniProt sequence. You can easily download the sequence from UniProt by doing:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS.Utils\ndownload_file(\"https://www.uniprot.org/uniprot/P00193.fasta\", \"P00193.fasta\")","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"To read the FASTA file we are going to use the FastaIO package:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using FastaIO\nuniprot_sequences = readfasta(uniprot_file)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"And get the unique sequence:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"uniprot_seq = uniprot_sequences[1][2]","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"We can perform a pairwise sequence alignment between both sequences by using the BioAlignments package from the BioJulia suite. In this case, we use a semi-global alignment (no start/end gap penalty) because we know that the MSA sequence is a region of the UniProt sequence.","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using BioAlignments\ncostmodel = AffineGapScoreModel(BLOSUM62, gap_open=-10, gap_extend=-1)\naln = pairalign(SemiGlobalAlignment(), msa_seq, uniprot_seq, costmodel)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"Then, we only need to iterate the alignment to designate the positions and store the equivalences in a dictionary:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"function seq2refnumber(aln)\n    seq_pos = 0\n\tref_pos = 0\n\tlast_seq_pos = 0\n\tseq2ref = Dict{Int,Int}()\n    for (seq_res, ref_res) in alignment(aln)\n        if seq_res != '-'\n            seq_pos += 1\n\t\tend\n        if ref_res != '-'\n            ref_pos += 1\n\t\tend\n\t\tif seq_pos != last_seq_pos\n\t\t\tseq2ref[seq_pos] = ref_pos\n\t\t\tlast_seq_pos = seq_pos\n    \tend\n\tend\n    seq2ref\nend\n\nseqnum2uniprotnum = seq2refnumber(aln)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"Then, we can use getsequencemapping to go from MSA column number to UniProt residue, and siftsmapping to go from UniProt to PDB:","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"seqmap = getsequencemapping(msa, 1)","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"colnum2uniprotnum = Dict{Int,Int}()\nfor (colnum, seqnum) in enumerate(seqmap)\n\tif seqnum != 0 # getsequencemapping returns 0 where there is a gap\n\t\tcolnum2uniprotnum[colnum] = seqnum2uniprotnum[seqnum]\n\tend\nend\ncolnum2uniprotnum","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"using MIToS.SIFTS\n\nuniprotnum2pdbnum = siftsmapping(sifts_file,\n    dbUniProt,\n    \"P00193\",\n    dbPDB,\n    \"1dur\", # SIFTS stores PDB identifiers in lowercase\n    chain=\"A\",\n    missings=false) # residues without coordinates aren't used in the mapping","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"To finally get the dictionary from MSA column index to PDB residue number","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"colnum2pdbnum = Dict{Int,String}()\nfor (colnum, uniprotnum) in colnum2uniprotnum\n\tpdbresnum = get(uniprotnum2pdbnum, string(uniprotnum), \"\")\n\tif pdbresnum != \"\"\n\t\tcolnum2pdbnum[colnum] = pdbresnum\n\tend\nend\n\ncolnum2pdbnum","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"","category":"page"},{"location":"02_Linking_structural_and_evolutionary_information/","page":"Linking structural and evolutionary information","title":"Linking structural and evolutionary information","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Information_API/","page":"Information","title":"Information","text":"@info \"Information API docs\"","category":"page"},{"location":"Information_API/#Information","page":"Information","title":"Information","text":"","category":"section"},{"location":"Information_API/","page":"Information","title":"Information","text":"MIToS.Information","category":"page"},{"location":"Information_API/#MIToS.Information","page":"Information","title":"MIToS.Information","text":"The Information module of MIToS defines types and functions useful to calculate information measures (e.g. Mutual Information (MI) and Entropy) over a Multiple Sequence Alignment (MSA). This module was designed to count Residues (defined in the MSA module) in special contingency tables (as fast as possible) and to derive probabilities from this counts. Also, includes methods for applying corrections to that tables, e.g. pseudocounts and pseudo frequencies. Finally, Information allows to use this probabilities and counts to estimate information measures and other frequency based values.\n\nFeatures\n\nEstimate multi dimensional frequencies and probabilities tables from sequences, MSAs, etc...\nCorrection for small number of observations\nCorrection for data redundancy on a MSA\nEstimate information measures\nCalculate corrected mutual information between residues\n\nusing MIToS.Information\n\n\n\n\n\n","category":"module"},{"location":"Information_API/#Contents","page":"Information","title":"Contents","text":"","category":"section"},{"location":"Information_API/","page":"Information","title":"Information","text":"Pages = [\"Information_API.md\"]\nDepth = 2","category":"page"},{"location":"Information_API/#Types","page":"Information","title":"Types","text":"","category":"section"},{"location":"Information_API/","page":"Information","title":"Information","text":"Modules = [MIToS.Information]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"Information_API/#MIToS.Information.AdditiveSmoothing","page":"Information","title":"MIToS.Information.AdditiveSmoothing","text":"Additive Smoothing or fixed pseudocount λ for ResidueCount (in order to estimate probabilities when the number of samples is low).\n\nCommon values of λ are:\n\n0 : No cell frequency prior, gives you the maximum likelihood estimator.\n0.05 is the optimum value for λ found in Buslje et. al. 2009, similar results was obtained for λ in the range [0.025, 0.075].\n1 / p : Perks prior (Perks, 1947) where p the number of parameters (i.e. residues, pairs of residues) to estimate. If p is the number of residues (20 without counting gaps), this gives you 0.05.\nsqrt(n) / p : Minimax prior (Trybula, 1958) where n is the number of samples and p the number of parameters to estimate. If the number of samples n is 400 (minimum number of sequence clusters for achieve good performance in Buslje et. al. 2009) for estimating 400 parameters (pairs of residues without counting gaps) this gives you 0.05.\n0.5 : Jeffreys prior (Jeffreys, 1946).\n1 : Bayes-Laplace uniform prior, aka. Laplace smoothing.\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.BLOSUM_Pseudofrequencies","page":"Information","title":"MIToS.Information.BLOSUM_Pseudofrequencies","text":"BLOSUM_Pseudofrequencies type. It takes to arguments/fields:\n\nα : Usually the number of sequences or sequence clusters in the MSA.\nβ : The weight of the pseudofrequencies, a value close to 8.512 when α is the number of sequence clusters.\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.ContingencyTable","page":"Information","title":"MIToS.Information.ContingencyTable","text":"A ContingencyTable is a multidimensional array. It stores the contingency matrix, its marginal values and total. The type also has an internal and private temporal array and an alphabet object. It's a parametric type, taking three ordered parameters:\n\nT : The element type of the multidimensional array.\nN : It's the dimension of the array and should be an Int.\nA : This should be a type, subtype of ResidueAlphabet, i.e.: UngappedAlphabet,\n\nGappedAlphabet or ReducedAlphabet.\n\nA ContingencyTable can be created from an alphabet if all the parameters are given. Otherwise, you need to give a type, a number (Val) and an alphabet. You can also create a ContingencyTable using a matrix and a alphabet. For example:\n\nContingencyTable{Float64, 2, UngappedAlphabet}(UngappedAlphabet())\nContingencyTable(Float64, Val{2}, UngappedAlphabet())\nContingencyTable(zeros(Float64,20,20), UngappedAlphabet())\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.Counts","page":"Information","title":"MIToS.Information.Counts","text":"A Counts object wraps a ContingencyTable storing counts/frequencies.\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.NoPseudocount","page":"Information","title":"MIToS.Information.NoPseudocount","text":"You can use NoPseudocount() to avoid pseudocount corrections where a Pseudocount type is needed.\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.NoPseudofrequencies","page":"Information","title":"MIToS.Information.NoPseudofrequencies","text":"You can use NoPseudofrequencies() to avoid pseudocount corrections where a Pseudofrequencies type is needed.\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.Probabilities","page":"Information","title":"MIToS.Information.Probabilities","text":"A Probabilities object wraps a ContingencyTable storing probabilities. It doesn't perform any check. If the total isn't one, you must use normalize or normalize!on the ContingencyTable before wrapping it to make the sum of the probabilities equal to one.\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.Pseudocount","page":"Information","title":"MIToS.Information.Pseudocount","text":"Parametric abstract type to define pseudocount types\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#MIToS.Information.Pseudofrequencies","page":"Information","title":"MIToS.Information.Pseudofrequencies","text":"Parametric abstract type to define pseudofrequencies types\n\n\n\n\n\n","category":"type"},{"location":"Information_API/#Constants","page":"Information","title":"Constants","text":"","category":"section"},{"location":"Information_API/","page":"Information","title":"Information","text":"Modules = [MIToS.Information]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"Information_API/#MIToS.Information.BLOSUM62_Pi","page":"Information","title":"MIToS.Information.BLOSUM62_Pi","text":"BLOSUM62 probabilities P(aa) for each residue on the UngappedAlphabet. SUM:  0.9987\n\n\n\n\n\n","category":"constant"},{"location":"Information_API/#MIToS.Information.BLOSUM62_Pij","page":"Information","title":"MIToS.Information.BLOSUM62_Pij","text":"Table with conditional probabilities of residues based on BLOSUM62. The normalization is done row based. The firts row contains the P(aa|A) and so one.\n\n\n\n\n\n","category":"constant"},{"location":"Information_API/#Macros","page":"Information","title":"Macros","text":"","category":"section"},{"location":"Information_API/","page":"Information","title":"Information","text":"Modules = [MIToS.Information]\nPrivate = false\nOrder   = [:macro]","category":"page"},{"location":"Information_API/#Methods-and-functions","page":"Information","title":"Methods and functions","text":"","category":"section"},{"location":"Information_API/","page":"Information","title":"Information","text":"Modules = [MIToS.Information]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"Information_API/#Base.count!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, N, A}, Any, MIToS.Information.Pseudocount, Vararg{AbstractVector{MIToS.MSA.Residue}, N}}} where {T, N, A}","page":"Information","title":"Base.count!","text":"It populates a ContingencyTable (first argument) using the frequencies in the sequences (last positional arguments). The dimension of the table must match the number of sequences and all the sequences must have the same length. You must indicate the used weights and pseudocounts as second and third positional arguments respectively. You can use NoPseudofrequencies() and NoClustering() to avoid the use of sequence weighting and pseudocounts, respectively.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#Base.count-Union{Tuple{Vararg{AbstractVector{MIToS.MSA.Residue}, N}}, Tuple{N}} where N","page":"Information","title":"Base.count","text":"It returns a ContingencyTable wrapped in a Counts type with the frequencies of residues in the sequences that takes as arguments. The dimension of the table is equal to the number of sequences. You can use the keyword arguments alphabet, weights and pseudocounts to indicate the alphabet of the table (default to UngappedAlphabet()), a clustering result (default to NoClustering()) and the pseudocounts (default to NoPseudocount()) to be used during the estimation of the frequencies.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#LinearAlgebra.normalize!-Union{Tuple{MIToS.Information.ContingencyTable{T, N, A}}, Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A}","page":"Information","title":"LinearAlgebra.normalize!","text":"normalize! makes the sum of the frequencies to be one, in place.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#LinearAlgebra.normalize-Union{Tuple{MIToS.Information.ContingencyTable{T, N, A}}, Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A}","page":"Information","title":"LinearAlgebra.normalize","text":"normalize returns another table where the sum of the frequencies is one.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.APC!-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Information","title":"MIToS.Information.APC!","text":"APC (Dunn et. al. 2008)\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.BLMI-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"Information","title":"MIToS.Information.BLMI","text":"BLMI takes a MSA or a file and a FileFormat as first arguments. It calculates a Z score (ZBLMI) and a corrected MI/MIp as described on Busjle et. al. 2009 but using using BLOSUM62 pseudo frequencies instead of a fixed pseudocount.\n\nKeyword argument, type, default value and descriptions:\n\n  - beta        Float64   8.512   β for BLOSUM62 pseudo frequencies\n  - lambda      Float64   0.0     Low count value\n  - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)\n  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation\n  - apc         Bool      true    Use APC correction (MIp)\n  - samples     Int       50      Number of samples for Z-score\n  - fixedgaps   Bool      true    Fix gaps positions for the random samples\n\nThis function returns:\n\n  - Z score (ZBLMI)\n  - MI or MIp using BLOSUM62 pseudo frequencies (BLMI/BLMIp)\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.apply_pseudocount!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, N, A}, T}} where {T, N, A}","page":"Information","title":"MIToS.Information.apply_pseudocount!","text":"It adds the pseudocount value to the table cells.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.apply_pseudofrequencies!-Union{Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, 2, MIToS.MSA.UngappedAlphabet}, MIToS.Information.BLOSUM_Pseudofrequencies}} where T","page":"Information","title":"MIToS.Information.apply_pseudofrequencies!","text":"apply_pseudofrequencies!{T}(Pab::ContingencyTable{T,2,UngappedAlphabet}, pseudofrequencies::BLOSUM_Pseudofrequencies)\n\nWhen a BLOSUM_Pseudofrequencies(α,β) is used, this function applies pseudofrequencies Gab over Pab, as a weighted mean of both. It uses the conditional probability matrix BLOSUM62_Pij and the real frequencies/probabilities Pab to estimate the pseudofrequencies Gab. α is the weight of the real frequencies Pab and β the weight of the pseudofrequencies.\n\nGab = Σcd  Pcd ⋅ BLOSUM62( a | c ) ⋅ BLOSUM62( b | d ) Pab = (α ⋅ Pab + β ⋅ Gab )/(α + β)\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.buslje09-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"Information","title":"MIToS.Information.buslje09","text":"buslje09 takes a MSA or a file and a FileFormat as first arguments. It calculates a Z score and a corrected MI/MIp as described on Busjle et. al. 2009.\n\nkeyword argument, type, default value and descriptions:\n\n  - lambda      Float64   0.05    Low count value\n  - clustering  Bool      true    Sequence clustering (Hobohm I)\n  - threshold             62      Percent identity threshold for clustering\n  - maxgap      Float64   0.5     Maximum fraction of gaps in positions included in calculation\n  - apc         Bool      true    Use APC correction (MIp)\n  - samples     Int       100     Number of samples for Z-score\n  - fixedgaps   Bool      true    Fix gaps positions for the random samples\n  - alphabet    ResidueAlphabet UngappedAlphabet()  Residue alphabet to be used\n\nThis function returns:\n\n  - Z score\n  - MI or MIp\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.cumulative-Union{Tuple{VT}, Tuple{D}, Tuple{T}, Tuple{PairwiseListMatrices.PairwiseListMatrix{T, D, VT}, T}} where {T, D, VT}","page":"Information","title":"MIToS.Information.cumulative","text":"cumulative allows to calculate cumulative scores (i.e. cMI) as defined in Buslje et. al. 2010\n\n\"We calculated a cumulative mutual information score (cMI) for each residue as the sum of MI values above a certain threshold for every amino acid pair where the particular residue appears. This value defines to what degree a given amino acid takes part in a mutual information network.\" Buslje, Cristina Marino, Elin Teppa, Tomas Di Doménico, José María Delfino, and Morten Nielsen. Networks of high mutual information define the structural proximity of catalytic sites: implications for catalytic residue identification. PLoS Comput Biol 6, no. 11 (2010): e1000978.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.delete_dimensions!-Union{Tuple{A}, Tuple{S}, Tuple{N}, Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, S, A}, MIToS.Information.ContingencyTable{T, N, A}, Vararg{Int64}}} where {T, N, S, A}","page":"Information","title":"MIToS.Information.delete_dimensions!","text":"delete_dimensions!(out::ContingencyTable, in::ContingencyTable, dimensions::Int...)\n\nThis function fills a ContingencyTable with the counts/probabilities on in after the deletion of dimensions. i.e. This is useful for getting Pxy from Pxyz.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.delete_dimensions-Union{Tuple{I}, Tuple{A}, Tuple{N}, Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, N, A}, Vararg{Int64, I}}} where {T, N, A, I}","page":"Information","title":"MIToS.Information.delete_dimensions","text":"delete_dimensions(in::ContingencyTable, dimensions::Int...)\n\nThis function creates a ContingencyTable with the counts/probabilities on in after the deletion of dimensions. i.e. This is useful for getting Pxy from Pxyz.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.gap_intersection_percentage-Union{Tuple{MIToS.Information.Counts{T, 2, MIToS.MSA.GappedAlphabet}}, Tuple{T}} where T","page":"Information","title":"MIToS.Information.gap_intersection_percentage","text":"It calculates the gap intersection as percentage from a table of Counts.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.gap_union_percentage-Union{Tuple{MIToS.Information.Counts{T, 2, MIToS.MSA.GappedAlphabet}}, Tuple{T}} where T","page":"Information","title":"MIToS.Information.gap_union_percentage","text":"It calculates the gap union as percentage from a table of Counts.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.getalphabet-Tuple{MIToS.Information.ContingencyTable}","page":"Information","title":"MIToS.Information.getalphabet","text":"getalphabet allows to access the stored alphabet object.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.getcontingencytable-Union{Tuple{MIToS.Information.Probabilities{T, N, A}}, Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A}","page":"Information","title":"MIToS.Information.getcontingencytable","text":"getcontingencytable allows to access the wrapped ContingencyTable in a Probabilities or Counts object.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.getmarginals-Tuple{MIToS.Information.ContingencyTable}","page":"Information","title":"MIToS.Information.getmarginals","text":"getmarginals allows to access the array with the marginal values (NamedArray).\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.getmarginalsarray-Tuple{MIToS.Information.ContingencyTable}","page":"Information","title":"MIToS.Information.getmarginalsarray","text":"getmarginalsarray allows to access the array with the marginal values (Array without names).\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.gettable-Tuple{MIToS.Information.ContingencyTable}","page":"Information","title":"MIToS.Information.gettable","text":"gettable allows to access the table (NamedArray).\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.gettablearray-Tuple{MIToS.Information.ContingencyTable}","page":"Information","title":"MIToS.Information.gettablearray","text":"gettablearray allows to access the table (Array without names).\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.gettotal-Tuple{MIToS.Information.ContingencyTable}","page":"Information","title":"MIToS.Information.gettotal","text":"gettotal allows to access the stored total value.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.kullback_leibler-Union{Tuple{A}, Tuple{T}, Tuple{MIToS.Information.Probabilities{T, 1, A}, Any, Real}} where {T, A}","page":"Information","title":"MIToS.Information.kullback_leibler","text":"It calculates the Kullback-Leibler (KL) divergence from a table of Probabilities. The second positional argument is a Probabilities or ContingencyTable with the background distribution. It's optional, the default is the BLOSUM62_Pi table. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.mapcolfreq!-Union{Tuple{A}, Tuple{T}, Tuple{Function, AbstractMatrix{MIToS.MSA.Residue}, Union{MIToS.Information.Counts{T, 1, A}, MIToS.Information.Probabilities{T, 1, A}}}} where {T, A}","page":"Information","title":"MIToS.Information.mapcolfreq!","text":"It efficiently map a function (first argument) that takes a table of Counts or Probabilities (third argument). The table is filled in place with the counts or probabilities of each column from the msa (second argument).\n\nweights (default: NoClustering()): Weights to be used for table counting.\npseudocounts (default: NoPseudocount()): Pseudocount object to be applied to table.\npseudofrequencies (default: NoPseudofrequencies()): Pseudofrequencies to be applied to the normalized (probabilities) table.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.mapcolpairfreq!-Union{Tuple{D}, Tuple{A}, Tuple{T}, Tuple{Function, AbstractMatrix{MIToS.MSA.Residue}, Union{MIToS.Information.Counts{T, 2, A}, MIToS.Information.Probabilities{T, 2, A}}}, Tuple{Function, AbstractMatrix{MIToS.MSA.Residue}, Union{MIToS.Information.Counts{T, 2, A}, MIToS.Information.Probabilities{T, 2, A}}, Type{Val{D}}}} where {T, A, D}","page":"Information","title":"MIToS.Information.mapcolpairfreq!","text":"It efficiently map a function (first argument) that takes a table of Counts or Probabilities (third argument). The table is filled in place with the counts or probabilities of each pair of columns from the msa (second argument). The fourth positional argument usediagonal indicates if the function should be applied to identical element pairs (default to Val{true}).\n\nweights (default: NoClustering()): Weights to be used for table counting.\npseudocounts (default: NoPseudocount()): Pseudocount object to be applied to table.\npseudofrequencies (default: NoPseudofrequencies()): Pseudofrequencies to be applied to the normalized (probabilities) table.\ndiagonalvalue (default: 0): Value to fill diagonal elements if usediagonal is Val{false}.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.mapseqfreq!-Union{Tuple{A}, Tuple{T}, Tuple{Function, AbstractMatrix{MIToS.MSA.Residue}, Union{MIToS.Information.Counts{T, 1, A}, MIToS.Information.Probabilities{T, 1, A}}}} where {T, A}","page":"Information","title":"MIToS.Information.mapseqfreq!","text":"It efficiently map a function (first argument) that takes a table of Counts or Probabilities (third argument). The table is filled in place with the counts or probabilities of each sequence from the msa (second argument).\n\nweights (default: NoClustering()): Weights to be used for table counting.\npseudocounts (default: NoPseudocount()): Pseudocount object to be applied to table.\npseudofrequencies (default: NoPseudofrequencies()): Pseudofrequencies to be applied to the normalized (probabilities) table.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.mapseqpairfreq!-Union{Tuple{D}, Tuple{A}, Tuple{T}, Tuple{Function, AbstractMatrix{MIToS.MSA.Residue}, Union{MIToS.Information.Counts{T, 2, A}, MIToS.Information.Probabilities{T, 2, A}}}, Tuple{Function, AbstractMatrix{MIToS.MSA.Residue}, Union{MIToS.Information.Counts{T, 2, A}, MIToS.Information.Probabilities{T, 2, A}}, Type{Val{D}}}} where {T, A, D}","page":"Information","title":"MIToS.Information.mapseqpairfreq!","text":"It efficiently map a function (first argument) that takes a table of Counts or Probabilities (third argument). The table is filled in place with the counts or probabilities of each pair of sequences from the msa (second argument). The fourth positional argument usediagonal indicates if the function should be applied to identical element pairs (default to Val{true}).\n\nweights (default: NoClustering()): Weights to be used for table counting.\npseudocounts (default: NoPseudocount()): Pseudocount object to be applied to table.\npseudofrequencies (default: NoPseudofrequencies()): Pseudofrequencies to be applied to the normalized (probabilities) table.\ndiagonalvalue (default: 0): Value to fill diagonal elements if usediagonal is Val{false}.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.marginal_entropy-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{MIToS.Information.Counts{T, N, A}, MIToS.Information.Probabilities{T, N, A}}, Int64, Real}} where {T, N, A}","page":"Information","title":"MIToS.Information.marginal_entropy","text":"It calculates marginal entropy (H) from a table of Counts or Probabilities. The second positional argument is used to indicate the magin used to calculate the entropy, e.g. it estimates the entropy H(X) if marginal is 1, H(Y) for 2, etc. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.mutual_information-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{MIToS.Information.Counts{T, N, A}, MIToS.Information.Probabilities{T, N, A}}, Real}} where {T, N, A}","page":"Information","title":"MIToS.Information.mutual_information","text":"It calculates Mutual Information (MI) from a table of Counts or Probabilities. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits. Calculation of MI from Counts is faster than from Probabilities.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.normalized_mutual_information-Union{Tuple{Union{MIToS.Information.Counts{T, N, A}, MIToS.Information.Probabilities{T, N, A}}}, Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A}","page":"Information","title":"MIToS.Information.normalized_mutual_information","text":"It calculates a Normalized Mutual Information (nMI) by Entropy from a table of Counts or Probabilities.\n\nnMI(X, Y) = MI(X, Y) / H(X, Y)\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.pairwisegapfraction-Tuple{AbstractMatrix{MIToS.MSA.Residue}}","page":"Information","title":"MIToS.Information.pairwisegapfraction","text":"It takes a MSA or a file and a FileFormat as first arguments. It calculates the percentage of gaps on columns pairs (union and intersection) using sequence clustering (Hobohm I).\n\nArgument, type, default value and descriptions:\n\n    - clustering  Bool      true    Sequence clustering (Hobohm I)\n    - threshold             62      Percent identity threshold for sequence clustering (Hobohm I)\n\nThis function returns:\n\n    - pairwise gap union as percentage\n    - pairwise gap intersection as percentage\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.probabilities!-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{MIToS.Information.ContingencyTable{T, N, A}, Any, MIToS.Information.Pseudocount, MIToS.Information.Pseudofrequencies, Vararg{AbstractVector{MIToS.MSA.Residue}, N}}} where {T, N, A}","page":"Information","title":"MIToS.Information.probabilities!","text":"It populates a ContingencyTable (first argument) using the probabilities in the sequences (last positional arguments). The dimension of the table must match the number of sequences and all the sequences must have the same length. You must indicate the used weights, pseudocounts and pseudofrequencies as second, third and fourth positional arguments respectively. You can use NoClustering(), NoPseudocount() and NoPseudofrequencies() to avoid the use of sequence weighting, pseudocounts and pseudofrequencies, respectively.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#MIToS.Information.probabilities-Union{Tuple{Vararg{AbstractVector{MIToS.MSA.Residue}, N}}, Tuple{N}} where N","page":"Information","title":"MIToS.Information.probabilities","text":"It returns a ContingencyTable wrapped in a Probabilities type with the frequencies of residues in the sequences that takes as arguments. The dimension of the table is equal to the number of sequences. You can use the keyword arguments alphabet, weights, pseudocounts and pseudofrequencies to indicate the alphabet of the table (default to UngappedAlphabet()), a clustering result (default to NoClustering()),  the pseudocounts (default to NoPseudocount()) and the pseudofrequencies (default to NoPseudofrequencies()) to be used during the estimation of the probabilities.\n\n\n\n\n\n","category":"method"},{"location":"Information_API/#StatsBase.entropy-Union{Tuple{A}, Tuple{N}, Tuple{T}, Tuple{Union{MIToS.Information.Counts{T, N, A}, MIToS.Information.Probabilities{T, N, A}}, Real}} where {T, N, A}","page":"Information","title":"StatsBase.entropy","text":"It calculates the Shannon entropy (H) from a table of Counts or Probabilities. Use last and optional positional argument to change the base of the log. The default base is e, so the result is in nats. You can use 2.0 as base to get the result in bits.\n\n\n\n\n\n","category":"method"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"@info \"SIFTS API docs\"","category":"page"},{"location":"SIFTS_API/#SIFTS","page":"SIFTS","title":"SIFTS","text":"","category":"section"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"MIToS.SIFTS","category":"page"},{"location":"SIFTS_API/#MIToS.SIFTS","page":"SIFTS","title":"MIToS.SIFTS","text":"The SIFTS module of MIToS allows to obtain the residue-level mapping between databases stored in the SIFTS XML files. It makes easy to assign PDB residues to UniProt/Pfam positions. Given the fact that pairwise alignments can lead to misleading association between residues in both sequences, SIFTS offers  more reliable association between sequence and structure residue numbers.\n\nFeatures\n\nDownload and parse SIFTS XML files\nStore residue-level mapping in Julia\nEasy generation of OrderedDicts between residues numbers\n\nusing MIToS.SIFTS\n\n\n\n\n\n","category":"module"},{"location":"SIFTS_API/#Contents","page":"SIFTS","title":"Contents","text":"","category":"section"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"Pages = [\"SIFTS_API.md\"]\nDepth = 2","category":"page"},{"location":"SIFTS_API/#Types","page":"SIFTS","title":"Types","text":"","category":"section"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"Modules = [MIToS.SIFTS]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"SIFTS_API/#MIToS.SIFTS.SIFTSResidue","page":"SIFTS","title":"MIToS.SIFTS.SIFTSResidue","text":"A SIFTSResidue object stores the SIFTS residue level mapping for a residue. It has the following fields that you can access at any moment for query purposes:\n\n- `PDBe` : A `dbPDBe` object, it's present in all the `SIFTSResidue`s.\n- `UniProt` : A `dbUniProt` object or `missing`.\n- `Pfam` : A `dbPfam` object or `missing`.\n- `NCBI` : A `dbNCBI` object or `missing`.\n- `InterPro` : An array of `dbInterPro` objects.\n- `PDB` : A `dbPDB` object or `missing`.\n- `SCOP` : A `dbSCOP` object or `missing`.\n- `SCOP2` : An array of `dbSCOP2` objects.\n- `SCOP2B` : A `dbSCOP2B` object or `missing`.\n- `CATH` : A `dbCATH` object or `missing`.\n- `Ensembl` : An array of `dbEnsembl` objects.\n- `missing` : It's `true` if the residue is missing, i.e. not observed, in the structure.\n- `sscode` : A string with the secondary structure code of the residue.\n- `ssname` : A string with the secondary structure name of the residue.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbCATH","page":"SIFTS","title":"MIToS.SIFTS.dbCATH","text":"dbCATH stores the residue id, number, name and chain in CATH as  strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbEnsembl","page":"SIFTS","title":"MIToS.SIFTS.dbEnsembl","text":"dbEnsembl stores the residue (gene) accession id, the transcript, translation and exon ids in Ensembl as strings, together with the residue number and name using the UniProt coordinates.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbInterPro","page":"SIFTS","title":"MIToS.SIFTS.dbInterPro","text":"dbInterPro stores the residue id, number, name and evidence in InterPro as strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbNCBI","page":"SIFTS","title":"MIToS.SIFTS.dbNCBI","text":"dbNCBI stores the residue id, number and name in NCBI as strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbPDB","page":"SIFTS","title":"MIToS.SIFTS.dbPDB","text":"dbPDB stores the residue id, number, name and chain in PDB as strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbPDBe","page":"SIFTS","title":"MIToS.SIFTS.dbPDBe","text":"dbPDBe stores the residue number and name in PDBe as strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbPfam","page":"SIFTS","title":"MIToS.SIFTS.dbPfam","text":"dbPfam stores the residue id, number and name in Pfam as strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbSCOP","page":"SIFTS","title":"MIToS.SIFTS.dbSCOP","text":"dbSCOP stores the residue id, number, name and chain in SCOP as  strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbSCOP2","page":"SIFTS","title":"MIToS.SIFTS.dbSCOP2","text":"dbSCOP2 stores the residue id, number, name and chain in SCOP2 as  strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbSCOP2B","page":"SIFTS","title":"MIToS.SIFTS.dbSCOP2B","text":"dbSCOP2B stores the residue id, number, name and chain in SCOP2B as  strings. SCOP2B is expansion of SCOP2 domain annotations at superfamily  level to every PDB with same UniProt accession having at least 80% SCOP2  domain coverage.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#MIToS.SIFTS.dbUniProt","page":"SIFTS","title":"MIToS.SIFTS.dbUniProt","text":"dbUniProt stores the residue id, number and name in UniProt as strings.\n\n\n\n\n\n","category":"type"},{"location":"SIFTS_API/#Constants","page":"SIFTS","title":"Constants","text":"","category":"section"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"Modules = [MIToS.SIFTS]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"SIFTS_API/#Macros","page":"SIFTS","title":"Macros","text":"","category":"section"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"Modules = [MIToS.SIFTS]\nPrivate = false\nOrder   = [:macro]","category":"page"},{"location":"SIFTS_API/#Methods-and-functions","page":"SIFTS","title":"Methods and functions","text":"","category":"section"},{"location":"SIFTS_API/","page":"SIFTS","title":"SIFTS","text":"Modules = [MIToS.SIFTS]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"SIFTS_API/#Base.parse-Tuple{LightXML.XMLDocument, Type{MIToS.SIFTS.SIFTSXML}}","page":"SIFTS","title":"Base.parse","text":"parse(document::LightXML.XMLDocument, ::Type{SIFTSXML}; chain=All, missings::Bool=true)\n\nReturns a Vector{SIFTSResidue} parsed from a SIFTSXML file. By default, parses all the chains and includes missing residues.\n\n\n\n\n\n","category":"method"},{"location":"SIFTS_API/#MIToS.SIFTS.downloadsifts-Tuple{String}","page":"SIFTS","title":"MIToS.SIFTS.downloadsifts","text":"Download the gzipped SIFTS xml  for the pdbcode. The extension of the downloaded file is .xml.gz by default. The filename can be changed, but the .xml.gz at the end is mandatory. Extra keyword arguments are passed to download_file.\n\n\n\n\n\n","category":"method"},{"location":"SIFTS_API/#MIToS.SIFTS.siftsmapping-Union{Tuple{T}, Tuple{F}, Tuple{String, Type{F}, String, Type{T}, String}} where {F, T}","page":"SIFTS","title":"MIToS.SIFTS.siftsmapping","text":"Parses a SIFTS XML file and returns a OrderedDict between residue numbers of  two DataBases with the given identifiers. A chain could be specified  (All by default). If missings is true (default) all the residues are  used, even if they haven’t coordinates in the PDB file.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"(Image: MIToS.jl)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MIToS is an environment for Mutual Information (MI) analysis and implements several useful tools for Multiple Sequence Alignments (MSAs) and PDB structures management in the Julia language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for MIToS v2 in Julia v1. If you are using MIToS 1.0 in Julia 0.4, please read this documentation  instead.  ","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIToS tools are separated on different modules, related to different tasks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MSA : This module defines multiple functions and types for dealing with MSAs and their annotations. It also includes facilities for sequence clustering.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PDB : This module defines types and methods to work with protein structures from PDB.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SIFTS : This module allows access to SIFTS residue-level mapping of UniProt, Pfam and other databases with PDB entries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Information : This module defines residue contingency tables and methods on them to estimate information measure from MSAs. It includes functions to estimate corrected mutual information (ZMIp, ZBLMIp) between MSA columns.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pfam : This module use the previous modules to work with Pfam MSAs. It also has useful parameter optimization functions to be used with Pfam alignments.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Utils : MIToS has also an Utils module with common utils functions and types used in this package.  ","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use MIToS, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Diego J. Zea, Diego Anfossi, Morten Nielsen, Cristina Marino-Buslje; MIToS.jl: mutual information tools for protein sequence analysis in the Julia language, Bioinformatics, Volume 33, Issue 4, 15 February 2017, Pages 564–565, https://doi.org/10.1093/bioinformatics/btw646  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Leloir Institute Foundation)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Structural Bioinformatics Unit, Leloir Institute Foundation. Av. Patricias Argentinas 435, CP C1405BWE, Buenos Aires, Argentina","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"@info \"Installation docs\"","category":"page"},{"location":"Installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"First you need to install Julia.(Image: ) MIToS' stable version can be installed by typing on the Julia REPL:  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"MIToS\")","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"If everything goes well with the installation, MIToS will be loaded without errors by typing:  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using MIToS","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"You can optionally do an exhaustive test of your installed version of MIToS with Pkg.test (it takes few minutes):  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.test(\"MIToS\")","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"note: Note\nWays to run Julia  Option Description\nJulia REPL(Image: ) Built-in Julia command line. Start an Julia interactive session (REPL) by double-clicking the Julia executable or running julia from the system command line.\nJuliaBox(Image: ) You can try Julia from your web browser. No installation is required.\nIJulia(Image: ) Jupyter/IPython notebook for Julia.\nJuno(Image: ) Integrated Development Environment (IDE).","category":"page"},{"location":"Installation/#Plots-installation","page":"Installation","title":"Plots installation","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"Julia plotting capabilities are available through external packages. MIToS makes use of  RecipesBase to define plot recipes, which can be plotted using  Plots(Image: ) and different  backends. You need to install Plots(Image: )  to plot MIToS objects:  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Plots\")","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"And you also need to install at least one of the following backends:  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"GR\") # Fast\nPkg.add(\"PlotlyJS\") # Interactive","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"You need to load Plots in order to use the plot function. There is more information about it in the Plots documentation(Image: ).  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using Plots","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"To generate graph (network), arc and chord (circo) plots, you also need to install and load GraphRecipes(Image: ).  ","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"Pkg.add(\"GraphRecipes\")\n\nusing GraphRecipes","category":"page"},{"location":"Installation/#Scripts-location","page":"Installation","title":"Scripts location","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"The MIToS’ scripts are located in the MIToS/scripts folder and can be runned from your system command line. It’s possible to ask Julia for the location of the installed package using:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"import MIToS\njoinpath(splitdir(dirname(pathof(MIToS)))[1], \"scripts\")","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"You might want to add this folder into your PATH to easily access MIToS’ scripts.   For example, in bash you can do it by adding the path of the MIToS script folder into the ~/.bashrc file. The println output shows the line to add to that file:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"import MIToS\nprintln(\"export PATH=\\\"\\$PATH:\", joinpath(splitdir(dirname(pathof(MIToS)))[1], \"scripts\"), \"\\\"\")","category":"page"}]
}
