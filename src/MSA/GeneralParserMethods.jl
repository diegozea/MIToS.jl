# Mappings
# ========

function _fill_aln_seq_ann!(aln, seq_ann::Vector{String}, seq::String,
                            init::Int, nres::Int, i)
    if length(seq) != nres
        throw(ErrorException(string(
            "There is and aligned sequence with different number of columns [ ",
            length(seq), " != ", nres, " ]:\n", seq)))
    end
    j = 1
    @inbounds for res in seq
        aln[j,i] = res
        if res != '-' && res != '.'
            seq_ann[j] = string(init)
            init += 1
        else
            seq_ann[j] = ""
        end
        j += 1
    end
    join(seq_ann, ','), init - 1
end

function _to_msa_mapping(sequences::Array{String,1})
    nseq = size(sequences,1)
    nres = length(sequences[1])
    aln = Array(Residue, nres, nseq)
    mapp = Array(String, nseq)
    seq_ann = Array(String, nres)
    for i in 1:nseq
        mapp[i], last = _fill_aln_seq_ann!(aln, seq_ann, sequences[i], 1, nres, i)
    end
    msa = NamedArray(permutedims(aln, [2,1]))
    # MSA constructors adds dimension names
    # setdimnames!(msa, ("Seq","Col"))
    (msa, mapp)
end

function _to_msa_mapping(sequences::Array{String,1}, ids::Array{String,1})
    nseq = size(sequences,1)
    nres = length(sequences[1])
    aln = Array(Residue, nres, nseq)
    mapp = Array(String, nseq)
    seq_ann = Array(String, nres)
    sep = r"/|-"
    for i in 1:nseq
        fields = split(ids[i], sep)
        init  = length(fields) == 3 ? parse(Int, fields[2]) : 1
        mapp[i], last = _fill_aln_seq_ann!(aln, seq_ann, sequences[i], init, nres, i)
        if length(fields) == 3
            end_coordinate = parse(Int, fields[3])
            if last != end_coordinate
                throw(ErrorException(string("The last residue number ", last,
                    " in sequence ", i, " isn't the end coordinate ", end_coordinate)))
            end
        end
    end
    msa = NamedArray(permutedims(aln, [2,1]))
    # MSA constructors adds dimension names
    # setdimnames!(msa, ("Seq","Col"))
    setnames!(msa, ids, 1)
    msa, mapp
end

# Delete Full of Gap Columns
# ==========================

"""
Deletes columns with 100% gaps, this columns are generated by inserts.
"""
function deletefullgapcolumns!(msa::AbstractMultipleSequenceAlignment, annotate::Bool=true)
    mask = vec(columngapfraction(msa) .!= one(Float64))
    number = sum(~mask)
    if number != 0
        annotate && annotate_modification!(msa, string("deletefullgaps!  :  Deletes ",
            number, " columns full of gaps (inserts generate full gap columns on MIToS ",
            "because lowercase and dots are not allowed)"))
        filtercolumns!(msa, mask, annotate)
    end
    msa
end

function deletefullgapcolumns(msa::AbstractMatrix{Residue})
    mask = vec(columngapfraction(msa) .!= one(Float64))
    number = sum(~mask)
    if number != 0
        return(filtercolumns(msa, mask))
    end
    msa
end

function deletefullgapcolumns(msa::AbstractMultipleSequenceAlignment, annotate::Bool=true)
    deletefullgapcolumns!(copy(msa), annotate)
end

@doc """
`parse(io::Union{IO, AbstractString}, format[, output; generatemapping::Bool=false, useidcoordinates::Bool=false, deletefullgaps::Bool=true ])`

The keyword argument `generatemapping` (`false` by default) indicates if the mapping of the
sequences ("SeqMap") and columns ("ColMap") and the number of columns in the original MSA
("NCol") should be generated and saved in the annotations. If `useidcoordinates` is `true`
(default: `false`) the sequence IDs of the form "ID/start-end" are parsed and used for
determining the start and end positions when the mappings are generated. `deletefullgaps`
(`true` by default) indicates if columns 100% gaps (generally inserts from a HMM) must be
removed from the MSA.
""" parse

# Keepinserts
# ===========

"""
Function to keep insert columns in `parse`. It uses the first sequence to generate the
"Aligned" annotation, and after that, convert all the characters to uppercase.
"""
function _keepinserts!(SEQS, annot)
    aligned = map(SEQS[1]) do char
        isupper(char) || char == '-' ? '1' : '0'
    end
    setannotcolumn!(annot, "Aligned", aligned)
    map!(uppercase, SEQS)
end

function _strings_to_msa(::Type{Matrix{Residue}}, seqs::Vector{String},
                        deletefullgaps::Bool)
    msa = convert(Matrix{Residue}, seqs)
    if deletefullgaps
        return( deletefullgapcolumns(msa) )
    end
    msa
end

function _strings_to_msa(::Type{NamedArray{Residue,2}}, seqs::Vector{String},
                        deletefullgaps::Bool)
    msa = NamedArray(convert(Matrix{Residue}, seqs))
    setdimnames!(msa, ("Seq","Col"))
    if deletefullgaps
        return( deletefullgapcolumns(msa) )
    end
    msa
end
